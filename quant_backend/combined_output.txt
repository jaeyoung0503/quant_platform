
==================================================
File: C:\Aproject\quant_backend\combine.py
==================================================
import os

# ì„¤ì •
input_dirs = [
    r"C:\Aproject\quant_backend",
    # r"C:\Aproject\quant-platform\quant-trading-platform\backend",
    # r"C:\Aproject\quant-platform\src",
    # r"C:\Aproject\quant-platform\backtester"
]  # ì…ë ¥ ë””ë ‰í† ë¦¬ ëª©ë¡
output_file = r"C:\Aproject\quant_backend\combined_output.txt"  # ì¶œë ¥ íŒŒì¼
file_extensions = [".py", ".ts", ".tsx", ".js", ".json"]  # í¬í•¨í•  íŒŒì¼ í™•ì¥ì

def combine_files():
    # ì¶œë ¥ íŒŒì¼ ì´ˆê¸°í™”
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # ê° ì…ë ¥ ë””ë ‰í† ë¦¬ ìˆœíšŒ
        for dir_path in input_dirs:
            if not os.path.exists(dir_path):
                outfile.write(f"\n{'='*50}\n")
                outfile.write(f"Directory not found: {dir_path}\n")
                outfile.write(f"{'='*50}\n")
                continue

            # ë””ë ‰í† ë¦¬ ë‚´ íŒŒì¼ ìˆœíšŒ
            for root, dirs, files in os.walk(dir_path):
                # node_modules ë° .next ë””ë ‰í† ë¦¬ ì œì™¸
                if 'node_modules' in dirs:
                    dirs.remove('node_modules')  # node_modules ì œì™¸
                if '.next' in dirs:
                    dirs.remove('.next')  # .next ë””ë ‰í† ë¦¬ ì œì™¸
                for file in files:
                    if any(file.endswith(ext) for ext in file_extensions):  # ì§€ì •ëœ í™•ì¥ì í™•ì¸
                        file_path = os.path.join(root, file)
                        try:
                            # íŒŒì¼ ë‚´ìš© ì½ê¸°
                            with open(file_path, 'r', encoding='utf-8') as infile:
                                content = infile.read()
                            # ì¶œë ¥ íŒŒì¼ì— íŒŒì¼ ê²½ë¡œì™€ ë‚´ìš© ê¸°ë¡
                            outfile.write(f"\n{'='*50}\n")
                            outfile.write(f"File: {file_path}\n")
                            outfile.write(f"{'='*50}\n")
                            outfile.write(content)
                            outfile.write("\n\n")  # íŒŒì¼ ê°„ êµ¬ë¶„ì„ ìœ„í•œ ë¹ˆ ì¤„
                        except UnicodeDecodeError:
                            # ì¸ì½”ë”© ì˜¤ë¥˜ ì‹œ cp949 ì‹œë„
                            try:
                                with open(file_path, 'r', encoding='cp949') as infile:
                                    content = infile.read()
                                outfile.write(f"\n{'='*50}\n")
                                outfile.write(f"File: {file_path} (encoded in cp949)\n")
                                outfile.write(f"{'='*50}\n")
                                outfile.write(content)
                                outfile.write("\n\n")
                            except Exception as e:
                                outfile.write(f"\n{'='*50}\n")
                                outfile.write(f"Error reading {file_path}: {str(e)}\n")
                                outfile.write(f"{'='*50}\n")
                        except Exception as e:
                            outfile.write(f"\n{'='*50}\n")
                            outfile.write(f"Error reading {file_path}: {str(e)}\n")
                            outfile.write(f"{'='*50}\n")

if __name__ == "__main__":
    combine_files()
    print(f"ëª¨ë“  íŒŒì¼ì´ {output_file}ë¡œ í•©ì³ì¡ŒìŠµë‹ˆë‹¤.")


==================================================
File: C:\Aproject\quant_backend\app\config.py
==================================================
# config.py - í™˜ê²½ ì„ íƒ ê¸°ëŠ¥ ì¶”ê°€
import os
from typing import Optional
from dataclasses import dataclass

try:
    from pydantic_settings import BaseSettings
except ImportError:
    from pydantic import BaseSettings

@dataclass
class KISEnvironment:
    """KIS API í™˜ê²½ ì„¤ì •"""
    name: str
    app_key: str
    app_secret: str
    base_url: str
    ws_url: str
    account_number: str
    account_product_code: str = "01"

class KISSettings(BaseSettings):
    """KIS API ì„¤ì • (í™˜ê²½ë³„ ë¶„ë¦¬)"""
    
    # ëª¨ì˜íˆ¬ì í™˜ê²½
    MOCK_APP_KEY: str = ""
    MOCK_APP_SECRET: str = ""
    MOCK_ACCOUNT_NUMBER: str = ""
    MOCK_BASE_URL: str = "https://openapi.koreainvestment.com:9443"
    MOCK_WS_URL: str = "wss://openapi.koreainvestment.com:9443"
    
    # ì‹¤ì „íˆ¬ì í™˜ê²½
    REAL_APP_KEY: str = ""
    REAL_APP_SECRET: str = ""
    REAL_ACCOUNT_NUMBER: str = ""
    REAL_BASE_URL: str = "https://openapi.koreainvestment.com:9443"
    REAL_WS_URL: str = "wss://openapi.koreainvestment.com:9443"
    
    # ê³µí†µ ì„¤ì •
    ACCOUNT_PRODUCT_CODE: str = "01"
    
    # í˜„ì¬ ì„ íƒëœ í™˜ê²½
    CURRENT_ENVIRONMENT: str = "mock"  # "mock" ë˜ëŠ” "real"
    
    class Config:
        env_file = ".env"
        case_sensitive = True

class EnvironmentSelector:
    """í™˜ê²½ ì„ íƒ ë° ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.settings = KISSettings()
        self.current_env: Optional[KISEnvironment] = None
    
    def get_available_environments(self) -> dict:
        """ì‚¬ìš© ê°€ëŠ¥í•œ í™˜ê²½ ëª©ë¡ ë°˜í™˜"""
        environments = {}
        
        # ëª¨ì˜íˆ¬ì í™˜ê²½ ì²´í¬
        if self.settings.MOCK_APP_KEY and self.settings.MOCK_APP_SECRET:
            environments["mock"] = KISEnvironment(
                name="ëª¨ì˜íˆ¬ì",
                app_key=self.settings.MOCK_APP_KEY,
                app_secret=self.settings.MOCK_APP_SECRET,
                base_url=self.settings.MOCK_BASE_URL,
                ws_url=self.settings.MOCK_WS_URL,
                account_number=self.settings.MOCK_ACCOUNT_NUMBER,
                account_product_code=self.settings.ACCOUNT_PRODUCT_CODE
            )
        
        # ì‹¤ì „íˆ¬ì í™˜ê²½ ì²´í¬
        if self.settings.REAL_APP_KEY and self.settings.REAL_APP_SECRET:
            environments["real"] = KISEnvironment(
                name="ì‹¤ì „íˆ¬ì",
                app_key=self.settings.REAL_APP_KEY,
                app_secret=self.settings.REAL_APP_SECRET,
                base_url=self.settings.REAL_BASE_URL,
                ws_url=self.settings.REAL_WS_URL,
                account_number=self.settings.REAL_ACCOUNT_NUMBER,
                account_product_code=self.settings.ACCOUNT_PRODUCT_CODE
            )
        
        return environments
    
    def select_environment_interactive(self) -> KISEnvironment:
        """ëŒ€í™”í˜• í™˜ê²½ ì„ íƒ"""
        environments = self.get_available_environments()
        
        if not environments:
            print("âŒ ì„¤ì •ëœ í™˜ê²½ì´ ì—†ìŠµë‹ˆë‹¤. .env íŒŒì¼ì„ í™•ì¸í•˜ì„¸ìš”.")
            print("\ní•„ìš”í•œ í™˜ê²½ë³€ìˆ˜:")
            print("MOCK_APP_KEY, MOCK_APP_SECRET, MOCK_ACCOUNT_NUMBER")
            print("REAL_APP_KEY, REAL_APP_SECRET, REAL_ACCOUNT_NUMBER")
            raise ValueError("ì‚¬ìš© ê°€ëŠ¥í•œ í™˜ê²½ì´ ì—†ìŠµë‹ˆë‹¤")
        
        print(f"\n" + "="*60)
        print(f"ğŸ¯ KIS API í™˜ê²½ ì„ íƒ")
        print(f"="*60)
        
        # í™˜ê²½ ëª©ë¡ ì¶œë ¥
        env_list = list(environments.items())
        for i, (key, env) in enumerate(env_list, 1):
            key_preview = f"{env.app_key[:4]}****{env.app_key[-4:]}" if len(env.app_key) >= 8 else "****"
            account_preview = f"{env.account_number[:4]}****" if len(env.account_number) >= 8 else "****"
            
            print(f"{i}. {env.name}")
            print(f"   â”œâ”€ ì•±í‚¤: {key_preview}")
            print(f"   â”œâ”€ ê³„ì¢Œ: {account_preview}")
            print(f"   â””â”€ URL: {env.base_url}")
        
        # ì‚¬ìš©ì ì„ íƒ ì…ë ¥
        while True:
            try:
                print(f"\ní™˜ê²½ì„ ì„ íƒí•˜ì„¸ìš” (1-{len(env_list)}): ", end="")
                choice = input().strip()
                
                if choice.isdigit() and 1 <= int(choice) <= len(env_list):
                    selected_key, selected_env = env_list[int(choice) - 1]
                    
                    # í™•ì¸ ë©”ì‹œì§€
                    print(f"\nâœ… '{selected_env.name}' í™˜ê²½ ì„ íƒë¨")
                    print(f"ê³„ì† ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/N): ", end="")
                    confirm = input().strip().lower()
                    
                    if confirm in ['y', 'yes', 'ã…‡']:
                        self.current_env = selected_env
                        self.settings.CURRENT_ENVIRONMENT = selected_key
                        return selected_env
                    else:
                        print("ì„ íƒì„ ì·¨ì†Œí•©ë‹ˆë‹¤.")
                        continue
                        
                else:
                    print(f"âŒ ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤. 1-{len(env_list)} ì¤‘ì—ì„œ ì„ íƒí•˜ì„¸ìš”.")
                    
            except KeyboardInterrupt:
                print("\n\nâŒ ì‚¬ìš©ìê°€ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
                exit(1)
            except Exception as e:
                print(f"âŒ ì…ë ¥ ì˜¤ë¥˜: {e}")
    
    def select_environment_auto(self, env_type: str = "mock") -> KISEnvironment:
        """ìë™ í™˜ê²½ ì„ íƒ (ëª…ë ¹í–‰ ì¸ìˆ˜ìš©)"""
        environments = self.get_available_environments()
        
        if env_type not in environments:
            available = list(environments.keys())
            raise ValueError(f"í™˜ê²½ '{env_type}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‚¬ìš© ê°€ëŠ¥: {available}")
        
        selected_env = environments[env_type]
        self.current_env = selected_env
        self.settings.CURRENT_ENVIRONMENT = env_type
        
        print(f"ğŸ¯ ìë™ ì„ íƒ: {selected_env.name} í™˜ê²½")
        return selected_env
    
    def get_current_environment(self) -> Optional[KISEnvironment]:
        """í˜„ì¬ ì„ íƒëœ í™˜ê²½ ë°˜í™˜"""
        return self.current_env
    
    def print_environment_info(self):
        """í˜„ì¬ í™˜ê²½ ì •ë³´ ì¶œë ¥"""
        if not self.current_env:
            print("âŒ ì„ íƒëœ í™˜ê²½ì´ ì—†ìŠµë‹ˆë‹¤.")
            return
        
        env = self.current_env
        print(f"\n" + "="*50)
        print(f"ğŸŒ í˜„ì¬ KIS API í™˜ê²½")
        print(f"="*50)
        print(f"í™˜ê²½: {env.name}")
        print(f"URL: {env.base_url}")
        print(f"WebSocket: {env.ws_url}")
        print(f"ê³„ì¢Œ: {env.account_number}")
        print(f"ì•±í‚¤: {env.app_key[:4]}****{env.app_key[-4:]}")
        print(f"="*50)





==================================================
File: C:\Aproject\quant_backend\app\main.py
==================================================
# main.py ìˆ˜ì • - í™˜ê²½ ì„ íƒ ê¸°ëŠ¥ í†µí•©
import asyncio
import sys
import argparse
from typing import Optional
from datetime import datetime

from config import EnvironmentSelector  # ìƒˆë¡œ ì¶”ê°€í•œ í´ë˜ìŠ¤
from services.kis_auth import KISAuth
from services.kis_websocket import KISWebSocket  # ê¸°ì¡´ íŒŒì¼ëª… ì‚¬ìš©


# ì „ì—­ ë³€ìˆ˜
env_selector: Optional[EnvironmentSelector] = None
kis_auth: Optional[KISAuth] = None
kis_ws: Optional[KISWebSocketStrategy] = None

def parse_arguments():
    """ëª…ë ¹í–‰ ì¸ìˆ˜ íŒŒì‹±"""
    parser = argparse.ArgumentParser(description='KIS ì‹¤ì‹œê°„ í€€íŠ¸ ì „ëµ ì‹œìŠ¤í…œ')
    parser.add_argument(
        '--env', 
        choices=['mock', 'real', 'interactive'], 
        default='interactive',
        help='ì‹¤í–‰ í™˜ê²½ ì„ íƒ (mock: ëª¨ì˜íˆ¬ì, real: ì‹¤ì „íˆ¬ì, interactive: ëŒ€í™”í˜• ì„ íƒ)'
    )
    parser.add_argument(
        '--stocks',
        nargs='+',
        default=['005930', '000660'],
        help='ëª¨ë‹ˆí„°ë§í•  ì¢…ëª© ì½”ë“œ (ì˜ˆ: --stocks 005930 000660 035720)'
    )
    parser.add_argument(
        '--auto-execute',
        action='store_true',
        help='ìë™ ì‹¤í–‰ ëª¨ë“œ í™œì„±í™”'
    )
    
    return parser.parse_args()

async def initialize_environment(env_type: str = "interactive"):
    """í™˜ê²½ ì´ˆê¸°í™”"""
    global env_selector, kis_auth, kis_ws
    
    try:
        print(f"\nğŸš€ KIS í€€íŠ¸ ì „ëµ ì‹œìŠ¤í…œ ì‹œì‘")
        print(f"ì‹œì‘ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        # í™˜ê²½ ì„ íƒ
        env_selector = EnvironmentSelector()
        
        if env_type == "interactive":
            selected_env = env_selector.select_environment_interactive()
        else:
            selected_env = env_selector.select_environment_auto(env_type)
        
        # ì„ íƒëœ í™˜ê²½ ì •ë³´ ì¶œë ¥
        env_selector.print_environment_info()
        
        # ì¸ì¦ ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
        print(f"\nğŸ”‘ {selected_env.name} ì¸ì¦ ì„œë¹„ìŠ¤ ì´ˆê¸°í™” ì¤‘...")
        kis_auth = KISAuth(
            app_key=selected_env.app_key,
            app_secret=selected_env.app_secret,
            base_url=selected_env.base_url,
            account_number=selected_env.account_number
        )
        
        # í† í° ë°œê¸‰ í…ŒìŠ¤íŠ¸
        await kis_auth.get_access_token()
        print(f"âœ… {selected_env.name} ì¸ì¦ ì™„ë£Œ")
        
        # WebSocket ì „ëµ ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
        print(f"ğŸ“¡ ì‹¤ì‹œê°„ ì „ëµ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...")
        kis_ws = KISWebSocketStrategy(kis_auth, selected_env.ws_url)
        
        print(f"âœ… {selected_env.name} í™˜ê²½ ì´ˆê¸°í™” ì™„ë£Œ!")
        return selected_env
        
    except Exception as e:
        print(f"âŒ í™˜ê²½ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
        raise

async def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    try:
        # ëª…ë ¹í–‰ ì¸ìˆ˜ íŒŒì‹±
        args = parse_arguments()
        
        print("="*80)
        print("ğŸ¯ KIS ì‹¤ì‹œê°„ í€€íŠ¸ ì „ëµ ì‹œìŠ¤í…œ")
        print("="*80)
        
        # í™˜ê²½ ì´ˆê¸°í™”
        selected_env = await initialize_environment(args.env)
        
        # ì „ëµ ì„¤ì •
        if args.auto_execute:
            kis_ws.auto_execute = True
            print(f"âš¡ ìë™ ì‹¤í–‰ ëª¨ë“œ í™œì„±í™”")
        else:
            print(f"ğŸ“‹ ìˆ˜ë™ í™•ì¸ ëª¨ë“œ í™œì„±í™”")
        
        # ëª¨ë‹ˆí„°ë§ ì‹œì‘
        print(f"\nğŸ¬ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘")
        print(f"ëŒ€ìƒ ì¢…ëª©: {', '.join(args.stocks)}")
        print(f"í™˜ê²½: {selected_env.name}")
        
        await kis_ws.start_strategy_monitoring(args.stocks)
        
        # ì‚¬ìš©ì ëª…ë ¹ ëŒ€ê¸°
        await handle_user_commands()
        
    except KeyboardInterrupt:
        print(f"\n\nâ¹ï¸  ì‚¬ìš©ìê°€ ì¤‘ë‹¨í–ˆìŠµë‹ˆë‹¤.")
    except Exception as e:
        print(f"âŒ ì‹œìŠ¤í…œ ì˜¤ë¥˜: {e}")
    finally:
        if kis_ws:
            await kis_ws.disconnect()

async def handle_user_commands():
    """ì‚¬ìš©ì ëª…ë ¹ ì²˜ë¦¬"""
    print(f"\n" + "="*60)
    print("ğŸ“‹ ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´:")
    print("  status  - ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸")
    print("  perf    - ì „ëµ ì„±ê³¼ ì¶œë ¥")
    print("  dash    - ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ")
    print("  add     - ì¢…ëª© ì¶”ê°€ ëª¨ë‹ˆí„°ë§")
    print("  switch  - í™˜ê²½ ë³€ê²½")
    print("  quit    - ì¢…ë£Œ")
    print("="*60)
    
    while True:
        try:
            print(f"\nëª…ë ¹ ì…ë ¥ (ë˜ëŠ” Ctrl+C ì¢…ë£Œ): ", end="")
            command = input().strip().lower()
            
            if command == "status":
                kis_ws.print_connection_status()
                
            elif command == "perf":
                kis_ws.print_strategy_performance()
                
            elif command == "dash":
                kis_ws.print_real_time_dashboard()
                
            elif command == "add":
                print("ì¶”ê°€í•  ì¢…ëª©ì½”ë“œ ì…ë ¥: ", end="")
                stock_code = input().strip()
                if stock_code:
                    await kis_ws.subscribe_realtime_price(stock_code)
                    print(f"âœ… {stock_code} ëª¨ë‹ˆí„°ë§ ì¶”ê°€ë¨")
                    
            elif command == "switch":
                await switch_environment()
                
            elif command in ["quit", "exit", "q"]:
                break
                
            else:
                print(f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹: {command}")
                
        except KeyboardInterrupt:
            break
        except Exception as e:
            print(f"âŒ ëª…ë ¹ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")

async def switch_environment():
    """ì‹¤í–‰ ì¤‘ í™˜ê²½ ë³€ê²½"""
    global env_selector, kis_auth, kis_ws
    
    try:
        print(f"\nğŸ”„ í™˜ê²½ ë³€ê²½ ì¤‘...")
        
        # ê¸°ì¡´ ì—°ê²° ì¢…ë£Œ
        if kis_ws:
            await kis_ws.disconnect()
        
        # ìƒˆ í™˜ê²½ ì„ íƒ
        new_env = env_selector.select_environment_interactive()
        
        # ìƒˆ ì¸ì¦ ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
        kis_auth = KISAuth(
            app_key=new_env.app_key,
            app_secret=new_env.app_secret,
            base_url=new_env.base_url,
            account_number=new_env.account_number
        )
        
        await kis_auth.get_access_token()
        
        # ìƒˆ WebSocket ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
        kis_ws = KISWebSocketStrategy(kis_auth, new_env.ws_url)
        
        print(f"âœ… {new_env.name} í™˜ê²½ìœ¼ë¡œ ë³€ê²½ ì™„ë£Œ!")
        env_selector.print_environment_info()
        
    except Exception as e:
        print(f"âŒ í™˜ê²½ ë³€ê²½ ì‹¤íŒ¨: {e}")

def print_startup_banner():
    """ì‹œì‘ ë°°ë„ˆ ì¶œë ¥"""
    print("""
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                 KIS ì‹¤ì‹œê°„ í€€íŠ¸ ì „ëµ ì‹œìŠ¤í…œ                   â•‘
    â•‘                                                              â•‘
    â•‘  ğŸ¯ ì‹¤ì‹œê°„ ëª¨ë©˜í…€/ì—­ëª¨ë©˜í…€ ì „ëµ                               â•‘
    â•‘  ğŸ“Š ê¸°ìˆ ì  ì§€í‘œ: RSI, ë³¼ë¦°ì €ë°´ë“œ, ì´ë™í‰ê·                     â•‘
    â•‘  ğŸ”„ ìë™ ì¬ì—°ê²° ë° ì•ˆì •ì„± ë³´ì¥                               â•‘
    â•‘  ğŸŒ ëª¨ì˜íˆ¬ì/ì‹¤ì „íˆ¬ì í™˜ê²½ ì„ íƒ                              â•‘
    â•‘                                                              â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)

if __name__ == "__main__":
    print_startup_banner()
    
    # ëª…ë ¹í–‰ ì‚¬ìš©ë²• ì•ˆë‚´
    if len(sys.argv) == 1:
        print("ğŸ“– ì‚¬ìš©ë²•:")
        print("  python main.py                           # ëŒ€í™”í˜• í™˜ê²½ ì„ íƒ")
        print("  python main.py --env mock                # ëª¨ì˜íˆ¬ì ìë™ ì„ íƒ")
        print("  python main.py --env real                # ì‹¤ì „íˆ¬ì ìë™ ì„ íƒ") 
        print("  python main.py --env mock --auto-execute # ëª¨ì˜íˆ¬ì + ìë™ì‹¤í–‰")
        print("  python main.py --stocks 005930 000660    # íŠ¹ì • ì¢…ëª© ëª¨ë‹ˆí„°ë§")
        print()
    
    # ë©”ì¸ ì‹¤í–‰
    asyncio.run(main())


==================================================
File: C:\Aproject\quant_backend\app\__init__.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\api\dependencies.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\api\__init__.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\api\routes\stocks.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\api\routes\websocket.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\api\routes\__init__.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\core\database.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\core\exceptions.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\core\redis_client.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\core\__init__.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\models\stock.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\models\user.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\models\__init__.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\services\chart_service.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\services\data_processor.py
==================================================
# services/data_processor.py - ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬ ë° í‹±ì°¨íŠ¸ ì„œë¹„ìŠ¤
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import asyncio
import json
from collections import deque
import logging

logger = logging.getLogger(__name__)

class TickDataProcessor:
    """ì‹¤ì‹œê°„ í‹± ë°ì´í„° ì²˜ë¦¬ê¸°"""
    
    def __init__(self, redis_client=None):
        self.redis = redis_client
        self.tick_buffers: Dict[str, deque] = {}
        self.chart_data: Dict[str, Dict] = {}
        self.max_ticks = 1000  # ìµœëŒ€ ì €ì¥ í‹± ìˆ˜
        
    async def process_tick(self, tick_data: Dict) -> Dict:
        """í‹± ë°ì´í„° ì²˜ë¦¬"""
        stock_code = tick_data['code']
        
        # í‹± ë²„í¼ ì´ˆê¸°í™”
        if stock_code not in self.tick_buffers:
            self.tick_buffers[stock_code] = deque(maxlen=self.max_ticks)
            self.chart_data[stock_code] = {
                'minute_bars': [],
                'volume_profile': {},
                'tick_stats': {}
            }
        
        # í‹± ë°ì´í„° ì¶”ê°€
        self.tick_buffers[stock_code].append(tick_data)
        
        # ë¶„ë´‰ ë°ì´í„° ì—…ë°ì´íŠ¸
        await self._update_minute_bar(stock_code, tick_data)
        
        # ë³¼ë¥¨ í”„ë¡œíŒŒì¼ ì—…ë°ì´íŠ¸
        self._update_volume_profile(stock_code, tick_data)
        
        # í‹± í†µê³„ ì—…ë°ì´íŠ¸
        self._update_tick_stats(stock_code)
        
        # Redisì— ì €ì¥
        if self.redis:
            await self._save_to_redis(stock_code, tick_data)
        
        # ì‹¤ì‹œê°„ ì¶œë ¥
        self._print_realtime_analysis(stock_code, tick_data)
        
        return tick_data
    
    async def _update_minute_bar(self, stock_code: str, tick_data: Dict):
        """1ë¶„ë´‰ ë°ì´í„° ì—…ë°ì´íŠ¸"""
        current_minute = tick_data['timestamp'].replace(second=0, microsecond=0)
        chart_data = self.chart_data[stock_code]
        
        # í˜„ì¬ ë¶„ë´‰ì´ ì—†ê±°ë‚˜ ìƒˆë¡œìš´ ë¶„ì´ë©´ ìƒì„±
        if not chart_data['minute_bars'] or chart_data['minute_bars'][-1]['timestamp'] != current_minute:
            new_bar = {
                'timestamp': current_minute,
                'open': tick_data['price'],
                'high': tick_data['price'],
                'low': tick_data['price'],
                'close': tick_data['price'],
                'volume': tick_data['volume'],
                'tick_count': 1
            }
            chart_data['minute_bars'].append(new_bar)
            
            # ìµœëŒ€ 480ê°œ (8ì‹œê°„) ë¶„ë´‰ ìœ ì§€
            if len(chart_data['minute_bars']) > 480:
                chart_data['minute_bars'] = chart_data['minute_bars'][-480:]
        else:
            # ê¸°ì¡´ ë¶„ë´‰ ì—…ë°ì´íŠ¸
            current_bar = chart_data['minute_bars'][-1]
            current_bar['high'] = max(current_bar['high'], tick_data['price'])
            current_bar['low'] = min(current_bar['low'], tick_data['price'])
            current_bar['close'] = tick_data['price']
            current_bar['volume'] += tick_data['volume']
            current_bar['tick_count'] += 1
    
    def _update_volume_profile(self, stock_code: str, tick_data: Dict):
        """ë³¼ë¥¨ í”„ë¡œíŒŒì¼ ì—…ë°ì´íŠ¸"""
        price = tick_data['price']
        volume = tick_data['volume']
        
        volume_profile = self.chart_data[stock_code]['volume_profile']
        
        # 100ì› ë‹¨ìœ„ë¡œ ê·¸ë£¹í•‘
        price_level = (price // 100) * 100
        
        if price_level not in volume_profile:
            volume_profile[price_level] = 0
        volume_profile[price_level] += volume
    
    def _update_tick_stats(self, stock_code: str):
        """í‹± í†µê³„ ì—…ë°ì´íŠ¸"""
        ticks = list(self.tick_buffers[stock_code])
        if len(ticks) < 2:
            return
        
        # ìµœê·¼ 1ë¶„ê°„ ë°ì´í„°
        now = datetime.now()
        recent_ticks = [t for t in ticks if (now - t['timestamp']).seconds <= 60]
        
        if recent_ticks:
            prices = [t['price'] for t in recent_ticks]
            volumes = [t['volume'] for t in recent_ticks]
            
            stats = {
                'tick_count_1min': len(recent_ticks),
                'avg_price_1min': np.mean(prices),
                'price_volatility_1min': np.std(prices),
                'total_volume_1min': sum(volumes),
                'avg_volume_1min': np.mean(volumes),
                'max_tick_volume': max(volumes) if volumes else 0,
                'last_update': now
            }
            
            self.chart_data[stock_code]['tick_stats'] = stats
    
    def _print_realtime_analysis(self, stock_code: str, tick_data: Dict):
        """ì‹¤ì‹œê°„ ë¶„ì„ ê²°ê³¼ ì¶œë ¥"""
        stats = self.chart_data[stock_code].get('tick_stats', {})
        timestamp = tick_data['timestamp'].strftime('%H:%M:%S')
        
        # ê¸°ë³¸ í‹± ì •ë³´
        print(f"\nâ•”â•â•â• ì‹¤ì‹œê°„ í‹± ë¶„ì„ [{stock_code}] {timestamp} â•â•â•â•—")
        print(f"â•‘ í˜„ì¬ê°€: {tick_data['price']:,}ì›                            â•‘")
        print(f"â•‘ ê±°ë˜ëŸ‰: {tick_data['volume']:,}ì£¼                             â•‘")
        print(f"â•‘ ì „ì¼ëŒ€ë¹„: {tick_data['change']:+,}ì› ({tick_data['change_rate']:+.2f}%)        â•‘")
        print(f"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
        
        # 1ë¶„ê°„ í†µê³„ (ìˆëŠ” ê²½ìš°)
        if stats:
            print(f"â•‘ [1ë¶„ê°„ í†µê³„]                                           â•‘")
            print(f"â•‘ í‹± ìˆ˜: {stats.get('tick_count_1min', 0):,}ê°œ                                    â•‘")
            print(f"â•‘ í‰ê· ê°€: {stats.get('avg_price_1min', 0):,.0f}ì›                              â•‘")
            print(f"â•‘ ë³€ë™ì„±: {stats.get('price_volatility_1min', 0):.1f}                                 â•‘")
            print(f"â•‘ ê±°ë˜ëŸ‰: {stats.get('total_volume_1min', 0):,}ì£¼                             â•‘")
            print(f"â•‘ ìµœëŒ€í‹±: {stats.get('max_tick_volume', 0):,}ì£¼                             â•‘")
        
        print(f"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        
        # ê±°ë˜ëŸ‰ ë¶„ì„
        if stats and stats.get('max_tick_volume', 0) > stats.get('avg_volume_1min', 0) * 3:
            print(f"ğŸš¨ ëŒ€ëŸ‰ ê±°ë˜ ê°ì§€! (í‰ê·  ëŒ€ë¹„ {stats['max_tick_volume'] / max(stats['avg_volume_1min'], 1):.1f}ë°°)")
    
    async def _save_to_redis(self, stock_code: str, tick_data: Dict):
        """Redisì— í‹± ë°ì´í„° ì €ì¥"""
        try:
            key = f"ticks:{stock_code}"
            tick_json = json.dumps(tick_data, default=str)
            
            # ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€ (ìµœì‹ ì´ ì•ìª½)
            await self.redis.lpush(key, tick_json)
            # ìµœëŒ€ 1000ê°œë§Œ ìœ ì§€
            await self.redis.ltrim(key, 0, 999)
            # 1ì¼ TTL ì„¤ì •
            await self.redis.expire(key, 86400)
            
        except Exception as e:
            logger.error(f"Redis ì €ì¥ ì‹¤íŒ¨: {e}")
    
    def get_tick_chart_data(self, stock_code: str, minutes: int = 60) -> List[Dict]:
        """í‹±ì°¨íŠ¸ ë°ì´í„° ë°˜í™˜"""
        if stock_code not in self.tick_buffers:
            return []
        
        # ì§€ì •ëœ ì‹œê°„ë§Œí¼ì˜ í‹± ë°ì´í„° í•„í„°ë§
        cutoff_time = datetime.now() - timedelta(minutes=minutes)
        ticks = [
            tick for tick in self.tick_buffers[stock_code] 
            if tick['timestamp'] >= cutoff_time
        ]
        
        return ticks
    
    def get_minute_chart_data(self, stock_code: str) -> List[Dict]:
        """ë¶„ë´‰ ì°¨íŠ¸ ë°ì´í„° ë°˜í™˜"""
        if stock_code not in self.chart_data:
            return []
        return self.chart_data[stock_code]['minute_bars']
    
    def get_volume_profile(self, stock_code: str) -> Dict[int, int]:
        """ë³¼ë¥¨ í”„ë¡œíŒŒì¼ ë°˜í™˜"""
        if stock_code not in self.chart_data:
            return {}
        return self.chart_data[stock_code]['volume_profile']
    
    def print_tick_summary(self, stock_code: str):
        """í‹± ë°ì´í„° ìš”ì•½ ì¶œë ¥"""
        if stock_code not in self.tick_buffers:
            print(f"âŒ {stock_code} ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤")
            return
        
        ticks = list(self.tick_buffers[stock_code])
        if not ticks:
            return
        
        # í†µê³„ ê³„ì‚°
        prices = [t['price'] for t in ticks]
        volumes = [t['volume'] for t in ticks]
        
        print(f"\n============ {stock_code} í‹± ë°ì´í„° ìš”ì•½ ============")
        print(f"ë°ì´í„° ê¸°ê°„: {ticks[0]['timestamp'].strftime('%H:%M:%S')} ~ {ticks[-1]['timestamp'].strftime('%H:%M:%S')}")
        print(f"ì´ í‹± ìˆ˜: {len(ticks):,}ê°œ")
        print(f"ê°€ê²© ë²”ìœ„: {min(prices):,}ì› ~ {max(prices):,}ì›")
        print(f"í‰ê·  ê°€ê²©: {np.mean(prices):,.0f}ì›")
        print(f"ì´ ê±°ë˜ëŸ‰: {sum(volumes):,}ì£¼")
        print(f"í‰ê·  í‹± ê±°ë˜ëŸ‰: {np.mean(volumes):,.0f}ì£¼")
        print(f"ìµœëŒ€ í‹± ê±°ë˜ëŸ‰: {max(volumes):,}ì£¼")
        print("=" * 48)

class TechnicalIndicators:
    """ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚°"""
    
    @staticmethod
    def calculate_sma(prices: List[float], period: int) -> float:
        """ë‹¨ìˆœì´ë™í‰ê· """
        if len(prices) < period:
            return 0
        return sum(prices[-period:]) / period
    
    @staticmethod
    def calculate_ema(prices: List[float], period: int) -> float:
        """ì§€ìˆ˜ì´ë™í‰ê· """
        if len(prices) < period:
            return prices[-1] if prices else 0
        
        multiplier = 2 / (period + 1)
        ema = prices[0]
        
        for price in prices[1:]:
            ema = (price * multiplier) + (ema * (1 - multiplier))
        
        return ema
    
    @staticmethod
    def calculate_rsi(prices: List[float], period: int = 14) -> float:
        """RSI ê³„ì‚°"""
        if len(prices) < period + 1:
            return 50
        
        deltas = np.diff(prices)
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)
        
        avg_gain = np.mean(gains[-period:])
        avg_loss = np.mean(losses[-period:])
        
        if avg_loss == 0:
            return 100
        
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        
        return rsi
    
    @staticmethod
    def print_indicators(stock_code: str, prices: List[float]):
        """ê¸°ìˆ ì  ì§€í‘œ ì¶œë ¥"""
        if len(prices) < 20:
            return
        
        sma5 = TechnicalIndicators.calculate_sma(prices, 5)
        sma20 = TechnicalIndicators.calculate_sma(prices, 20)
        ema12 = TechnicalIndicators.calculate_ema(prices, 12)
        ema26 = TechnicalIndicators.calculate_ema(prices, 26)
        rsi = TechnicalIndicators.calculate_rsi(prices, 14)
        
        current_price = prices[-1]
        
        print(f"\n[ê¸°ìˆ ì  ì§€í‘œ] {stock_code}")
        print(f"â”œâ”€ í˜„ì¬ê°€: {current_price:,.0f}ì›")
        print(f"â”œâ”€ SMA5: {sma5:,.0f}ì› ({'ìƒìŠ¹' if current_price > sma5 else 'í•˜ë½'})")
        print(f"â”œâ”€ SMA20: {sma20:,.0f}ì› ({'ìƒìŠ¹' if current_price > sma20 else 'í•˜ë½'})")
        print(f"â”œâ”€ EMA12: {ema12:,.0f}ì›")
        print(f"â”œâ”€ EMA26: {ema26:,.0f}ì›")
        print(f"â””â”€ RSI(14): {rsi:.1f} ({'ê³¼ë§¤ìˆ˜' if rsi > 70 else 'ê³¼ë§¤ë„' if rsi < 30 else 'ì¤‘ë¦½'})")
        
        # MACD ê³„ì‚°
        macd = ema12 - ema26
        signal = TechnicalIndicators.calculate_ema([macd], 9)
        
        if macd > signal:
            print(f"ğŸ“ˆ MACD ë§¤ìˆ˜ ì‹ í˜¸ (MACD: {macd:.1f} > Signal: {signal:.1f})")
        elif macd < signal:
            print(f"ğŸ“‰ MACD ë§¤ë„ ì‹ í˜¸ (MACD: {macd:.1f} < Signal: {signal:.1f})")

class RealTimeChartManager:
    """ì‹¤ì‹œê°„ ì°¨íŠ¸ ë§¤ë‹ˆì €"""
    
    def __init__(self, data_processor: TickDataProcessor):
        self.processor = data_processor
        self.chart_subscribers: Dict[str, List] = {}
        
    async def add_chart_subscriber(self, stock_code: str, websocket):
        """ì°¨íŠ¸ êµ¬ë…ì ì¶”ê°€"""
        if stock_code not in self.chart_subscribers:
            self.chart_subscribers[stock_code] = []
        self.chart_subscribers[stock_code].append(websocket)
        
        print(f"ğŸ“Š ì°¨íŠ¸ êµ¬ë…ì ì¶”ê°€: {stock_code}")
    
    async def remove_chart_subscriber(self, stock_code: str, websocket):
        """ì°¨íŠ¸ êµ¬ë…ì ì œê±°"""
        if stock_code in self.chart_subscribers:
            try:
                self.chart_subscribers[stock_code].remove(websocket)
                if not self.chart_subscribers[stock_code]:
                    del self.chart_subscribers[stock_code]
                print(f"ğŸ“Š ì°¨íŠ¸ êµ¬ë…ì ì œê±°: {stock_code}")
            except ValueError:
                pass
    
    async def broadcast_chart_update(self, stock_code: str, tick_data: Dict):
        """ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸"""
        if stock_code not in self.chart_subscribers:
            return
        
        # ì°¨íŠ¸ ë°ì´í„° ì¤€ë¹„
        chart_update = {
            'type': 'tick_update',
            'code': stock_code,
            'timestamp': tick_data['timestamp'].isoformat(),
            'price': tick_data['price'],
            'volume': tick_data['volume'],
            'change': tick_data['change'],
            'change_rate': tick_data['change_rate']
        }
        
        # ê¸°ìˆ ì  ì§€í‘œ ì¶”ê°€
        if len(self.processor.tick_buffers.get(stock_code, [])) >= 20:
            prices = [t['price'] for t in list(self.processor.tick_buffers[stock_code])[-20:]]
            chart_update['indicators'] = {
                'sma5': TechnicalIndicators.calculate_sma(prices, 5),
                'sma20': TechnicalIndicators.calculate_sma(prices, 20),
                'rsi': TechnicalIndicators.calculate_rsi(prices, 14)
            }
        
        # êµ¬ë…ìë“¤ì—ê²Œ ì „ì†¡
        message = json.dumps(chart_update, default=str)
        disconnected = []
        
        for websocket in self.chart_subscribers[stock_code]:
            try:
                await websocket.send_text(message)
            except:
                disconnected.append(websocket)
        
        # ëŠì–´ì§„ ì—°ê²° ì œê±°
        for ws in disconnected:
            await self.remove_chart_subscriber(stock_code, ws)
    
    def print_chart_status(self):
        """ì°¨íŠ¸ ìƒíƒœ ì¶œë ¥"""
        print(f"\n================== ì‹¤ì‹œê°„ ì°¨íŠ¸ ìƒíƒœ ==================")
        print(f"í™œì„± ì°¨íŠ¸ ìˆ˜: {len(self.chart_subscribers)}ê°œ")
        
        for stock_code, subscribers in self.chart_subscribers.items():
            tick_count = len(self.processor.tick_buffers.get(stock_code, []))
            minute_bars = len(self.processor.chart_data.get(stock_code, {}).get('minute_bars', []))
            
            print(f"\n[{stock_code}]")
            print(f"â”œâ”€ êµ¬ë…ì: {len(subscribers)}ëª…")
            print(f"â”œâ”€ í‹± ë°ì´í„°: {tick_count:,}ê°œ")
            print(f"â”œâ”€ ë¶„ë´‰ ë°ì´í„°: {minute_bars}ê°œ")
            print(f"â””â”€ ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: {datetime.now().strftime('%H:%M:%S')}")
        
        print("=" * 54)
    
    async def generate_tick_chart_json(self, stock_code: str, minutes: int = 30) -> Dict:
        """í‹±ì°¨íŠ¸ JSON ë°ì´í„° ìƒì„±"""
        tick_data = self.processor.get_tick_chart_data(stock_code, minutes)
        minute_data = self.processor.get_minute_chart_data(stock_code)
        volume_profile = self.processor.get_volume_profile(stock_code)
        
        return {
            'stock_code': stock_code,
            'timestamp': datetime.now().isoformat(),
            'tick_data': [
                {
                    'time': tick['timestamp'].isoformat(),
                    'price': tick['price'],
                    'volume': tick['volume']
                } for tick in tick_data
            ],
            'minute_bars': [
                {
                    'time': bar['timestamp'].isoformat(),
                    'open': bar['open'],
                    'high': bar['high'],
                    'low': bar['low'],
                    'close': bar['close'],
                    'volume': bar['volume']
                } for bar in minute_data
            ],
            'volume_profile': volume_profile,
            'stats': self.processor.chart_data.get(stock_code, {}).get('tick_stats', {})
        } 



==================================================
File: C:\Aproject\quant_backend\app\services\kis_api.py
==================================================
# services/kis_api.py - KIS REST API í´ë¼ì´ì–¸íŠ¸ ì™„ì„±ë³¸
import aiohttp
import asyncio
from typing import Dict, List, Optional
import logging
from datetime import datetime, timedelta
import json

logger = logging.getLogger(__name__)

class KISAPI:
    """KIS REST API í´ë¼ì´ì–¸íŠ¸ ì™„ì„±ë³¸"""
    
    def __init__(self, auth_service, base_url: str):
        self.auth = auth_service
        self.base_url = base_url
        self.session: Optional[aiohttp.ClientSession] = None
        self.call_count = 0
        self.last_call_time = datetime.now()
        self.daily_call_count = 0
        self.last_reset_date = datetime.now().date()
    
    async def __aenter__(self):
        if not self.session or self.session.closed:
            self.session = aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=30),
                headers={"User-Agent": "KIS-Quant-Backend/1.0"}
            )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session and not self.session.closed:
            await self.session.close()
    
    async def _rate_limit_check(self):
        """API í˜¸ì¶œ ì œí•œ ê´€ë¦¬"""
        now = datetime.now()
        
        # ì¼ì¼ ì¹´ìš´í„° ë¦¬ì…‹
        if now.date() > self.last_reset_date:
            self.daily_call_count = 0
            self.last_reset_date = now.date()
            print(f"\n[API ì œí•œ] ì¼ì¼ ì¹´ìš´í„° ë¦¬ì…‹ - ìƒˆë¡œìš´ ë‚ : {now.date()}")
        
        # ë¶„ë‹¹ ì œí•œ ì²´í¬
        time_since_last = (now - self.last_call_time).total_seconds()
        if time_since_last < 60:
            if self.call_count >= 18:  # ë¶„ë‹¹ 20íšŒ ì œí•œ, ì•ˆì „ ë§ˆì§„ 2íšŒ
                wait_time = 60 - time_since_last
                print(f"â³ API ë¶„ë‹¹ ì œí•œ ë„ë‹¬ - {wait_time:.1f}ì´ˆ ëŒ€ê¸° ì¤‘...")
                print(f"   í˜„ì¬: {self.call_count}/20íšŒ")
                await asyncio.sleep(wait_time)
                self.call_count = 0
        else:
            self.call_count = 0
        
        # ì¼ì¼ ì œí•œ ì²´í¬
        if self.daily_call_count >= 9500:  # ì¼ì¼ 10,000íšŒ ì œí•œ, ì•ˆì „ ë§ˆì§„ 500íšŒ
            print(f"âš ï¸  ì¼ì¼ API í˜¸ì¶œ ì œí•œ ê·¼ì ‘: {self.daily_call_count}/10,000íšŒ")
            if self.daily_call_count >= 9900:
                raise Exception("ì¼ì¼ API í˜¸ì¶œ ì œí•œ ì´ˆê³¼")
        
        self.call_count += 1
        self.daily_call_count += 1
        self.last_call_time = now
    
    async def _make_request(self, method: str, url: str, headers: Dict, params: Dict = None, data: Dict = None) -> Dict:
        """ê³µí†µ API ìš”ì²­ ë©”ì„œë“œ"""
        await self._rate_limit_check()
        
        try:
            if method.upper() == "GET":
                async with self.session.get(url, headers=headers, params=params) as response:
                    return await self._handle_response(response)
            elif method.upper() == "POST":
                async with self.session.post(url, headers=headers, json=data) as response:
                    return await self._handle_response(response)
                    
        except aiohttp.ClientError as e:
            logger.error(f"HTTP ìš”ì²­ ì‹¤íŒ¨: {e}")
            raise Exception(f"ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: {e}")
        except asyncio.TimeoutError:
            logger.error("API ìš”ì²­ íƒ€ì„ì•„ì›ƒ")
            raise Exception("API ìš”ì²­ íƒ€ì„ì•„ì›ƒ")
    
    async def _handle_response(self, response: aiohttp.ClientResponse) -> Dict:
        """ì‘ë‹µ ì²˜ë¦¬"""
        if response.status == 200:
            return await response.json()
        elif response.status == 401:
            # í† í° ë§Œë£Œ - ì¬ë°œê¸‰ ì‹œë„
            print("ğŸ”‘ í† í° ë§Œë£Œ ê°ì§€ - ìë™ ê°±ì‹  ì¤‘...")
            await self.auth._refresh_token()
            raise Exception("í† í° ë§Œë£Œ - ì¬ì‹œë„ í•„ìš”")
        elif response.status == 429:
            print("â³ API í˜¸ì¶œ ì œí•œ - 1ë¶„ ëŒ€ê¸° ì¤‘...")
            await asyncio.sleep(60)
            raise Exception("API í˜¸ì¶œ ì œí•œ - ì¬ì‹œë„ í•„ìš”")
        else:
            error_text = await response.text()
            logger.error(f"API ì˜¤ë¥˜: {response.status} - {error_text}")
            raise Exception(f"API ì˜¤ë¥˜: {response.status} - {error_text}")
    
    async def get_current_price(self, stock_code: str) -> Dict:
        """í˜„ì¬ê°€ ìƒì„¸ ì¡°íšŒ"""
        url = f"{self.base_url}/uapi/domestic-stock/v1/quotations/inquire-price"
        headers = self.auth.get_headers("FHKST01010100")
        params = {
            "fid_cond_mrkt_div_code": "J",
            "fid_input_iscd": stock_code
        }
        
        try:
            result = await self._make_request("GET", url, headers, params)
            data = result.get("output", {})
            
            # ìƒì„¸ ì •ë³´ ì¶œë ¥
            self._print_detailed_price_info(stock_code, data)
            
            return data
            
        except Exception as e:
            logger.error(f"í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨ {stock_code}: {e}")
            print(f"âŒ {stock_code} í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            raise e
    
    def _print_detailed_price_info(self, stock_code: str, data: Dict):
        """ìƒì„¸ ê°€ê²© ì •ë³´ ì¶œë ¥"""
        print(f"\nâ•”â•â•â•â•â•â•â•â•â•â• {stock_code} ìƒì„¸ ì •ë³´ â•â•â•â•â•â•â•â•â•â•â•—")
        print(f"â•‘ ì¢…ëª©ëª…: {data.get('hts_kor_isnm', 'N/A'):15s}                    â•‘")
        print(f"â•‘ í˜„ì¬ê°€: {int(data.get('stck_prpr', 0)):>10,}ì›                     â•‘")
        print(f"â•‘ ì „ì¼ëŒ€ë¹„: {int(data.get('prdy_vrss', 0)):>8,}ì› ({float(data.get('prdy_vrss_rate', 0)):>6.2f}%)    â•‘")
        print(f"â•‘                                                  â•‘")
        print(f"â•‘ ì‹œê°€: {int(data.get('stck_oprc', 0)):>12,}ì›   ê³ ê°€: {int(data.get('stck_hgpr', 0)):>10,}ì›     â•‘")
        print(f"â•‘ ì €ê°€: {int(data.get('stck_lwpr', 0)):>12,}ì›   ê±°ë˜ëŸ‰: {int(data.get('acml_vol', 0)):>8,}ì£¼    â•‘")
        print(f"â•‘                                                  â•‘")
        print(f"â•‘ ê±°ë˜ëŒ€ê¸ˆ: {int(data.get('acml_tr_pbmn', 0))//100000000:>8,}ì–µì›                           â•‘")
        print(f"â•‘ ì‹œê°€ì´ì•¡: {int(data.get('mrkt_tot_amt', 0))//100000000:>8,}ì–µì›                           â•‘")
        print(f"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        
        # ìƒí•œê°€/í•˜í•œê°€ ì²´í¬
        upper_limit = int(data.get('stck_mxpr', 0))
        lower_limit = int(data.get('stck_llmr', 0))
        current_price = int(data.get('stck_prpr', 0))
        
        if current_price >= upper_limit:
            print("ğŸ”´ ìƒí•œê°€ ë„ë‹¬!")
        elif current_price <= lower_limit:
            print("ğŸ”µ í•˜í•œê°€ ë„ë‹¬!")
        elif current_price >= upper_limit * 0.95:
            print("ğŸŸ¡ ìƒí•œê°€ ê·¼ì ‘ (95% ì´ìƒ)")
        elif current_price <= lower_limit * 1.05:
            print("ğŸŸ¡ í•˜í•œê°€ ê·¼ì ‘ (105% ì´í•˜)")
    
    async def get_daily_chart(self, stock_code: str, period: int = 30) -> List[Dict]:
        """ì¼ë´‰ ì°¨íŠ¸ ë°ì´í„° ì¡°íšŒ"""
        url = f"{self.base_url}/uapi/domestic-stock/v1/quotations/inquire-daily-price"
        headers = self.auth.get_headers("FHKST01010400")
        params = {
            "fid_cond_mrkt_div_code": "J",
            "fid_input_iscd": stock_code,
            "fid_period_div_code": "D",
            "fid_org_adj_prc": "1"
        }
        
        try:
            result = await self._make_request("GET", url, headers, params)
            data = result.get("output", [])
            
            # ì°¨íŠ¸ ë¶„ì„ ì¶œë ¥
            self._print_chart_analysis(stock_code, data[:period])
            
            return data[:period]
            
        except Exception as e:
            logger.error(f"ì¼ë´‰ ì¡°íšŒ ì‹¤íŒ¨ {stock_code}: {e}")
            raise e
    
    def _print_chart_analysis(self, stock_code: str, chart_data: List[Dict]):
        """ì°¨íŠ¸ ë¶„ì„ ê²°ê³¼ ì¶œë ¥"""
        if not chart_data:
            return
        
        print(f"\n[ì°¨íŠ¸ ë¶„ì„] {stock_code} - ìµœê·¼ {len(chart_data)}ì¼")
        print("=" * 65)
        
        # ìµœê·¼ 5ì¼ ë°ì´í„° ì¶œë ¥
        print("ë‚ ì§œ       â”‚ ì‹œê°€     â”‚ ê³ ê°€     â”‚ ì €ê°€     â”‚ ì¢…ê°€     â”‚ ê±°ë˜ëŸ‰     â”‚ ë“±ë½")
        print("-" * 65)
        
        for i, candle in enumerate(chart_data[:5]):
            date = candle.get('stck_bsop_date', '')
            open_price = int(candle.get('stck_oprc', 0))
            high_price = int(candle.get('stck_hgpr', 0))
            low_price = int(candle.get('stck_lwpr', 0))
            close_price = int(candle.get('stck_clpr', 0))
            volume = int(candle.get('acml_vol', 0))
            change_rate = float(candle.get('prdy_vrss_rate', 0))
            
            change_symbol = "â–²" if change_rate > 0 else "â–¼" if change_rate < 0 else "="
            
            print(f"{date} â”‚ {open_price:7,} â”‚ {high_price:7,} â”‚ {low_price:7,} â”‚ {close_price:7,} â”‚ {volume:9,} â”‚ {change_symbol}{abs(change_rate):.2f}%")
        
        # ê¸°ìˆ ì  ë¶„ì„
        closes = [int(candle.get('stck_clpr', 0)) for candle in chart_data]
        volumes = [int(candle.get('acml_vol', 0)) for candle in chart_data]
        
        if len(closes) >= 5:
            sma5 = sum(closes[:5]) / 5
            current_price = closes[0]
            
            print(f"\n[ê¸°ìˆ ì  ë¶„ì„]")
            print(f"â”œâ”€ 5ì¼ í‰ê· : {sma5:,.0f}ì›")
            print(f"â”œâ”€ í˜„ì¬ vs 5ì¼í‰ê· : {((current_price / sma5 - 1) * 100):+.2f}%")
            print(f"â”œâ”€ í‰ê·  ê±°ë˜ëŸ‰: {sum(volumes) / len(volumes):,.0f}ì£¼")
            print(f"â””â”€ ìµœê·¼ ê±°ë˜ëŸ‰: {volumes[0]:,}ì£¼ (í‰ê·  ëŒ€ë¹„ {(volumes[0] / (sum(volumes) / len(volumes)) * 100):.1f}%)")
        
        print("=" * 65)
    
    async def get_minute_chart(self, stock_code: str, time_frame: str = "1") -> List[Dict]:
        """ë¶„ë´‰ ë°ì´í„° ì¡°íšŒ"""
        url = f"{self.base_url}/uapi/domestic-stock/v1/quotations/inquire-time-itemchartprice"
        headers = self.auth.get_headers("FHKST01010200")
        params = {
            "fid_etc_cls_code": "",
            "fid_cond_mrkt_div_code": "J",
            "fid_input_iscd": stock_code,
            "fid_input_hour_1": time_frame,
            "fid_pw_data_incu_yn": "Y"
        }
        
        try:
            result = await self._make_request("GET", url, headers, params)
            data = result.get("output2", [])
            
            self._print_minute_chart(stock_code, data, time_frame)
            return data
            
        except Exception as e:
            logger.error(f"ë¶„ë´‰ ì¡°íšŒ ì‹¤íŒ¨ {stock_code}: {e}")
            raise e
    
    def _print_minute_chart(self, stock_code: str, data: List[Dict], time_frame: str):
        """ë¶„ë´‰ ë°ì´í„° ì¶œë ¥"""
        print(f"\n[{time_frame}ë¶„ë´‰] {stock_code} - ìµœê·¼ {min(len(data), 10)}ê°œ")
        print("ì‹œê°„     â”‚ ì‹œê°€     â”‚ ê³ ê°€     â”‚ ì €ê°€     â”‚ ì¢…ê°€     â”‚ ê±°ë˜ëŸ‰    â”‚ ë“±ë½ë¥ ")
        print("-" * 70)
        
        for candle in data[:10]:
            time = candle.get('stck_cntg_hour', '')
            open_price = int(candle.get('stck_oprc', 0))
            high_price = int(candle.get('stck_hgpr', 0))
            low_price = int(candle.get('stck_lwpr', 0))
            close_price = int(candle.get('stck_prpr', 0))
            volume = int(candle.get('cntg_vol', 0))
            change_rate = float(candle.get('prdy_vrss_rate', 0))
            
            change_symbol = "â–²" if change_rate > 0 else "â–¼" if change_rate < 0 else "="
            
            print(f"{time} â”‚ {open_price:7,} â”‚ {high_price:7,} â”‚ {low_price:7,} â”‚ {close_price:7,} â”‚ {volume:8,} â”‚ {change_symbol}{abs(change_rate):.2f}%")
    
    async def get_stock_info(self, stock_code: str) -> Dict:
        """ì¢…ëª© ê¸°ë³¸ ì •ë³´ ì¡°íšŒ"""
        url = f"{self.base_url}/uapi/domestic-stock/v1/quotations/search-stock-info"
        headers = self.auth.get_headers("CTPF1002R")
        params = {
            "PRDT_TYPE_CD": "300",
            "PDNO": stock_code
        }
        
        try:
            result = await self._make_request("GET", url, headers, params)
            return result.get("output", {})
        except Exception as e:
            logger.error(f"ì¢…ëª© ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨ {stock_code}: {e}")
            return {}
    
    async def get_top_stocks(self, market: str = "0", sort_type: str = "1") -> List[Dict]:
        """ì¸ê¸° ì¢…ëª© ì¡°íšŒ"""
        url = f"{self.base_url}/uapi/domestic-stock/v1/quotations/volume-rank"
        headers = self.auth.get_headers("FHPST01710000")
        params = {
            "fid_cond_mrkt_div_code": "J",
            "fid_cond_scr_div_code": "20171",
            "fid_input_iscd": market,
            "fid_div_cls_code": sort_type,
            "fid_blng_cls_code": "0",
            "fid_trgt_cls_code": "111111111",
            "fid_trgt_exls_cls_code": "0000000000",
            "fid_input_price_1": "",
            "fid_input_price_2": "",
            "fid_vol_cnt": ""
        }
        
        try:
            result = await self._make_request("GET", url, headers, params)
            data = result.get("output", [])
            
            self._print_top_stocks(data[:10])
            return data
            
        except Exception as e:
            logger.error(f"ì¸ê¸° ì¢…ëª© ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return []
    
    def _print_top_stocks(self, stocks: List[Dict]):
        """ì¸ê¸° ì¢…ëª© ë¦¬ìŠ¤íŠ¸ ì¶œë ¥"""
        print(f"\n================= ê±°ë˜ëŸ‰ ìƒìœ„ ì¢…ëª© =================")
        print("ìˆœìœ„ â”‚ ì¢…ëª©ì½”ë“œ â”‚ ì¢…ëª©ëª…        â”‚ í˜„ì¬ê°€     â”‚ ë“±ë½ë¥    â”‚ ê±°ë˜ëŸ‰")
        print("-" * 60)
        
        for i, stock in enumerate(stocks, 1):
            code = stock.get('mksc_shrn_iscd', '')
            name = stock.get('hts_kor_isnm', '')[:10]
            price = int(stock.get('stck_prpr', 0))
            change_rate = float(stock.get('prdy_vrss_rate', 0))
            volume = int(stock.get('acml_vol', 0))
            
            change_symbol = "â–²" if change_rate > 0 else "â–¼" if change_rate < 0 else "="
            
            print(f"{i:2d}ìœ„ â”‚ {code:6s} â”‚ {name:10s} â”‚ {price:8,}ì› â”‚ {change_symbol}{abs(change_rate):6.2f}% â”‚ {volume:8,}")
        
        print("=" * 60)
    
    def print_api_stats(self):
        """API í˜¸ì¶œ í†µê³„ ìƒì„¸ ì¶œë ¥"""
        now = datetime.now()
        
        print(f"\n==================== API í†µê³„ ====================")
        print(f"í˜„ì¬ ì‹œê°„: {now.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"ë§ˆì§€ë§‰ í˜¸ì¶œ: {self.last_call_time.strftime('%H:%M:%S')}")
        print(f"ë¶„ë‹¹ í˜¸ì¶œ: {self.call_count}/20íšŒ")
        print(f"ì¼ì¼ í˜¸ì¶œ: {self.daily_call_count:,}/10,000íšŒ")
        
        # ì œí•œ ìƒíƒœ í‘œì‹œ
        minute_usage = (self.call_count / 20) * 100
        daily_usage = (self.daily_call_count / 10000) * 100
        
        print(f"\n[ì‚¬ìš©ë¥ ]")
        print(f"â”œâ”€ ë¶„ë‹¹ ì‚¬ìš©ë¥ : {minute_usage:.1f}% {'ğŸŸ¢' if minute_usage < 70 else 'ğŸŸ¡' if minute_usage < 90 else 'ğŸ”´'}")
        print(f"â””â”€ ì¼ì¼ ì‚¬ìš©ë¥ : {daily_usage:.1f}% {'ğŸŸ¢' if daily_usage < 70 else 'ğŸŸ¡' if daily_usage < 90 else 'ğŸ”´'}")
        
        if minute_usage > 90:
            print("âš ï¸  ë¶„ë‹¹ í˜¸ì¶œ ì œí•œ ì„ë°•")
        if daily_usage > 90:
            print("âš ï¸  ì¼ì¼ í˜¸ì¶œ ì œí•œ ì„ë°•")
        
        print("=" * 48)
    
    async def batch_current_prices(self, stock_codes: List[str]) -> Dict[str, Dict]:
        """ì—¬ëŸ¬ ì¢…ëª© í˜„ì¬ê°€ ì¼ê´„ ì¡°íšŒ"""
        print(f"\n[ì¼ê´„ ì¡°íšŒ] {len(stock_codes)}ê°œ ì¢…ëª© í˜„ì¬ê°€ ì¡°íšŒ ì‹œì‘")
        
        results = {}
        failed_codes = []
        
        for i, code in enumerate(stock_codes, 1):
            try:
                print(f"ì§„í–‰ë¥ : {i}/{len(stock_codes)} ({(i/len(stock_codes)*100):.1f}%) - {code}")
                
                data = await self.get_current_price(code)
                results[code] = data
                
                # API ì œí•œ ê³ ë ¤í•˜ì—¬ ì ì‹œ ëŒ€ê¸°
                if i % 10 == 0:
                    print("â³ API ì•ˆì •ì„±ì„ ìœ„í•´ 2ì´ˆ ëŒ€ê¸°...")
                    await asyncio.sleep(2)
                    
            except Exception as e:
                print(f"âŒ {code} ì¡°íšŒ ì‹¤íŒ¨: {e}")
                failed_codes.append(code)
                continue
        
        print(f"\n[ì¼ê´„ ì¡°íšŒ ì™„ë£Œ]")
        print(f"â”œâ”€ ì„±ê³µ: {len(results)}ê°œ")
        print(f"â”œâ”€ ì‹¤íŒ¨: {len(failed_codes)}ê°œ")
        print(f"â””â”€ ì„±ê³µë¥ : {(len(results)/(len(results)+len(failed_codes))*100):.1f}%")
        
        if failed_codes:
            print(f"ì‹¤íŒ¨ ì¢…ëª©: {', '.join(failed_codes)}")
        
        return results
    
    async def search_stock(self, keyword: str) -> List[Dict]:
        """ì¢…ëª© ê²€ìƒ‰"""
        url = f"{self.base_url}/uapi/domestic-stock/v1/quotations/search-stock-info"
        headers = self.auth.get_headers("CTPF1002R")
        params = {
            "PRDT_TYPE_CD": "300",
            "PDNO": keyword
        }
        
        try:
            result = await self._make_request("GET", url, headers, params)
            data = result.get("output", [])
            
            print(f"\n[ì¢…ëª© ê²€ìƒ‰] '{keyword}' ê²€ìƒ‰ ê²°ê³¼: {len(data)}ê°œ")
            print("ì¢…ëª©ì½”ë“œ â”‚ ì¢…ëª©ëª…              â”‚ í˜„ì¬ê°€     â”‚ ë“±ë½ë¥ ")
            print("-" * 50)
            
            for stock in data[:10]:
                code = stock.get('pdno', '')
                name = stock.get('prdt_name', '')[:15]
                price = int(stock.get('stck_prpr', 0))
                change_rate = float(stock.get('prdy_vrss_rate', 0))
                
                change_symbol = "â–²" if change_rate > 0 else "â–¼" if change_rate < 0 else "="
                print(f"{code:6s} â”‚ {name:15s} â”‚ {price:8,}ì› â”‚ {change_symbol}{abs(change_rate):6.2f}%")
            
            return data
            
        except Exception as e:
            logger.error(f"ì¢…ëª© ê²€ìƒ‰ ì‹¤íŒ¨: {e}")
            return []


==================================================
File: C:\Aproject\quant_backend\app\services\kis_auth.py
==================================================
# services/kis_auth.py - KIS ì¸ì¦ ì„œë¹„ìŠ¤
import aiohttp
import asyncio
import json
from datetime import datetime, timedelta
from typing import Optional
import logging

logger = logging.getLogger(__name__)

class KISAuth:
    """KIS API ì¸ì¦ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, app_key: str, app_secret: str, base_url: str):
        self.app_key = app_key
        self.app_secret = app_secret
        self.base_url = base_url
        self.access_token: Optional[str] = None
        self.token_expiry: Optional[datetime] = None
        self._lock = asyncio.Lock()
    
    async def get_access_token(self) -> str:
        """ì•¡ì„¸ìŠ¤ í† í° ë°˜í™˜ (í•„ìš”ì‹œ ê°±ì‹ )"""
        async with self._lock:
            if self._is_token_valid():
                return self.access_token
            
            await self._refresh_token()
            return self.access_token
    
    def _is_token_valid(self) -> bool:
        """í† í° ìœ íš¨ì„± ê²€ì‚¬"""
        if not self.access_token or not self.token_expiry:
            return False
        
        # 5ë¶„ ì—¬ìœ ë¥¼ ë‘ê³  ê°±ì‹ 
        return self.token_expiry > datetime.now() + timedelta(minutes=5)
    
    async def _refresh_token(self):
        """í† í° ê°±ì‹ """
        url = f"{self.base_url}/oauth2/tokenP"
        data = {
            "grant_type": "client_credentials",
            "appkey": self.app_key,
            "appsecret": self.app_secret
        }
        
        try:
            logger.info("ğŸ”‘ KIS API í† í° ê°±ì‹  ì¤‘...")
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=data) as response:
                    if response.status == 200:
                        result = await response.json()
                        self.access_token = result["access_token"]
                        expires_in = result.get("expires_in", 86400)
                        self.token_expiry = datetime.now() + timedelta(seconds=expires_in)
                        
                        logger.info(f"âœ… í† í° ê°±ì‹  ì™„ë£Œ (ë§Œë£Œ: {self.token_expiry.strftime('%Y-%m-%d %H:%M:%S')})")
                        print(f"\n[í† í° ìƒíƒœ] ìƒˆ ì•¡ì„¸ìŠ¤ í† í° ë°œê¸‰ ì™„ë£Œ")
                        print(f"â”œâ”€ ë°œê¸‰ì‹œê°„: {datetime.now().strftime('%H:%M:%S')}")
                        print(f"â”œâ”€ ë§Œë£Œì‹œê°„: {self.token_expiry.strftime('%H:%M:%S')}")
                        print(f"â””â”€ ìœ íš¨ê¸°ê°„: {expires_in//3600}ì‹œê°„ {(expires_in%3600)//60}ë¶„")
                    else:
                        error_text = await response.text()
                        raise Exception(f"í† í° ë°œê¸‰ ì‹¤íŒ¨: {response.status} - {error_text}")
                        
        except Exception as error:
            logger.error(f"âŒ í† í° ê°±ì‹  ì‹¤íŒ¨: {error}")
            print(f"\n[ì˜¤ë¥˜] í† í° ê°±ì‹  ì‹¤íŒ¨: {error}")
            raise error
    
    def get_headers(self, tr_id: str) -> dict:
        """API í˜¸ì¶œìš© í—¤ë” ìƒì„±"""
        return {
            "authorization": f"Bearer {self.access_token}",
            "appkey": self.app_key,
            "appsecret": self.app_secret,
            "tr_id": tr_id,
            "custtype": "P"
        }
    
    def print_status(self):
        """í˜„ì¬ ì¸ì¦ ìƒíƒœ ì¶œë ¥"""
        print("\n==================== KIS ì¸ì¦ ìƒíƒœ ====================")
        print(f"APP KEY: {self.app_key[:10]}...")
        if self.access_token:
            print(f"ì•¡ì„¸ìŠ¤ í† í°: {self.access_token[:20]}...")
            print(f"í† í° ë§Œë£Œ: {self.token_expiry.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"í† í° ìƒíƒœ: {'âœ… ìœ íš¨' if self._is_token_valid() else 'âŒ ë§Œë£Œ'}")
        else:
            print("ì•¡ì„¸ìŠ¤ í† í°: ì—†ìŒ")
        print("=" * 54)



==================================================
File: C:\Aproject\quant_backend\app\services\kis_websocket.py
==================================================
# services/kis_websocket.py - KIS WebSocket ì‹¤ì‹œê°„ ë°ì´í„° í´ë¼ì´ì–¸íŠ¸

import websockets
import json
import asyncio
from typing import Dict, List, Callable, Optional
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class KISWebSocket:
    """KIS WebSocket ì‹¤ì‹œê°„ ë°ì´í„° í´ë¼ì´ì–¸íŠ¸"""
    
    def __init__(self, auth_service, ws_url: str):
        self.auth = auth_service
        self.ws_url = ws_url
        self.websocket: Optional[websockets.WebSocketServerProtocol] = None
        self.is_connected = False
        self.subscribers: Dict[str, List[Callable]] = {}
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 5
        
    async def connect(self):
        """WebSocket ì—°ê²°"""
        try:
            logger.info("ğŸ”Œ KIS WebSocket ì—°ê²° ì‹œë„...")
            print(f"\n[WebSocket] ì—°ê²° ì‹œë„ ì¤‘...")
            print(f"â”œâ”€ URL: {self.ws_url}")
            print(f"â””â”€ ì‹œê°„: {datetime.now().strftime('%H:%M:%S')}")
            
            self.websocket = await websockets.connect(
                self.ws_url,
                ping_interval=30,
                ping_timeout=10
            )
            
            self.is_connected = True
            self.reconnect_attempts = 0
            
            logger.info("âœ… KIS WebSocket ì—°ê²° ì™„ë£Œ")
            print(f"âœ… WebSocket ì—°ê²° ì„±ê³µ!")
            
            # ìŠ¹ì¸í‚¤ ì „ì†¡
            await self._send_approval()
            
            # ë©”ì‹œì§€ ìˆ˜ì‹  íƒœìŠ¤í¬ ì‹œì‘
            asyncio.create_task(self._listen_messages())
            
        except Exception as e:
            logger.error(f"âŒ WebSocket ì—°ê²° ì‹¤íŒ¨: {e}")
            print(f"âŒ WebSocket ì—°ê²° ì‹¤íŒ¨: {e}")
            await self._handle_reconnect()
    
    async def _send_approval(self):
        """ìŠ¹ì¸í‚¤ ì „ì†¡"""
        try:
            token = await self.auth.get_access_token()
            approval_data = {
                "header": {
                    "approval_key": token,
                    "custtype": "P",
                    "tr_type": "1",
                    "content_type": "utf-8"
                },
                "body": {
                    "input": {
                        "tr_id": "PINGPONG",
                        "tr_key": ""
                    }
                }
            }
            
            await self.websocket.send(json.dumps(approval_data))
            logger.info("ğŸ” ìŠ¹ì¸í‚¤ ì „ì†¡ ì™„ë£Œ")
            print("ğŸ” WebSocket ìŠ¹ì¸í‚¤ ì „ì†¡ ì™„ë£Œ")
            
        except Exception as e:
            logger.error(f"ìŠ¹ì¸í‚¤ ì „ì†¡ ì‹¤íŒ¨: {e}")
            print(f"âŒ ìŠ¹ì¸í‚¤ ì „ì†¡ ì‹¤íŒ¨: {e}")
    
    async def subscribe_realtime_price(self, stock_code: str, callback: Callable = None):
        """ì‹¤ì‹œê°„ ì‹œì„¸ êµ¬ë…"""
        if not self.is_connected:
            await self.connect()
        
        try:
            subscribe_data = {
                "header": {
                    "approval_key": await self.auth.get_access_token(),
                    "custtype": "P",
                    "tr_type": "1",
                    "content_type": "utf-8"
                },
                "body": {
                    "input": {
                        "tr_id": "H0STCNT0",  # ì‹¤ì‹œê°„ ì‹œì„¸
                        "tr_key": stock_code
                    }
                }
            }
            
            await self.websocket.send(json.dumps(subscribe_data))
            
            # ì½œë°± ë“±ë¡
            if callback:
                if stock_code not in self.subscribers:
                    self.subscribers[stock_code] = []
                self.subscribers[stock_code].append(callback)
            
            logger.info(f"ğŸ“¡ ì‹¤ì‹œê°„ ì‹œì„¸ êµ¬ë…: {stock_code}")
            print(f"\n[êµ¬ë… ì‹œì‘] {stock_code} ì‹¤ì‹œê°„ ì‹œì„¸")
            print(f"â”œâ”€ êµ¬ë… ì‹œê°„: {datetime.now().strftime('%H:%M:%S')}")
            print(f"â””â”€ ìƒíƒœ: í™œì„±")
            
        except Exception as e:
            logger.error(f"ì‹¤ì‹œê°„ êµ¬ë… ì‹¤íŒ¨: {e}")
            print(f"âŒ {stock_code} êµ¬ë… ì‹¤íŒ¨: {e}")
    
    async def subscribe_realtime_orderbook(self, stock_code: str, callback: Callable = None):
        """ì‹¤ì‹œê°„ í˜¸ê°€ êµ¬ë…"""
        if not self.is_connected:
            await self.connect()
        
        try:
            subscribe_data = {
                "header": {
                    "approval_key": await self.auth.get_access_token(),
                    "custtype": "P",
                    "tr_type": "1",
                    "content_type": "utf-8"
                },
                "body": {
                    "input": {
                        "tr_id": "H0STASP0",  # ì‹¤ì‹œê°„ í˜¸ê°€
                        "tr_key": stock_code
                    }
                }
            }
            
            await self.websocket.send(json.dumps(subscribe_data))
            
            if callback:
                callback_key = f"{stock_code}_orderbook"
                if callback_key not in self.subscribers:
                    self.subscribers[callback_key] = []
                self.subscribers[callback_key].append(callback)
            
            print(f"[í˜¸ê°€ êµ¬ë…] {stock_code} ì‹¤ì‹œê°„ í˜¸ê°€ êµ¬ë… ì‹œì‘")
            
        except Exception as e:
            logger.error(f"í˜¸ê°€ êµ¬ë… ì‹¤íŒ¨: {e}")
            print(f"âŒ {stock_code} í˜¸ê°€ êµ¬ë… ì‹¤íŒ¨: {e}")
    
    async def _listen_messages(self):
        """ì‹¤ì‹œê°„ ë©”ì‹œì§€ ìˆ˜ì‹ """
        try:
            async for message in self.websocket:
                await self._process_message(message)
        except websockets.exceptions.ConnectionClosed:
            logger.warning("WebSocket ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤")
            print("âš ï¸  WebSocket ì—°ê²° ëŠì–´ì§ - ì¬ì—°ê²° ì‹œë„ ì¤‘...")
            self.is_connected = False
            await self._handle_reconnect()
        except Exception as e:
            logger.error(f"ë©”ì‹œì§€ ìˆ˜ì‹  ì˜¤ë¥˜: {e}")
            print(f"âŒ ë©”ì‹œì§€ ìˆ˜ì‹  ì˜¤ë¥˜: {e}")
    
    async def _process_message(self, message):
        """ë°›ì€ ë©”ì‹œì§€ ì²˜ë¦¬"""
        try:
            data = json.loads(message)
            header = data.get("header", {})
            body = data.get("body", {})
            
            tr_id = header.get("tr_id")
            tr_key = header.get("tr_key")
            
            if tr_id == "H0STCNT0":  # ì‹¤ì‹œê°„ ì‹œì„¸
                await self._handle_realtime_price(tr_key, body)
            elif tr_id == "H0STASP0":  # ì‹¤ì‹œê°„ í˜¸ê°€
                await self._handle_realtime_orderbook(tr_key, body)
            
        except Exception as e:
            logger.error(f"ë©”ì‹œì§€ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    async def _handle_realtime_price(self, stock_code: str, data: Dict):
        """ì‹¤ì‹œê°„ ì‹œì„¸ ë°ì´í„° ì²˜ë¦¬"""
        try:
            price_data = {
                'timestamp': datetime.now(),
                'code': stock_code,
                'price': int(data.get('stck_prpr', 0)),
                'volume': int(data.get('cntg_vol', 0)),
                'total_volume': int(data.get('acml_vol', 0)),
                'change': int(data.get('prdy_vrss', 0)),
                'change_rate': float(data.get('prdy_vrss_rate', 0))
            }
            
            # ì‹¤ì‹œê°„ í‹± ì¶œë ¥
            self._print_tick_data(price_data)
            
            # êµ¬ë…ìë“¤ì—ê²Œ ì½œë°± ì‹¤í–‰
            if stock_code in self.subscribers:
                for callback in self.subscribers[stock_code]:
                    await callback(price_data)
                    
        except Exception as e:
            logger.error(f"ì‹¤ì‹œê°„ ì‹œì„¸ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    async def _handle_realtime_orderbook(self, stock_code: str, data: Dict):
        """ì‹¤ì‹œê°„ í˜¸ê°€ ë°ì´í„° ì²˜ë¦¬"""
        try:
            # í˜¸ê°€ ë°ì´í„° íŒŒì‹±
            orderbook = {
                'timestamp': datetime.now(),
                'code': stock_code,
                'ask_prices': [int(data.get(f'askp{i}', 0)) for i in range(1, 11)],
                'ask_volumes': [int(data.get(f'askp_rsqn{i}', 0)) for i in range(1, 11)],
                'bid_prices': [int(data.get(f'bidp{i}', 0)) for i in range(1, 11)],
                'bid_volumes': [int(data.get(f'bidp_rsqn{i}', 0)) for i in range(1, 11)]
            }
            
            # í˜¸ê°€ì°½ ì¶œë ¥
            self._print_orderbook(orderbook)
            
            # ì½œë°± ì‹¤í–‰
            callback_key = f"{stock_code}_orderbook"
            if callback_key in self.subscribers:
                for callback in self.subscribers[callback_key]:
                    await callback(orderbook)
                    
        except Exception as e:
            logger.error(f"í˜¸ê°€ ë°ì´í„° ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    def _print_tick_data(self, data: Dict):
        """í‹± ë°ì´í„° ì‹¤ì‹œê°„ ì¶œë ¥"""
        timestamp = data['timestamp'].strftime('%H:%M:%S')
        price = data['price']
        volume = data['volume']
        change = data['change']
        change_rate = data['change_rate']
        
        # ë“±ë½ í‘œì‹œ
        if change > 0:
            change_symbol = "â–²"
            color = "ìƒìŠ¹"
        elif change < 0:
            change_symbol = "â–¼" 
            color = "í•˜ë½"
        else:
            change_symbol = "="
            color = "ë³´í•©"
        
        print(f"\n[ì‹¤ì‹œê°„ í‹±] {data['code']} | {timestamp}")
        print(f"â”œâ”€ í˜„ì¬ê°€: {price:,}ì› ({change_symbol} {abs(change)}, {change_rate:+.2f}%) [{color}]")
        print(f"â”œâ”€ ê±°ë˜ëŸ‰: {volume:,}ì£¼")
        print(f"â””â”€ ëˆ„ì ê±°ë˜ëŸ‰: {data['total_volume']:,}ì£¼")
    
    def _print_orderbook(self, data: Dict):
        """í˜¸ê°€ì°½ ì‹¤ì‹œê°„ ì¶œë ¥"""
        timestamp = data['timestamp'].strftime('%H:%M:%S')
        
        print(f"\n[ì‹¤ì‹œê°„ í˜¸ê°€] {data['code']} | {timestamp}")
        print("ë§¤ë„ í˜¸ê°€                    â”‚ ë§¤ìˆ˜ í˜¸ê°€")
        print("-" * 30 + "â”¼" + "-" * 30)
        
        for i in range(5):  # ìƒìœ„ 5í˜¸ê°€ë§Œ ì¶œë ¥
            ask_price = data['ask_prices'][i]
            ask_volume = data['ask_volumes'][i]
            bid_price = data['bid_prices'][i]
            bid_volume = data['bid_volumes'][i]
            
            print(f"{ask_price:>7,} ({ask_volume:>4,})    â”‚    {bid_price:>7,} ({bid_volume:>4,})")
    
    async def _handle_reconnect(self):
        """ì¬ì—°ê²° ì²˜ë¦¬"""
        if self.reconnect_attempts >= self.max_reconnect_attempts:
            logger.error("ìµœëŒ€ ì¬ì—°ê²° ì‹œë„ íšŸìˆ˜ ì´ˆê³¼")
            print("âŒ ìµœëŒ€ ì¬ì—°ê²° ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ - ì—°ê²° í¬ê¸°")
            return
        
        self.reconnect_attempts += 1
        wait_time = min(2 ** self.reconnect_attempts, 30)  # ì§€ìˆ˜ ë°±ì˜¤í”„
        
        print(f"ğŸ”„ ì¬ì—°ê²° ì‹œë„ {self.reconnect_attempts}/{self.max_reconnect_attempts} - {wait_time}ì´ˆ í›„...")
        await asyncio.sleep(wait_time)
        
        try:
            await self.connect()
            # ê¸°ì¡´ êµ¬ë… ë³µêµ¬
            await self._restore_subscriptions()
        except Exception as e:
            logger.error(f"ì¬ì—°ê²° ì‹¤íŒ¨: {e}")
            await self._handle_reconnect()
    
    async def _restore_subscriptions(self):
        """ê¸°ì¡´ êµ¬ë… ë³µêµ¬"""
        print("\n[êµ¬ë… ë³µêµ¬] ê¸°ì¡´ êµ¬ë… ì¢…ëª© ë³µêµ¬ ì¤‘...")
        
        restored_count = 0
        for key in list(self.subscribers.keys()):
            if "_orderbook" not in key:  # ì‹œì„¸ êµ¬ë…ë§Œ ë³µêµ¬
                try:
                    await self.subscribe_realtime_price(key)
                    restored_count += 1
                except Exception as e:
                    logger.error(f"êµ¬ë… ë³µêµ¬ ì‹¤íŒ¨ {key}: {e}")
        
        print(f"âœ… {restored_count}ê°œ ì¢…ëª© êµ¬ë… ë³µêµ¬ ì™„ë£Œ")
    
    def add_subscriber(self, stock_code: str, callback: Callable):
        """êµ¬ë…ì ì¶”ê°€"""
        if stock_code not in self.subscribers:
            self.subscribers[stock_code] = []
        self.subscribers[stock_code].append(callback)
    
    def remove_subscriber(self, stock_code: str, callback: Callable):
        """êµ¬ë…ì ì œê±°"""
        if stock_code in self.subscribers:
            try:
                self.subscribers[stock_code].remove(callback)
                if not self.subscribers[stock_code]:
                    del self.subscribers[stock_code]
            except ValueError:
                pass
    
    def print_connection_status(self):
        """ì—°ê²° ìƒíƒœ ì¶œë ¥"""
        print(f"\n==================== WebSocket ìƒíƒœ ====================")
        print(f"ì—°ê²° ìƒíƒœ: {'âœ… ì—°ê²°ë¨' if self.is_connected else 'âŒ ëŠì–´ì§'}")
        print(f"êµ¬ë… ì¢…ëª© ìˆ˜: {len([k for k in self.subscribers.keys() if '_orderbook' not in k])}ê°œ")
        print(f"ì¬ì—°ê²° ì‹œë„: {self.reconnect_attempts}/{self.max_reconnect_attempts}")
        
        if self.subscribers:
            print(f"\n[êµ¬ë… ì¤‘ì¸ ì¢…ëª©]")
            for i, stock_code in enumerate([k for k in self.subscribers.keys() if '_orderbook' not in k], 1):
                print(f"{i:2d}. {stock_code}")
        
        print("=" * 54)
    
    async def disconnect(self):
        """ì—°ê²° ì¢…ë£Œ"""
        if self.websocket and not self.websocket.closed:
            await self.websocket.close()
        self.is_connected = False
        print("ğŸ”Œ WebSocket ì—°ê²° ì¢…ë£Œ") 



==================================================
File: C:\Aproject\quant_backend\app\services\__init__.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\utils\indicators.py
==================================================
 



==================================================
File: C:\Aproject\quant_backend\app\utils\__init__.py
==================================================
 


