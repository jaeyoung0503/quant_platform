
==================================================
File: C:\Aproject\test\quant_actual\combine.py
==================================================
import os

# 설정
input_dirs = [
    r"C:\Aproject\test\quant_actual",
    # r"C:\Aproject\quant-platform\quant-trading-platform\backend",
    # r"C:\Aproject\quant-platform\src",
    # r"C:\Aproject\quant-platform\backtester"
]  # 입력 디렉토리 목록
output_file = r"C:\Aproject\test\combined_output.txt"  # 출력 파일
file_extensions = [".py", ".ts", ".tsx", ".js", ".json"]  # 포함할 파일 확장자

def combine_files():
    # 출력 파일 초기화
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # 각 입력 디렉토리 순회
        for dir_path in input_dirs:  # input_dir → input_dirs로 수정
            # 디렉토리 존재 여부 확인
            if not os.path.exists(dir_path):
                outfile.write(f"\n{'='*50}\n")
                outfile.write(f"Directory not found: {dir_path}\n")
                outfile.write(f"{'='*50}\n")
                continue

            # 디렉토리 내 파일 순회
            for root, dirs, files in os.walk(dir_path):  # input_dir → dir_path
                # node_modules 디렉토리 제외
                if 'node_modules' in dirs:
                    dirs.remove('node_modules')  # node_modules 제외
                for file in files:
                    if any(file.endswith(ext) for ext in file_extensions):  # 지정된 확장자 확인
                        file_path = os.path.join(root, file)
                        try:
                            # 파일 내용 읽기
                            with open(file_path, 'r', encoding='utf-8') as infile:
                                content = infile.read()
                            # 출력 파일에 파일 경로와 내용 기록
                            outfile.write(f"\n{'='*50}\n")
                            outfile.write(f"File: {file_path}\n")
                            outfile.write(f"{'='*50}\n")
                            outfile.write(content)
                            outfile.write("\n\n")  # 파일 간 구분을 위한 빈 줄
                        except UnicodeDecodeError:
                            # 인코딩 오류 시 cp949 시도
                            try:
                                with open(file_path, 'r', encoding='cp949') as infile:
                                    content = infile.read()
                                outfile.write(f"\n{'='*50}\n")
                                outfile.write(f"File: {file_path} (encoded in cp949)\n")
                                outfile.write(f"{'='*50}\n")
                                outfile.write(content)
                                outfile.write("\n\n")
                            except Exception as e:
                                outfile.write(f"\n{'='*50}\n")
                                outfile.write(f"Error reading {file_path}: {str(e)}\n")
                                outfile.write(f"{'='*50}\n")
                        except Exception as e:
                            outfile.write(f"\n{'='*50}\n")
                            outfile.write(f"Error reading {file_path}: {str(e)}\n")
                            outfile.write(f"{'='*50}\n")

if __name__ == "__main__":
    combine_files()
    print(f"모든 파일이 {output_file}로 합쳐졌습니다.")


==================================================
File: C:\Aproject\test\quant_actual\config_real.py
==================================================
"""
file: config_real.py

실거래용 설정 파일
주의: 실제 계좌 정보와 비밀번호가 필요합니다
"""

import os
from typing import Dict, Any

# 환경변수에서 실제 계좌 정보 로드
KIWOOM_ACCOUNT = os.getenv("KIWOOM_ACCOUNT", "")  # 실제 계좌번호
KIWOOM_PASSWORD = os.getenv("KIWOOM_PASSWORD", "")  # 실제 비밀번호
KIWOOM_CERT_PASSWORD = os.getenv("KIWOOM_CERT_PASSWORD", "")  # 공인인증서 비밀번호

# 실거래 모드 설정
TRADING_CONFIG = {
    "mode": "REAL",  # DEMO → REAL 변경
    "server_type": "REAL",
    "auto_login": True,
    "save_password": False,  # 보안상 비추천
    
    # 실거래 안전장치
    "daily_loss_limit": -50000,    # 일일 최대 손실 (5만원)
    "max_position_size": 100000,   # 최대 포지션 크기 (10만원)
    "max_positions": 3,            # 최대 보유 종목 (3개)
    "emergency_stop_loss": -100000,  # 긴급중단 손실액 (10만원)
    
    # 거래 시간 제한
    "trading_start_time": "09:30",  # 거래 시작
    "trading_end_time": "15:00",    # 거래 종료
    "lunch_break_start": "12:00",   # 점심시간 시작
    "lunch_break_end": "13:00",     # 점심시간 종료
}

# 실거래용 전략 설정 (보수적)
REAL_STRATEGY_CONFIG = {
    "bollinger_bands": {
        "enabled": True,
        "investment_amount": 50000,  # 5만원만 투자
        "target_stocks": ["005930"],  # 삼성전자만
        "parameters": {
            "period": 20,
            "std_multiplier": 2.5,  # 더 보수적
            "stop_loss": 0.02,      # 2% 손절
            "take_profit": 0.03,    # 3% 익절
        }
    },
    "rsi_reversal": {
        "enabled": False,  # 처음에는 1개 전략만
        "investment_amount": 30000,
        "target_stocks": ["035720"],
        "parameters": {
            "period": 14,
            "oversold": 25,  # 더 보수적
            "overbought": 75,
            "stop_loss": 0.03
        }
    }
}

# 리스크 알림 설정
RISK_ALERTS = {
    "email_enabled": True,
    "email_recipients": ["your-email@gmail.com"],
    "slack_enabled": False,
    
    "alert_conditions": {
        "daily_loss": -10000,      # 일일 손실 1만원 시 알림
        "position_loss": -5000,    # 포지션 손실 5천원 시 알림
        "system_error": True,      # 시스템 오류 시 알림
        "connection_lost": True    # 연결 끊김 시 알림
    }
}

# 백업 및 로깅 설정
BACKUP_CONFIG = {
    "auto_backup": True,
    "backup_interval": 3600,  # 1시간마다 백업
    "max_backups": 24,        # 24시간분 보관
    "backup_location": "backups/real_trading/",
    
    "detailed_logging": True,
    "log_all_api_calls": True,
    "log_sensitive_data": False  # 비밀번호 등 로그에 기록 안함
}

def validate_real_trading_config():
    """실거래 설정 검증"""
    errors = []
    warnings = []
    
    # 필수 정보 체크
    if not KIWOOM_ACCOUNT:
        errors.append("KIWOOM_ACCOUNT 환경변수가 설정되지 않음")
    
    if not KIWOOM_PASSWORD:
        errors.append("KIWOOM_PASSWORD 환경변수가 설정되지 않음")
    
    # 안전장치 체크
    total_investment = sum(
        config.get("investment_amount", 0) 
        for config in REAL_STRATEGY_CONFIG.values() 
        if config.get("enabled", False)
    )
    
    if total_investment > 100000:  # 10만원 초과
        warnings.append(f"총 투자금액이 {total_investment:,}원으로 권장액(10만원)을 초과")
    
    # 손절 설정 체크
    for strategy_name, config in REAL_STRATEGY_CONFIG.items():
        if config.get("enabled") and not config.get("parameters", {}).get("stop_loss"):
            warnings.append(f"{strategy_name} 전략에 손절 설정이 없음")
    
    return {
        "valid": len(errors) == 0,
        "errors": errors,
        "warnings": warnings
    }

def get_real_trading_disclaimer():
    """실거래 면책 고지"""
    return """
    ⚠️  실거래 모드 경고 ⚠️
    
    1. 이 소프트웨어는 실제 돈으로 거래합니다
    2. 투자 손실 위험이 있습니다
    3. 시스템 오류로 인한 손실 가능성이 있습니다
    4. 반드시 소액으로 시작하시기 바랍니다
    5. 충분한 테스트 후 사용하시기 바랍니다
    
    계속하시겠습니까? (yes/no): 
    """

# 실거래 체크리스트
REAL_TRADING_CHECKLIST = [
    "✅ 키움증권 계좌 개설 완료",
    "✅ 키움 Open API+ 설치 완료", 
    "✅ 모의투자로 충분한 테스트 완료",
    "✅ 손절/익절 설정 확인",
    "✅ 일일 손실 한도 설정 확인",
    "✅ 긴급연락처 설정 완료",
    "✅ 백업 시스템 동작 확인",
    "✅ 인터넷 연결 안정성 확인",
    "✅ 투자 가능 금액 확인",
    "✅ 가족/지인에게 자동매매 사실 고지"
]

def print_real_trading_checklist():
    """실거래 체크리스트 출력"""
    print("\n" + "="*50)
    print("🚨 실거래 전 필수 체크리스트")
    print("="*50)
    
    for item in REAL_TRADING_CHECKLIST:
        print(item)
    
    print("="*50)
    print("모든 항목을 확인하신 후 실거래를 시작하세요!")
    print("="*50)

# 실거래 시작 함수
def start_real_trading():
    """실거래 모드 시작"""
    
    # 1. 면책 고지
    disclaimer = get_real_trading_disclaimer()
    response = input(disclaimer).lower().strip()
    
    if response not in ['yes', 'y', '네', 'ㅇ']:
        print("실거래 시작이 취소되었습니다.")
        return False
    
    # 2. 설정 검증
    validation = validate_real_trading_config()
    
    if not validation["valid"]:
        print("❌ 설정 오류:")
        for error in validation["errors"]:
            print(f"  - {error}")
        return False
    
    if validation["warnings"]:
        print("⚠️  경고사항:")
        for warning in validation["warnings"]:
            print(f"  - {warning}")
        
        proceed = input("경고사항을 무시하고 계속하시겠습니까? (yes/no): ").lower().strip()
        if proceed not in ['yes', 'y', '네', 'ㅇ']:
            print("실거래 시작이 취소되었습니다.")
            return False
    
    # 3. 체크리스트 확인
    print_real_trading_checklist()
    checklist_ok = input("\n모든 체크리스트를 확인하셨나요? (yes/no): ").lower().strip()
    
    if checklist_ok not in ['yes', 'y', '네', 'ㅇ']:
        print("체크리스트를 먼저 확인해주세요.")
        return False
    
    # 4. 최종 확인
    print("\n" + "🔥" * 20)
    print("최종 확인: 실제 돈으로 자동매매를 시작합니다!")
    print("🔥" * 20)
    
    final_confirm = input("정말로 시작하시겠습니까? 'START REAL TRADING' 을 입력하세요: ")
    
    if final_confirm != "START REAL TRADING":
        print("실거래 시작이 취소되었습니다.")
        return False
    
    print("\n✅ 실거래 모드로 시스템을 시작합니다...")
    return True

# 환경변수 설정 예시 파일 생성
def create_env_example():
    """실거래용 .env.example 파일 생성"""
    env_content = """
# 키움증권 계좌 정보 (실제 정보로 변경 필요)
KIWOOM_ACCOUNT=8012345-01
KIWOOM_PASSWORD=your_password
KIWOOM_CERT_PASSWORD=your_cert_password

# 실거래 모드 설정
TRADING_MODE=REAL
SERVER_TYPE=REAL

# 보안 설정
SECRET_KEY=your-very-secure-secret-key-here

# 알림 설정
EMAIL_SMTP_SERVER=smtp.gmail.com
EMAIL_SMTP_PORT=587
EMAIL_USERNAME=your-email@gmail.com
EMAIL_PASSWORD=your-email-password
EMAIL_RECIPIENTS=your-email@gmail.com,backup-email@gmail.com

# 슬랙 알림 (선택사항)
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/...
SLACK_CHANNEL=#trading-alerts

# 데이터베이스 (실거래용 별도 DB)
DATABASE_URL=sqlite:///./data/quantrade_real.db

# 로깅 설정
LOG_LEVEL=INFO
LOG_FILE=logs/real_trading.log
"""
    
    with open(".env.real.example", "w", encoding="utf-8") as f:
        f.write(env_content)
    
    print("✅ .env.real.example 파일이 생성되었습니다.")
    print("이 파일을 .env.real로 복사하고 실제 정보로 수정하세요.")

if __name__ == "__main__":
    # 실거래 설정 파일 실행 시
    print("🔧 실거래 설정 도구")
    print("-" * 30)
    
    choice = input("""
선택하세요:
1. 실거래 시작
2. 설정 검증만
3. 체크리스트 출력
4. .env 예시 파일 생성
5. 종료

선택 (1-5): """).strip()
    
    if choice == "1":
        if start_real_trading():
            print("실거래 모드가 승인되었습니다.")
        else:
            print("실거래 시작이 취소되었습니다.")
    
    elif choice == "2":
        validation = validate_real_trading_config()
        if validation["valid"]:
            print("✅ 설정이 올바릅니다.")
        else:
            print("❌ 설정 오류가 있습니다:")
            for error in validation["errors"]:
                print(f"  - {error}")
        
        if validation["warnings"]:
            print("⚠️  경고사항:")
            for warning in validation["warnings"]:
                print(f"  - {warning}")
    
    elif choice == "3":
        print_real_trading_checklist()
    
    elif choice == "4":
        create_env_example()
    
    elif choice == "5":
        print("종료합니다.")
    
    else:
        print("잘못된 선택입니다.")


==================================================
File: C:\Aproject\test\quant_actual\kiwoom_real_api.py
==================================================
"""
file: kiwoom_real_api.py
실제 키움 Open API 클라이언트
주의: Windows 환경에서만 동작하며, 키움 Open API+ 설치 필요
"""

import sys
import logging
from typing import Dict, Any, Optional
from datetime import datetime
import asyncio

# Windows 전용 import
try:
    import pythoncom
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QAxContainer import QAxWidget
    from PyQt5.QtCore import QEventLoop, QTimer
    WINDOWS_AVAILABLE = True
except ImportError:
    WINDOWS_AVAILABLE = False
    print("⚠️ Windows 환경이 아니거나 PyQt5가 설치되지 않았습니다.")

logger = logging.getLogger(__name__)

class KiwoomRealClient:
    """실제 키움 Open API 클라이언트"""
    
    def __init__(self):
        if not WINDOWS_AVAILABLE:
            raise RuntimeError("키움 API는 Windows 환경에서만 사용 가능합니다")
        
        self.is_connected = False
        self.account_number = None
        self.app = None
        self.kiwoom = None
        
        # 실시간 데이터 저장
        self.real_data = {}
        self.order_data = {}
        
        # 이벤트 루프
        self.login_event_loop = None
        self.tr_event_loop = None
        
        # 요청 제한 (초당 5회)
        self.last_request_time = {}
        self.request_interval = 0.2  # 200ms
        
    async def initialize(self):
        """키움 API 초기화"""
        try:
            # QApplication 생성
            if not QApplication.instance():
                self.app = QApplication(sys.argv)
            else:
                self.app = QApplication.instance()
                
            # 키움 OCX 생성
            self.kiwoom = QAxWidget("KHOPENAPI.KHOpenAPICtrl.1")
            
            # 이벤트 연결
            self.kiwoom.OnEventConnect.connect(self._on_event_connect)
            self.kiwoom.OnReceiveTrData.connect(self._on_receive_tr_data)
            self.kiwoom.OnReceiveRealData.connect(self._on_receive_real_data)
            self.kiwoom.OnReceiveChejanData.connect(self._on_receive_chejan_data)
            
            logger.info("키움 API 초기화 완료")
            return True
            
        except Exception as e:
            logger.error(f"키움 API 초기화 실패: {e}")
            return False
    
    async def connect(self):
        """키움 API 로그인"""
        try:
            if not self.kiwoom:
                await self.initialize()
            
            # 이미 연결된 경우
            if self.get_connect_state() == 1:
                self.is_connected = True
                logger.info("키움 API 이미 연결됨")
                return True
            
            # 로그인 요청
            self.login_event_loop = QEventLoop()
            ret = self.kiwoom.dynamicCall("CommConnect()")
            
            if ret == 0:
                self.login_event_loop.exec_()
                
            if self.is_connected:
                # 계좌 정보 조회
                accounts = self.kiwoom.dynamicCall("GetLoginInfo(QString)", "ACCNO")
                self.account_number = accounts.split(';')[0]
                
                logger.info(f"키움 API 로그인 성공 - 계좌: {self.account_number}")
                return True
            else:
                logger.error("키움 API 로그인 실패")
                return False
                
        except Exception as e:
            logger.error(f"키움 API 연결 오류: {e}")
            return False
    
    async def disconnect(self):
        """키움 API 연결 해제"""
        try:
            if self.kiwoom:
                self.kiwoom.dynamicCall("CommTerminate()")
            self.is_connected = False
            logger.info("키움 API 연결 해제됨")
        except Exception as e:
            logger.error(f"키움 API 연결 해제 오류: {e}")
    
    def get_connect_state(self):
        """연결 상태 확인"""
        if self.kiwoom:
            return self.kiwoom.dynamicCall("GetConnectState()")
        return 0
    
    async def get_current_price(self, stock_code: str) -> Dict[str, Any]:
        """현재가 조회"""
        try:
            await self._wait_for_request_limit("current_price")
            
            # TR 요청
            self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "종목코드", stock_code)
            
            self.tr_event_loop = QEventLoop()
            ret = self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)",
                                        "주식기본정보", "opt10001", 0, "0001")
            
            if ret == 0:
                self.tr_event_loop.exec_()
                
                # 데이터 조회
                current_price = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                          "opt10001", "주식기본정보", 0, "현재가"))
                prev_close = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                       "opt10001", "주식기본정보", 0, "기준가"))
                volume = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                   "opt10001", "주식기본정보", 0, "거래량"))
                
                return {
                    'current_price': abs(current_price),  # 음수 제거
                    'prev_close': abs(prev_close),
                    'volume': volume,
                    'price_change': current_price - prev_close,
                    'change_rate': ((current_price - prev_close) / prev_close) * 100,
                    'timestamp': datetime.now().isoformat()
                }
            else:
                logger.error(f"현재가 조회 실패: {stock_code}")
                return {}
                
        except Exception as e:
            logger.error(f"현재가 조회 오류 {stock_code}: {e}")
            return {}
    
    async def send_order(self, stock_code: str, order_type: str, 
                        quantity: int, price: float) -> str:
        """주문 전송"""
        try:
            await self._wait_for_request_limit("send_order")
            
            # 주문 구분 코드 변환
            order_type_code = "1" if order_type.upper() == "BUY" else "2"
            hoga_code = "00"  # 지정가
            
            # 주문 요청
            ret = self.kiwoom.dynamicCall(
                "SendOrder(QString, QString, QString, int, QString, int, int, QString, QString)",
                "자동매매",              # 사용자구분명
                "0001",                 # 화면번호
                self.account_number,    # 계좌번호
                int(order_type_code),   # 주문유형
                stock_code,             # 종목코드
                quantity,               # 주문수량
                int(price),             # 주문가격
                hoga_code,              # 호가구분
                ""                      # 원주문번호
            )
            
            if ret == 0:
                # 주문번호 생성 (실제로는 키움에서 반환)
                order_id = f"ORD{datetime.now().strftime('%Y%m%d%H%M%S')}"
                
                logger.info(f"주문 전송 성공: {stock_code} {order_type} {quantity}주 @ {price}")
                return order_id
            else:
                logger.error(f"주문 전송 실패: {ret}")
                raise Exception(f"주문 전송 실패: {ret}")
                
        except Exception as e:
            logger.error(f"주문 전송 오류: {e}")
            raise
    
    async def cancel_order(self, order_id: str) -> bool:
        """주문 취소"""
        try:
            # 실제로는 원주문번호로 취소 요청
            ret = self.kiwoom.dynamicCall(
                "SendOrder(QString, QString, QString, int, QString, int, int, QString, QString)",
                "취소",                  # 사용자구분명
                "0002",                 # 화면번호
                self.account_number,    # 계좌번호
                3,                      # 취소
                "",                     # 종목코드
                0,                      # 수량
                0,                      # 가격
                "00",                   # 호가구분
                order_id                # 원주문번호
            )
            
            return ret == 0
            
        except Exception as e:
            logger.error(f"주문 취소 오류: {e}")
            return False
    
    async def get_account_info(self) -> Dict[str, Any]:
        """계좌 정보 조회"""
        try:
            await self._wait_for_request_limit("account_info")
            
            # 예수금 조회
            self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "계좌번호", self.account_number)
            self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "비밀번호", "")
            
            self.tr_event_loop = QEventLoop()
            ret = self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)",
                                        "예수금상세현황", "opw00001", 0, "0002")
            
            if ret == 0:
                self.tr_event_loop.exec_()
                
                # 데이터 파싱
                total_cash = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                       "opw00001", "예수금상세현황", 0, "예수금"))
                available_cash = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                           "opw00001", "예수금상세현황", 0, "출금가능금액"))
                
                return {
                    'account_number': self.account_number,
                    'total_cash': total_cash,
                    'available_cash': available_cash,
                    'server_type': 'REAL'
                }
            else:
                logger.error("계좌 정보 조회 실패")
                return {}
                
        except Exception as e:
            logger.error(f"계좌 정보 조회 오류: {e}")
            return {}
    
    async def get_balance(self) -> list:
        """잔고 조회"""
        try:
            await self._wait_for_request_limit("balance")
            
            # 계좌평가잔고내역요청
            self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "계좌번호", self.account_number)
            self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "비밀번호", "")
            
            self.tr_event_loop = QEventLoop()
            ret = self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)",
                                        "계좌평가잔고내역", "opw00018", 0, "0003")
            
            if ret == 0:
                self.tr_event_loop.exec_()
                
                # 잔고 데이터 파싱
                balance = []
                count = self.kiwoom.dynamicCall("GetRepeatCnt(QString, QString)", 
                                               "opw00018", "계좌평가잔고내역")
                
                for i in range(count):
                    stock_code = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                       "opw00018", "계좌평가잔고내역", i, "종목번호").strip()
                    stock_name = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                       "opw00018", "계좌평가잔고내역", i, "종목명").strip()
                    quantity = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                         "opw00018", "계좌평가잔고내역", i, "보유수량"))
                    avg_price = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                          "opw00018", "계좌평가잔고내역", i, "매입가"))
                    current_price = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                              "opw00018", "계좌평가잔고내역", i, "현재가"))
                    
                    if quantity > 0:
                        balance_item = {
                            'stock_code': stock_code,
                            'stock_name': stock_name,
                            'quantity': quantity,
                            'avg_price': abs(avg_price),
                            'current_price': abs(current_price),
                            'current_value': abs(current_price) * quantity,
                            'purchase_value': abs(avg_price) * quantity,
                            'profit_loss': (abs(current_price) - abs(avg_price)) * quantity,
                            'profit_loss_rate': ((abs(current_price) - abs(avg_price)) / abs(avg_price)) * 100
                        }
                        balance.append(balance_item)
                
                return balance
            else:
                logger.error("잔고 조회 실패")
                return []
                
        except Exception as e:
            logger.error(f"잔고 조회 오류: {e}")
            return []
    
    # 이벤트 핸들러들
    def _on_event_connect(self, err_code):
        """로그인 결과 처리"""
        if err_code == 0:
            self.is_connected = True
            logger.info("키움 API 로그인 성공")
        else:
            self.is_connected = False
            logger.error(f"키움 API 로그인 실패: {err_code}")
        
        if self.login_event_loop:
            self.login_event_loop.exit()
    
    def _on_receive_tr_data(self, screen_no, rq_name, tr_code, record_name, next_code):
        """TR 데이터 수신"""
        if self.tr_event_loop:
            self.tr_event_loop.exit()
    
    def _on_receive_real_data(self, stock_code, real_type, real_data):
        """실시간 데이터 수신"""
        try:
            if real_type == "주식체결":
                current_price = int(self.kiwoom.dynamicCall("GetCommRealData(QString, int)", stock_code, 10))
                volume = int(self.kiwoom.dynamicCall("GetCommRealData(QString, int)", stock_code, 15))
                
                self.real_data[stock_code] = {
                    'current_price': abs(current_price),
                    'volume': volume,
                    'timestamp': datetime.now()
                }
                
        except Exception as e:
            logger.error(f"실시간 데이터 처리 오류: {e}")
    
    def _on_receive_chejan_data(self, gubun, item_cnt, fid_list):
        """주문/체결 데이터 수신"""
        try:
            if gubun == "0":  # 주문체결
                order_no = self.kiwoom.dynamicCall("GetChejanData(int)", 9203)
                stock_code = self.kiwoom.dynamicCall("GetChejanData(int)", 9001)
                order_status = self.kiwoom.dynamicCall("GetChejanData(int)", 913)
                
                logger.info(f"주문체결 수신: {stock_code} - {order_status}")
                
        except Exception as e:
            logger.error(f"체결 데이터 처리 오류: {e}")
    
    async def _wait_for_request_limit(self, request_type: str):
        """요청 제한 대기"""
        now = datetime.now().timestamp()
        last_time = self.last_request_time.get(request_type, 0)
        
        if now - last_time < self.request_interval:
            wait_time = self.request_interval - (now - last_time)
            await asyncio.sleep(wait_time)
        
        self.last_request_time[request_type] = datetime.now().timestamp()
    
    def get_connection_status(self) -> Dict[str, Any]:
        """연결 상태 반환"""
        return {
            'is_connected': self.is_connected,
            'account_number': self.account_number,
            'server_type': 'REAL',
            'connection_time': datetime.now().isoformat() if self.is_connected else None
        }

# 싱글톤 패턴으로 구현
_kiwoom_real_client = None

def get_kiwoom_real_client() -> KiwoomRealClient:
    """키움 실거래 클라이언트 싱글톤"""
    global _kiwoom_real_client
    if _kiwoom_real_client is None:
        _kiwoom_real_client = KiwoomRealClient()
    return _kiwoom_real_client


==================================================
File: C:\Aproject\test\quant_actual\package.json
==================================================
{
  "name": "quantrade-frontend",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit",
    "format": "prettier --write .",
    "format:check": "prettier --check ."
  },
  "dependencies": {
    "next": "14.0.4",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "typescript": "5.3.3",
    "@types/node": "20.10.4",
    "@types/react": "18.2.45",
    "@types/react-dom": "18.2.17",
    "tailwindcss": "3.3.6",
    "autoprefixer": "10.4.16",
    "postcss": "8.4.32",
    "clsx": "2.0.0",
    "tailwind-merge": "2.2.0",
    "class-variance-authority": "0.7.0",
    "@tailwindcss/forms": "0.5.7",
    "@tailwindcss/typography": "0.5.10"
  },
  "devDependencies": {
    "eslint": "8.56.0",
    "eslint-config-next": "14.0.4",
    "@typescript-eslint/eslint-plugin": "6.15.0",
    "@typescript-eslint/parser": "6.15.0",
    "prettier": "3.1.1",
    "prettier-plugin-tailwindcss": "0.5.9",
    "@types/eslint": "8.56.0"
  },
  "engines": {
    "node": ">=18.17.0",
    "npm": ">=9.0.0"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
} 



==================================================
File: C:\Aproject\test\quant_actual\start_system.py
==================================================
"""
file: start_system.py
QuanTrade Pro 시스템 시작 스크립트
백엔드와 프론트엔드를 동시에 실행합니다.
"""

import os
import sys
import subprocess
import time
import signal
import threading
import webbrowser
from pathlib import Path

class SystemManager:
    def __init__(self):
        self.backend_process = None
        self.frontend_process = None
        self.running = True
        
        # 프로젝트 디렉토리 설정
        self.project_dir = Path(__file__).parent
        self.backend_dir = self.project_dir / "backend"
        self.frontend_dir = self.project_dir / "frontend"
        
        # 로그 파일 설정
        self.log_dir = self.project_dir / "logs"
        self.log_dir.mkdir(exist_ok=True)
    
    def check_dependencies(self):
        """시스템 의존성 체크"""
        print("🔍 시스템 의존성 체크 중...")
        
        # Python 버전 체크
        python_version = sys.version_info
        if python_version < (3, 9):
            print(f"❌ Python 3.9+ 필요. 현재 버전: {python_version.major}.{python_version.minor}")
            return False
        
        print(f"✅ Python {python_version.major}.{python_version.minor}.{python_version.micro}")
        
        # Node.js 체크
        try:
            result = subprocess.run(['node', '--version'], capture_output=True, text=True)
            if result.returncode == 0:
                node_version = result.stdout.strip()
                print(f"✅ Node.js {node_version}")
            else:
                print("❌ Node.js가 설치되지 않았습니다")
                return False
        except FileNotFoundError:
            print("❌ Node.js가 설치되지 않았습니다")
            return False
        
        # NPM 체크
        try:
            result = subprocess.run(['npm', '--version'], capture_output=True, text=True)
            if result.returncode == 0:
                npm_version = result.stdout.strip()
                print(f"✅ NPM {npm_version}")
            else:
                print("❌ NPM이 설치되지 않았습니다")
                return False
        except FileNotFoundError:
            print("❌ NPM이 설치되지 않았습니다")
            return False
        
        # 디렉토리 체크
        if not self.backend_dir.exists():
            print(f"❌ 백엔드 디렉토리가 없습니다: {self.backend_dir}")
            return False
        
        if not self.frontend_dir.exists():
            print(f"❌ 프론트엔드 디렉토리가 없습니다: {self.frontend_dir}")
            return False
        
        # 필수 파일 체크
        if not (self.backend_dir / "main.py").exists():
            print("❌ backend/main.py 파일이 없습니다")
            return False
        
        if not (self.backend_dir / "requirements.txt").exists():
            print("❌ backend/requirements.txt 파일이 없습니다")
            return False
        
        if not (self.frontend_dir / "package.json").exists():
            print("❌ frontend/package.json 파일이 없습니다")
            return False
        
        print("✅ 모든 의존성 체크 완료")
        return True
    
    def install_dependencies(self):
        """의존성 설치"""
        print("\n📦 의존성 설치 중...")
        
        # Python 의존성 설치
        print("🐍 Python 패키지 설치 중...")
        try:
            cmd = [sys.executable, "-m", "pip", "install", "-r", "requirements.txt"]
            result = subprocess.run(
                cmd, 
                cwd=self.backend_dir, 
                capture_output=True, 
                text=True
            )
            
            if result.returncode != 0:
                print(f"❌ Python 패키지 설치 실패:\n{result.stderr}")
                return False
            
            print("✅ Python 패키지 설치 완료")
            
        except Exception as e:
            print(f"❌ Python 패키지 설치 중 오류: {e}")
            return False
        
        # Node.js 의존성 설치
        print("📦 Node.js 패키지 설치 중...")
        try:
            result = subprocess.run(
                ["npm", "install"], 
                cwd=self.frontend_dir, 
                capture_output=True, 
                text=True
            )
            
            if result.returncode != 0:
                print(f"❌ Node.js 패키지 설치 실패:\n{result.stderr}")
                return False
            
            print("✅ Node.js 패키지 설치 완료")
            
        except Exception as e:
            print(f"❌ Node.js 패키지 설치 중 오류: {e}")
            return False
        
        return True
    
    def start_backend(self):
        """백엔드 서버 시작"""
        print("\n🚀 백엔드 서버 시작 중...")
        
        try:
            # 백엔드 로그 파일
            backend_log = self.log_dir / "backend.log"
            
            with open(backend_log, "w") as log_file:
                self.backend_process = subprocess.Popen(
                    [sys.executable, "main.py"],
                    cwd=self.backend_dir,
                    stdout=log_file,
                    stderr=subprocess.STDOUT,
                    text=True
                )
            
            # 서버 시작 대기
            time.sleep(3)
            
            if self.backend_process.poll() is None:
                print("✅ 백엔드 서버 시작됨 (http://localhost:8000)")
                return True
            else:
                print("❌ 백엔드 서버 시작 실패")
                return False
                
        except Exception as e:
            print(f"❌ 백엔드 시작 중 오류: {e}")
            return False
    
    def start_frontend(self):
        """프론트엔드 서버 시작"""
        print("\n🎨 프론트엔드 서버 시작 중...")
        
        try:
            # 프론트엔드 로그 파일
            frontend_log = self.log_dir / "frontend.log"
            
            with open(frontend_log, "w") as log_file:
                self.frontend_process = subprocess.Popen(
                    ["npm", "run", "dev"],
                    cwd=self.frontend_dir,
                    stdout=log_file,
                    stderr=subprocess.STDOUT,
                    text=True
                )
            
            # 서버 시작 대기
            time.sleep(5)
            
            if self.frontend_process.poll() is None:
                print("✅ 프론트엔드 서버 시작됨 (http://localhost:3000)")
                return True
            else:
                print("❌ 프론트엔드 서버 시작 실패")
                return False
                
        except Exception as e:
            print(f"❌ 프론트엔드 시작 중 오류: {e}")
            return False
    
    def check_server_health(self):
        """서버 상태 체크"""
        try:
            import requests
            
            # 백엔드 헬스 체크
            try:
                response = requests.get("http://localhost:8000/health", timeout=5)
                if response.status_code == 200:
                    print("✅ 백엔드 서버 정상 작동")
                else:
                    print(f"⚠️  백엔드 서버 상태 이상: {response.status_code}")
            except requests.RequestException:
                print("❌ 백엔드 서버 연결 실패")
                return False
            
            # 프론트엔드 헬스 체크
            try:
                response = requests.get("http://localhost:3000", timeout=5)
                if response.status_code == 200:
                    print("✅ 프론트엔드 서버 정상 작동")
                else:
                    print(f"⚠️  프론트엔드 서버 상태 이상: {response.status_code}")
            except requests.RequestException:
                print("❌ 프론트엔드 서버 연결 실패")
                return False
            
            return True
            
        except ImportError:
            print("⚠️  requests 모듈이 없어 헬스 체크를 건너뜁니다")
            return True
    
    def open_browser(self):
        """브라우저에서 애플리케이션 열기"""
        try:
            print("\n🌐 브라우저에서 애플리케이션을 엽니다...")
            webbrowser.open("http://localhost:3000")
            time.sleep(2)
        except Exception as e:
            print(f"⚠️  브라우저 열기 실패: {e}")
            print("수동으로 http://localhost:3000 에 접속하세요")
    
    def monitor_processes(self):
        """프로세스 상태 모니터링"""
        while self.running:
            try:
                # 백엔드 프로세스 체크
                if self.backend_process and self.backend_process.poll() is not None:
                    print("❌ 백엔드 프로세스가 종료되었습니다")
                    self.running = False
                    break
                
                # 프론트엔드 프로세스 체크
                if self.frontend_process and self.frontend_process.poll() is not None:
                    print("❌ 프론트엔드 프로세스가 종료되었습니다")
                    self.running = False
                    break
                
                time.sleep(5)
                
            except KeyboardInterrupt:
                break
    
    def cleanup(self):
        """프로세스 정리"""
        print("\n🛑 시스템 종료 중...")
        
        if self.backend_process:
            try:
                self.backend_process.terminate()
                self.backend_process.wait(timeout=5)
                print("✅ 백엔드 서버 종료됨")
            except subprocess.TimeoutExpired:
                self.backend_process.kill()
                print("🔥 백엔드 서버 강제 종료됨")
            except Exception as e:
                print(f"⚠️  백엔드 종료 중 오류: {e}")
        
        if self.frontend_process:
            try:
                self.frontend_process.terminate()
                self.frontend_process.wait(timeout=5)
                print("✅ 프론트엔드 서버 종료됨")
            except subprocess.TimeoutExpired:
                self.frontend_process.kill()
                print("🔥 프론트엔드 서버 강제 종료됨")
            except Exception as e:
                print(f"⚠️  프론트엔드 종료 중 오류: {e}")
    
    def signal_handler(self, signum, frame):
        """시그널 핸들러"""
        print(f"\n📡 시그널 {signum} 수신됨")
        self.running = False
        self.cleanup()
        sys.exit(0)
    
    def start_system(self, install_deps=True, open_browser=True):
        """전체 시스템 시작"""
        print("🚀 QuanTrade Pro 시스템 시작")
        print("=" * 50)
        
        # 시그널 핸들러 등록
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
        
        try:
            # 1. 의존성 체크
            if not self.check_dependencies():
                print("❌ 의존성 체크 실패")
                return False
            
            # 2. 의존성 설치 (옵션)
            if install_deps:
                if not self.install_dependencies():
                    print("❌ 의존성 설치 실패")
                    return False
            
            # 3. 백엔드 시작
            if not self.start_backend():
                print("❌ 백엔드 시작 실패")
                return False
            
            # 4. 프론트엔드 시작
            if not self.start_frontend():
                print("❌ 프론트엔드 시작 실패")
                self.cleanup()
                return False
            
            # 5. 서버 상태 체크
            time.sleep(3)
            if not self.check_server_health():
                print("⚠️  서버 상태 체크 실패, 계속 진행합니다")
            
            # 6. 브라우저 열기 (옵션)
            if open_browser:
                self.open_browser()
            
            # 7. 시스템 정보 출력
            self.print_system_info()
            
            # 8. 프로세스 모니터링 시작
            monitor_thread = threading.Thread(target=self.monitor_processes)
            monitor_thread.daemon = True
            monitor_thread.start()
            
            # 9. 메인 루프
            print("\n✅ 시스템이 성공적으로 시작되었습니다!")
            print("Ctrl+C를 눌러 종료하세요")
            
            while self.running:
                try:
                    time.sleep(1)
                except KeyboardInterrupt:
                    break
            
            return True
            
        except Exception as e:
            print(f"❌ 시스템 시작 중 오류: {e}")
            return False
        
        finally:
            self.cleanup()
    
    def print_system_info(self):
        """시스템 정보 출력"""
        print("\n" + "=" * 50)
        print("🎯 QuanTrade Pro 시스템 정보")
        print("=" * 50)
        print(f"📍 프론트엔드: http://localhost:3000")
        print(f"📍 백엔드 API: http://localhost:8000")
        print(f"📍 API 문서: http://localhost:8000/docs")
        print(f"📁 로그 디렉토리: {self.log_dir}")
        print(f"📁 프로젝트 디렉토리: {self.project_dir}")
        print("=" * 50)
        
        print("\n💡 사용법:")
        print("• 웹 브라우저에서 http://localhost:3000 접속")
        print("• 전략을 활성화하고 자동매매 시작 버튼 클릭")
        print("• 실시간 수익 현황 및 주문 내역 모니터링")
        print("• 긴급 상황 시 긴급중단 버튼 사용")
        
        print("\n⚠️  주의사항:")
        print("• 현재는 모의투자 모드로 실행됩니다")
        print("• 실제 거래 전 충분한 테스트를 권장합니다")
        print("• 리스크 관리 설정을 반드시 확인하세요")
        
        print("\n🔧 문제 해결:")
        print(f"• 백엔드 로그: tail -f {self.log_dir}/backend.log")
        print(f"• 프론트엔드 로그: tail -f {self.log_dir}/frontend.log")
        print("• 포트 충돌 시: lsof -i :3000 또는 lsof -i :8000")


def main():
    """메인 함수"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="QuanTrade Pro 시스템 시작 스크립트",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
사용 예시:
  python start_system.py              # 전체 시스템 시작
  python start_system.py --no-install # 의존성 설치 건너뛰기
  python start_system.py --no-browser # 브라우저 자동 열기 비활성화
  python start_system.py --check-only # 의존성만 체크하고 종료
        """
    )
    
    parser.add_argument(
        "--no-install", 
        action="store_true",
        help="의존성 설치 건너뛰기"
    )
    
    parser.add_argument(
        "--no-browser", 
        action="store_true",
        help="브라우저 자동 열기 비활성화"
    )
    
    parser.add_argument(
        "--check-only", 
        action="store_true",
        help="의존성만 체크하고 종료"
    )
    
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="상세 로그 출력"
    )
    
    args = parser.parse_args()
    
    # 시스템 매니저 생성
    system_manager = SystemManager()
    
    # 의존성만 체크하고 종료
    if args.check_only:
        print("🔍 의존성 체크 모드")
        if system_manager.check_dependencies():
            print("✅ 모든 의존성이 충족되었습니다")
            sys.exit(0)
        else:
            print("❌ 의존성 문제가 있습니다")
            sys.exit(1)
    
    # 전체 시스템 시작
    success = system_manager.start_system(
        install_deps=not args.no_install,
        open_browser=not args.no_browser
    )
    
    if success:
        print("\n👋 QuanTrade Pro를 이용해 주셔서 감사합니다!")
        sys.exit(0)
    else:
        print("\n❌ 시스템 시작에 실패했습니다")
        sys.exit(1)


if __name__ == "__main__":
    main()


==================================================
File: C:\Aproject\test\quant_actual\trading_mode.tsx
==================================================
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'

interface SystemStatus {
  current_mode: 'DEMO' | 'REAL'
  is_windows: boolean
  kiwoom_api_available: boolean
  account_connected: boolean
  account_info?: {
    account_number: string
    server_type: string
    available_cash: number
  }
}

export default function TradingModeSelector() {
  const [systemStatus, setSystemStatus] = useState<SystemStatus | null>(null)
  const [selectedMode, setSelectedMode] = useState<'DEMO' | 'REAL'>('DEMO')
  const [loading, setLoading] = useState(true)
  const [isChanging, setIsChanging] = useState(false)
  const [showRealTradeWarning, setShowRealTradeWarning] = useState(false)
  const [acceptedTerms, setAcceptedTerms] = useState(false)
  const [confirmationText, setConfirmationText] = useState('')
  const router = useRouter()

  useEffect(() => {
    checkSystemStatus()
  }, [])

  const checkSystemStatus = async () => {
    try {
      const response = await fetch('/api/proxy/system/trading-mode')
      const data = await response.json()
      setSystemStatus(data)
      setSelectedMode(data.current_mode)
    } catch (error) {
      console.error('시스템 상태 확인 실패:', error)
    } finally {
      setLoading(false)
    }
  }

  const handleModeChange = async (mode: 'DEMO' | 'REAL') => {
    if (mode === 'REAL') {
      setShowRealTradeWarning(true)
      return
    }
    
    await changeTradingMode(mode)
  }

  const changeTradingMode = async (mode: 'DEMO' | 'REAL') => {
    setIsChanging(true)
    
    try {
      const response = await fetch('/api/proxy/system/change-trading-mode', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ mode })
      })

      if (response.ok) {
        setSelectedMode(mode)
        await checkSystemStatus()
        
        if (mode === 'DEMO') {
          alert('모의투자 모드로 변경되었습니다.')
        } else {
          alert('실거래 모드로 변경되었습니다. 주의해서 거래하세요!')
        }
      } else {
        const error = await response.json()
        alert(`모드 변경 실패: ${error.detail}`)
      }
    } catch (error) {
      console.error('모드 변경 실패:', error)
      alert('모드 변경 중 오류가 발생했습니다.')
    } finally {
      setIsChanging(false)
      setShowRealTradeWarning(false)
      setAcceptedTerms(false)
      setConfirmationText('')
    }
  }

  const handleRealTradeConfirm = () => {
    if (!acceptedTerms) {
      alert('위험 고지를 먼저 확인해주세요.')
      return
    }

    if (confirmationText !== 'START REAL TRADING') {
      alert('확인 텍스트를 정확히 입력해주세요.')
      return
    }

    changeTradingMode('REAL')
  }

  const startTrading = () => {
    router.push('/dashboard')
  }

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-white text-xl">시스템 상태 확인 중...</div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gray-900 text-white">
      {/* 헤더 */}
      <header className="bg-gray-800 px-6 py-4 border-b border-gray-700">
        <h1 className="text-2xl font-bold text-green-400">QuanTrade Pro - 거래 모드 선택</h1>
      </header>

      <div className="container mx-auto px-6 py-8">
        <div className="max-w-4xl mx-auto">
          
          {/* 현재 시스템 상태 */}
          <div className="bg-gray-800 rounded-lg p-6 mb-8">
            <h2 className="text-xl font-semibold mb-4">📊 현재 시스템 상태</h2>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <div className="bg-gray-700 p-4 rounded">
                <div className="text-sm text-gray-400">현재 모드</div>
                <div className={`text-lg font-bold ${
                  systemStatus?.current_mode === 'REAL' ? 'text-red-400' : 'text-blue-400'
                }`}>
                  {systemStatus?.current_mode === 'REAL' ? '실거래' : '모의투자'}
                </div>
              </div>
              
              <div className="bg-gray-700 p-4 rounded">
                <div className="text-sm text-gray-400">운영체제</div>
                <div className={`text-lg font-bold ${
                  systemStatus?.is_windows ? 'text-green-400' : 'text-yellow-400'
                }`}>
                  {systemStatus?.is_windows ? 'Windows' : 'Other'}
                </div>
              </div>
              
              <div className="bg-gray-700 p-4 rounded">
                <div className="text-sm text-gray-400">키움 API</div>
                <div className={`text-lg font-bold ${
                  systemStatus?.kiwoom_api_available ? 'text-green-400' : 'text-red-400'
                }`}>
                  {systemStatus?.kiwoom_api_available ? '사용 가능' : '불가능'}
                </div>
              </div>
              
              <div className="bg-gray-700 p-4 rounded">
                <div className="text-sm text-gray-400">계좌 연결</div>
                <div className={`text-lg font-bold ${
                  systemStatus?.account_connected ? 'text-green-400' : 'text-gray-400'
                }`}>
                  {systemStatus?.account_connected ? '연결됨' : '미연결'}
                </div>
              </div>
            </div>

            {/* 계좌 정보 */}
            {systemStatus?.account_info && (
              <div className="mt-4 p-4 bg-gray-700 rounded">
                <div className="text-sm text-gray-400 mb-2">계좌 정보</div>
                <div className="flex justify-between items-center">
                  <span>계좌번호: {systemStatus.account_info.account_number}</span>
                  <span>서버: {systemStatus.account_info.server_type}</span>
                  <span>가용자금: ₩{systemStatus.account_info.available_cash.toLocaleString()}</span>
                </div>
              </div>
            )}
          </div>

          {/* 거래 모드 선택 */}
          <div className="grid md:grid-cols-2 gap-8 mb-8">
            
            {/* 모의투자 모드 */}
            <div className={`bg-gray-800 rounded-lg p-6 border-2 transition-all cursor-pointer ${
              selectedMode === 'DEMO' ? 'border-blue-500 bg-blue-900/20' : 'border-gray-600 hover:border-blue-400'
            }`} onClick={() => setSelectedMode('DEMO')}>
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-xl font-bold text-blue-400">🎮 모의투자 모드</h3>
                <div className={`w-6 h-6 rounded-full border-2 flex items-center justify-center ${
                  selectedMode === 'DEMO' ? 'border-blue-500 bg-blue-500' : 'border-gray-400'
                }`}>
                  {selectedMode === 'DEMO' && <div className="w-3 h-3 bg-white rounded-full"></div>}
                </div>
              </div>
              
              <div className="space-y-3 text-sm">
                <div className="flex items-center space-x-2">
                  <span className="text-green-400">✅</span>
                  <span>실제 돈을 사용하지 않음</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-green-400">✅</span>
                  <span>모든 플랫폼에서 실행 가능</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-green-400">✅</span>
                  <span>전략 테스트 및 학습에 최적</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-green-400">✅</span>
                  <span>위험 없이 시스템 동작 확인</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-blue-400">💡</span>
                  <span>실시간 시세 시뮬레이션</span>
                </div>
              </div>

              <div className="mt-4 p-3 bg-blue-900/30 rounded text-xs">
                <strong>추천 대상:</strong> 초보자, 전략 개발자, 시스템 테스트
              </div>
            </div>

            {/* 실거래 모드 */}
            <div className={`bg-gray-800 rounded-lg p-6 border-2 transition-all cursor-pointer ${
              selectedMode === 'REAL' ? 'border-red-500 bg-red-900/20' : 'border-gray-600 hover:border-red-400'
            } ${!systemStatus?.is_windows || !systemStatus?.kiwoom_api_available ? 'opacity-50 cursor-not-allowed' : ''}`} 
            onClick={() => systemStatus?.is_windows && systemStatus?.kiwoom_api_available && setSelectedMode('REAL')}>
              
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-xl font-bold text-red-400">🔥 실거래 모드</h3>
                <div className={`w-6 h-6 rounded-full border-2 flex items-center justify-center ${
                  selectedMode === 'REAL' ? 'border-red-500 bg-red-500' : 'border-gray-400'
                }`}>
                  {selectedMode === 'REAL' && <div className="w-3 h-3 bg-white rounded-full"></div>}
                </div>
              </div>
              
              <div className="space-y-3 text-sm">
                <div className="flex items-center space-x-2">
                  <span className="text-red-400">⚠️</span>
                  <span>실제 돈으로 거래</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-yellow-400">🖥️</span>
                  <span>Windows 환경 필수</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-yellow-400">🔑</span>
                  <span>키움증권 계좌 필요</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-red-400">💰</span>
                  <span>투자 손실 위험</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-green-400">📈</span>
                  <span>실제 수익 가능</span>
                </div>
              </div>

              <div className="mt-4 p-3 bg-red-900/30 rounded text-xs">
                <strong>추천 대상:</strong> 경험자, 충분한 테스트 완료, 소액 투자 가능자
              </div>

              {/* 실거래 불가능한 경우 안내 */}
              {(!systemStatus?.is_windows || !systemStatus?.kiwoom_api_available) && (
                <div className="mt-4 p-3 bg-gray-700 rounded text-xs text-yellow-400">
                  <strong>실거래 불가능:</strong> 
                  {!systemStatus?.is_windows && " Windows 환경 필요"}
                  {!systemStatus?.kiwoom_api_available && " 키움 API 설치 필요"}
                </div>
              )}
            </div>
          </div>

          {/* 모드 변경 버튼 */}
          <div className="flex justify-center space-x-4 mb-8">
            {selectedMode !== systemStatus?.current_mode && (
              <button
                onClick={() => handleModeChange(selectedMode)}
                disabled={isChanging || (!systemStatus?.is_windows && selectedMode === 'REAL')}
                className={`px-8 py-3 rounded-lg font-semibold transition-all ${
                  selectedMode === 'REAL'
                    ? 'bg-red-600 hover:bg-red-700 text-white'
                    : 'bg-blue-600 hover:bg-blue-700 text-white'
                } disabled:opacity-50 disabled:cursor-not-allowed`}
              >
                {isChanging ? '변경 중...' : `${selectedMode === 'REAL' ? '실거래' : '모의투자'} 모드로 변경`}
              </button>
            )}
            
            <button
              onClick={startTrading}
              className="px-8 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg font-semibold transition-all"
            >
              트레이딩 시작
            </button>
          </div>

          {/* 주의사항 */}
          <div className="bg-yellow-900/20 border border-yellow-600 rounded-lg p-6">
            <h3 className="text-yellow-400 font-semibold mb-3">⚠️ 중요 안내사항</h3>
            <ul className="space-y-2 text-sm">
              <li>• <strong>모의투자:</strong> 가상의 돈으로 거래하므로 실제 손익이 발생하지 않습니다</li>
              <li>• <strong>실거래:</strong> 실제 돈으로 거래하므로 투자 손실 위험이 있습니다</li>
              <li>• 실거래 전에는 반드시 모의투자로 충분한 테스트를 진행하세요</li>
              <li>• 시스템 오류나 네트워크 장애로 인한 손실 가능성이 있습니다</li>
              <li>• 소액으로 시작하여 점진적으로 투자금액을 늘려가세요</li>
            </ul>
          </div>
        </div>
      </div>

      {/* 실거래 확인 모달 */}
      {showRealTradeWarning && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
          <div className="bg-gray-800 rounded-lg p-8 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto">
            <div className="text-center mb-6">
              <div className="text-6xl mb-4">⚠️</div>
              <h2 className="text-2xl font-bold text-red-400">실거래 모드 경고</h2>
            </div>

            <div className="space-y-4 text-sm mb-6">
              <div className="bg-red-900/30 p-4 rounded">
                <h3 className="font-bold text-red-400 mb-2">🚨 위험 고지</h3>
                <ul className="space-y-1">
                  <li>• 이 소프트웨어는 실제 돈으로 자동매매를 실행합니다</li>
                  <li>• 투자원금 손실 위험이 있습니다</li>
                  <li>• 시스템 오류, 네트워크 장애로 인한 손실 가능성이 있습니다</li>
                  <li>• 급격한 시장 변동 시 큰 손실이 발생할 수 있습니다</li>
                  <li>• 개발자는 투자 손실에 대해 어떠한 책임도 지지 않습니다</li>
                </ul>
              </div>

              <div className="bg-yellow-900/30 p-4 rounded">
                <h3 className="font-bold text-yellow-400 mb-2">✅ 사전 준비사항</h3>
                <ul className="space-y-1">
                  <li>• 키움증권 계좌 개설 및 Open API+ 설치 완료</li>
                  <li>• 모의투자로 최소 1개월 이상 테스트 완료</li>
                  <li>• 손절/익절 설정 및 리스크 관리 설정 확인</li>
                  <li>• 투자 가능한 소액으로 시작 (권장: 10만원 이하)</li>
                  <li>• 실시간 모니터링 가능한 환경 구축</li>
                </ul>
              </div>
            </div>

            <div className="space-y-4">
              <label className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={acceptedTerms}
                  onChange={(e) => setAcceptedTerms(e.target.checked)}
                  className="w-4 h-4"
                />
                <span className="text-sm">위험 고지를 모두 읽고 이해했으며, 모든 투자 손실에 대한 책임을 집니다</span>
              </label>

              <div>
                <label className="block text-sm mb-2">
                  확인을 위해 <span className="text-red-400 font-bold">"START REAL TRADING"</span>을 입력하세요:
                </label>
                <input
                  type="text"
                  value={confirmationText}
                  onChange={(e) => setConfirmationText(e.target.value)}
                  className="w-full p-3 bg-gray-700 rounded text-white"
                  placeholder="START REAL TRADING"
                />
              </div>
            </div>

            <div className="flex justify-end space-x-4 mt-6">
              <button
                onClick={() => setShowRealTradeWarning(false)}
                className="px-6 py-2 bg-gray-600 hover:bg-gray-700 rounded text-white"
              >
                취소
              </button>
              <button
                onClick={handleRealTradeConfirm}
                disabled={!acceptedTerms || confirmationText !== 'START REAL TRADING'}
                className="px-6 py-2 bg-red-600 hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed rounded text-white font-semibold"
              >
                실거래 시작
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}


==================================================
File: C:\Aproject\test\quant_actual\trading_mode_api.py
==================================================
"""
file: trading_mode_api.py
거래 모드 전환 API
Mock ↔ Real 모드 전환을 위한 엔드포인트
"""

import os
import platform
import logging
from typing import Dict, Any
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel

from utils.config import get_settings
from database import get_db_session

logger = logging.getLogger(__name__)

# 전역 변수로 현재 모드 저장
CURRENT_TRADING_MODE = "DEMO"  # DEMO or REAL
KIWOOM_CLIENT_INSTANCE = None

class TradingModeRequest(BaseModel):
    mode: str  # "DEMO" or "REAL"

class SystemStatusResponse(BaseModel):
    current_mode: str
    is_windows: bool
    kiwoom_api_available: bool
    account_connected: bool
    account_info: Dict[str, Any] = None

router = APIRouter()

def check_windows_environment() -> bool:
    """Windows 환경 체크"""
    return platform.system() == "Windows"

def check_kiwoom_api_available() -> bool:
    """키움 API 사용 가능성 체크"""
    if not check_windows_environment():
        return False
    
    try:
        # PyQt5와 pythoncom 모듈 체크
        import PyQt5
        import pythoncom
        
        # 키움 API 파일 존재 체크 (일반적인 설치 경로)
        kiwoom_paths = [
            "C:\\OpenAPI\\",
            "C:\\Program Files\\OpenAPI\\",
            "C:\\Program Files (x86)\\OpenAPI\\"
        ]
        
        for path in kiwoom_paths:
            if os.path.exists(path):
                return True
        
        # 레지스트리에서 키움 API 확인 (선택적)
        try:
            import winreg
            key = winreg.OpenKey(winreg.HKEY_CLASSES_ROOT, "KHOPENAPI.KHOpenAPICtrl.1")
            winreg.CloseKey(key)
            return True
        except:
            pass
        
        return False
        
    except ImportError:
        return False

async def get_account_info():
    """계좌 정보 조회"""
    global KIWOOM_CLIENT_INSTANCE
    
    if CURRENT_TRADING_MODE == "REAL" and KIWOOM_CLIENT_INSTANCE:
        try:
            account_info = await KIWOOM_CLIENT_INSTANCE.get_account_info()
            return account_info
        except Exception as e:
            logger.error(f"실거래 계좌 정보 조회 실패: {e}")
            return None
    else:
        # Mock 모드 계좌 정보
        return {
            "account_number": "8012345-01",
            "server_type": "DEMO",
            "available_cash": 50000000,
            "total_cash": 50000000
        }

@router.get("/system/trading-mode", response_model=SystemStatusResponse)
async def get_trading_mode_status():
    """현재 거래 모드 상태 조회"""
    try:
        is_windows = check_windows_environment()
        kiwoom_available = check_kiwoom_api_available()
        
        # 계좌 연결 상태 체크
        account_connected = False
        account_info = None
        
        if CURRENT_TRADING_MODE == "REAL" and KIWOOM_CLIENT_INSTANCE:
            account_connected = KIWOOM_CLIENT_INSTANCE.is_connected
            if account_connected:
                account_info = await get_account_info()
        elif CURRENT_TRADING_MODE == "DEMO":
            account_connected = True  # Mock 모드에서는 항상 연결됨
            account_info = await get_account_info()
        
        return SystemStatusResponse(
            current_mode=CURRENT_TRADING_MODE,
            is_windows=is_windows,
            kiwoom_api_available=kiwoom_available,
            account_connected=account_connected,
            account_info=account_info
        )
        
    except Exception as e:
        logger.error(f"거래 모드 상태 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to get trading mode status")

@router.post("/system/change-trading-mode")
async def change_trading_mode(request: TradingModeRequest):
    """거래 모드 변경"""
    global CURRENT_TRADING_MODE, KIWOOM_CLIENT_INSTANCE
    
    try:
        new_mode = request.mode.upper()
        
        if new_mode not in ["DEMO", "REAL"]:
            raise HTTPException(status_code=400, detail="Invalid trading mode")
        
        if new_mode == CURRENT_TRADING_MODE:
            return {"success": True, "message": f"이미 {new_mode} 모드입니다."}
        
        # 실거래 모드 전환 시 추가 검증
        if new_mode == "REAL":
            if not check_windows_environment():
                raise HTTPException(
                    status_code=400, 
                    detail="실거래 모드는 Windows 환경에서만 사용 가능합니다."
                )
            
            if not check_kiwoom_api_available():
                raise HTTPException(
                    status_code=400, 
                    detail="키움 Open API가 설치되지 않았습니다."
                )
            
            # 환경변수 체크
            if not os.getenv("KIWOOM_ACCOUNT"):
                raise HTTPException(
                    status_code=400, 
                    detail="KIWOOM_ACCOUNT 환경변수가 설정되지 않았습니다."
                )
            
            if not os.getenv("KIWOOM_PASSWORD"):
                raise HTTPException(
                    status_code=400, 
                    detail="KIWOOM_PASSWORD 환경변수가 설정되지 않았습니다."
                )
        
        # 기존 연결 해제
        if KIWOOM_CLIENT_INSTANCE:
            try:
                await KIWOOM_CLIENT_INSTANCE.disconnect()
            except:
                pass
            KIWOOM_CLIENT_INSTANCE = None
        
        # 새로운 모드로 전환
        if new_mode == "REAL":
            # 실거래 클라이언트 초기화
            from data.kiwoom_real import KiwoomRealClient
            KIWOOM_CLIENT_INSTANCE = KiwoomRealClient()
            
            # 연결 시도
            if not await KIWOOM_CLIENT_INSTANCE.initialize():
                raise HTTPException(status_code=500, detail="키움 API 초기화 실패")
            
            if not await KIWOOM_CLIENT_INSTANCE.connect():
                raise HTTPException(status_code=500, detail="키움 API 연결 실패")
            
            logger.warning("실거래 모드로 전환됨")
            
        else:  # DEMO 모드
            # Mock 클라이언트 초기화
            from data.kiwoom_mock import KiwoomClient
            KIWOOM_CLIENT_INSTANCE = KiwoomClient()
            await KIWOOM_CLIENT_INSTANCE.connect()
            
            logger.info("모의투자 모드로 전환됨")
        
        # 모드 변경
        CURRENT_TRADING_MODE = new_mode
        
        # 트레이딩 엔진에 새로운 클라이언트 적용
        from main import get_trading_engine
        trading_engine = get_trading_engine()
        trading_engine.kiwoom_client = KIWOOM_CLIENT_INSTANCE
        
        # 데이터베이스에 모드 변경 기록
        with get_db_session() as db:
            # 실제로는 SystemLog 테이블에 기록
            pass
        
        return {
            "success": True,
            "message": f"{new_mode} 모드로 변경되었습니다.",
            "mode": new_mode,
            "account_connected": KIWOOM_CLIENT_INSTANCE.is_connected if KIWOOM_CLIENT_INSTANCE else False
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"거래 모드 변경 실패: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to change trading mode: {str(e)}")

@router.get("/system/environment-check")
async def check_environment():
    """환경 체크 및 설치 가이드"""
    try:
        checks = {
            "operating_system": {
                "name": platform.system(),
                "version": platform.version(),
                "is_windows": check_windows_environment(),
                "status": "✅" if check_windows_environment() else "❌"
            },
            "python_version": {
                "version": platform.python_version(),
                "is_compatible": platform.python_version() >= "3.9",
                "status": "✅" if platform.python_version() >= "3.9" else "❌"
            },
            "required_packages": {},
            "kiwoom_api": {
                "available": check_kiwoom_api_available(),
                "status": "✅" if check_kiwoom_api_available() else "❌"
            },
            "environment_variables": {
                "kiwoom_account": bool(os.getenv("KIWOOM_ACCOUNT")),
                "kiwoom_password": bool(os.getenv("KIWOOM_PASSWORD")),
                "status": "✅" if (os.getenv("KIWOOM_ACCOUNT") and os.getenv("KIWOOM_PASSWORD")) else "❌"
            }
        }
        
        # Python 패키지 체크
        required_packages = ["PyQt5", "pythoncom", "fastapi", "sqlalchemy", "pandas", "numpy"]
        
        for package in required_packages:
            try:
                __import__(package.lower())
                checks["required_packages"][package] = {"installed": True, "status": "✅"}
            except ImportError:
                checks["required_packages"][package] = {"installed": False, "status": "❌"}
        
        # 전체 상태 판정
        overall_status = "READY" if all([
            checks["operating_system"]["is_windows"],
            checks["python_version"]["is_compatible"],
            all(pkg["installed"] for pkg in checks["required_packages"].values()),
            checks["kiwoom_api"]["available"]
        ]) else "NOT_READY"
        
        return {
            "overall_status": overall_status,
            "checks": checks,
            "recommendations": get_installation_recommendations(checks)
        }
        
    except Exception as e:
        logger.error(f"환경 체크 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to check environment")

def get_installation_recommendations(checks: Dict) -> List[str]:
    """설치 권장사항 생성"""
    recommendations = []
    
    if not checks["operating_system"]["is_windows"]:
        recommendations.append("실거래를 위해서는 Windows 환경이 필요합니다.")
    
    if not checks["python_version"]["is_compatible"]:
        recommendations.append("Python 3.9 이상으로 업그레이드가 필요합니다.")
    
    missing_packages = [
        pkg for pkg, info in checks["required_packages"].items() 
        if not info["installed"]
    ]
    
    if missing_packages:
        recommendations.append(f"다음 패키지 설치 필요: {', '.join(missing_packages)}")
        recommendations.append("pip install " + " ".join(missing_packages))
    
    if not checks["kiwoom_api"]["available"]:
        recommendations.extend([
            "키움 Open API+ 설치가 필요합니다:",
            "1. 키움증권 홈페이지 → 고객지원 → API",
            "2. Open API+ 다운로드 및 설치",
            "3. 시스템 재부팅 후 재시도"
        ])
    
    if not checks["environment_variables"]["kiwoom_account"]:
        recommendations.extend([
            "환경변수 설정이 필요합니다:",
            "KIWOOM_ACCOUNT=실제계좌번호",
            "KIWOOM_PASSWORD=실제비밀번호"
        ])
    
    if not recommendations:
        recommendations.append("모든 요구사항이 충족되었습니다. 실거래 준비 완료!")
    
    return recommendations

@router.post("/system/test-connection")
async def test_connection(request: TradingModeRequest):
    """연결 테스트"""
    try:
        mode = request.mode.upper()
        
        if mode == "DEMO":
            # Mock 연결 테스트
            from data.kiwoom_mock import KiwoomClient
            test_client = KiwoomClient()
            
            if await test_client.connect():
                await test_client.disconnect()
                return {
                    "success": True,
                    "message": "모의투자 연결 테스트 성공",
                    "details": {
                        "mode": "DEMO",
                        "connection_time": "< 1초",
                        "account": "모의계좌"
                    }
                }
            else:
                raise HTTPException(status_code=500, detail="모의투자 연결 실패")
        
        elif mode == "REAL":
            # 실거래 연결 테스트
            if not check_windows_environment():
                raise HTTPException(status_code=400, detail="Windows 환경이 아닙니다")
            
            if not check_kiwoom_api_available():
                raise HTTPException(status_code=400, detail="키움 API가 설치되지 않았습니다")
            
            from data.kiwoom_real import KiwoomRealClient
            test_client = KiwoomRealClient()
            
            if await test_client.initialize():
                if await test_client.connect():
                    account_info = await test_client.get_account_info()
                    await test_client.disconnect()
                    
                    return {
                        "success": True,
                        "message": "실거래 연결 테스트 성공",
                        "details": {
                            "mode": "REAL",
                            "account": account_info.get("account_number", "확인불가"),
                            "server_type": account_info.get("server_type", "REAL"),
                            "available_cash": account_info.get("available_cash", 0)
                        }
                    }
                else:
                    raise HTTPException(status_code=500, detail="키움 API 로그인 실패")
            else:
                raise HTTPException(status_code=500, detail="키움 API 초기화 실패")
        
        else:
            raise HTTPException(status_code=400, detail="잘못된 모드입니다")
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"연결 테스트 실패: {e}")
        raise HTTPException(status_code=500, detail=f"Connection test failed: {str(e)}")

@router.get("/system/trading-mode-guide")
async def get_trading_mode_guide():
    """거래 모드 가이드"""
    return {
        "modes": {
            "DEMO": {
                "name": "모의투자 모드",
                "description": "가상의 돈으로 안전하게 거래 연습",
                "pros": [
                    "실제 돈 손실 위험 없음",
                    "모든 플랫폼에서 실행 가능",
                    "무제한 테스트 가능",
                    "전략 개발 및 검증에 최적"
                ],
                "cons": [
                    "실제 수익 불가능",
                    "시뮬레이션 데이터 사용",
                    "실제 시장과 미세한 차이 가능"
                ],
                "recommended_for": [
                    "퀀트 트레이딩 초보자",
                    "새로운 전략 테스트",
                    "시스템 안정성 확인",
                    "교육 목적"
                ]
            },
            "REAL": {
                "name": "실거래 모드",
                "description": "실제 돈으로 진짜 거래 실행",
                "pros": [
                    "실제 수익 가능",
                    "진짜 시장 데이터 사용",
                    "완전한 거래 경험"
                ],
                "cons": [
                    "투자 손실 위험",
                    "Windows 환경 필수",
                    "키움증권 계좌 필요",
                    "시스템 오류 시 실제 손실 가능"
                ],
                "recommended_for": [
                    "충분한 경험자",
                    "모의투자 검증 완료자",
                    "소액 투자 가능자",
                    "실시간 모니터링 가능자"
                ],
                "requirements": [
                    "Windows 10 이상",
                    "키움증권 계좌",
                    "키움 Open API+ 설치",
                    "Python 3.9+",
                    "안정적인 인터넷 연결"
                ]
            }
        },
        "transition_guide": {
            "step1": "모의투자로 최소 1개월 테스트",
            "step2": "모든 전략의 수익성 검증",
            "step3": "리스크 관리 설정 최적화",
            "step4": "Windows 환경 및 키움 API 설치",
            "step5": "실거래 환경변수 설정",
            "step6": "소액(5-10만원)으로 실거래 시작",
            "step7": "안정성 확인 후 점진적 증액"
        },
        "safety_tips": [
            "항상 손절선을 설정하세요",
            "일일 손실 한도를 설정하세요",
            "투자 가능한 돈으로만 거래하세요",
            "시스템을 실시간 모니터링하세요",
            "정기적으로 백업을 생성하세요",
            "네트워크 연결 상태를 확인하세요",
            "긴급상황 시 수동 개입 방법을 숙지하세요"
        ]
    }

def get_current_trading_mode():
    """현재 거래 모드 반환"""
    return CURRENT_TRADING_MODE

def get_current_kiwoom_client():
    """현재 키움 클라이언트 반환"""
    return KIWOOM_CLIENT_INSTANCE

# 의존성 주입용 함수들
def get_trading_mode():
    """거래 모드 의존성"""
    return CURRENT_TRADING_MODE

def get_kiwoom_client():
    """키움 클라이언트 의존성"""
    if KIWOOM_CLIENT_INSTANCE is None:
        raise HTTPException(status_code=503, detail="키움 클라이언트가 초기화되지 않았습니다")
    return KIWOOM_CLIENT_INSTANCE


==================================================
File: C:\Aproject\test\quant_actual\backend\api.py
==================================================
# file: backend/api.py

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime, timedelta
import json
import logging

from database import get_db, DatabaseManager
from models import *
from trading_engine_manager import get_trading_engine

logger = logging.getLogger(__name__)
router = APIRouter()

# 포트폴리오 API
@router.get("/portfolio", response_model=PortfolioResponse)
async def get_portfolio_status(db: Session = Depends(get_db)):
    """포트폴리오 현황 조회"""
    try:
        # 최신 포트폴리오 정보 조회
        portfolio = db.query(Portfolio).order_by(Portfolio.timestamp.desc()).first()
        
        if not portfolio:
            # 포트폴리오가 없으면 기본값 생성
            portfolio = Portfolio(
                total_value=50000000.0,
                cash=24000000.0,
                invested_amount=26000000.0,
                realized_pnl=0.0,
                unrealized_pnl=0.0,
                daily_pnl=0.0,
                total_return=0.0
            )
            db.add(portfolio)
            db.commit()
            db.refresh(portfolio)
        
        return portfolio
    except Exception as e:
        logger.error(f"포트폴리오 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch portfolio")

@router.get("/portfolio/positions", response_model=List[PositionResponse])
async def get_current_positions(db: Session = Depends(get_db)):
    """현재 포지션 조회"""
    try:
        positions = db.query(Position)\
            .join(Strategy)\
            .join(Stock)\
            .filter(Position.quantity > 0)\
            .all()
        
        return [
            PositionResponse(
                id=pos.id,
                strategy_name=pos.strategy.name,
                stock_code=pos.stock.code,
                stock_name=pos.stock.name,
                quantity=pos.quantity,
                avg_price=pos.avg_price,
                current_price=pos.current_price or pos.avg_price,
                unrealized_pnl=pos.unrealized_pnl,
                realized_pnl=pos.realized_pnl
            )
            for pos in positions
        ]
    except Exception as e:
        logger.error(f"포지션 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch positions")

# 전략 관리 API
@router.get("/strategies", response_model=List[StrategyResponse])
async def get_strategies(db: Session = Depends(get_db)):
    """전략 목록 조회"""
    try:
        strategies = db.query(Strategy).all()
        return strategies
    except Exception as e:
        logger.error(f"전략 목록 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch strategies")

@router.post("/strategies", response_model=StrategyResponse)
async def create_strategy(strategy: StrategyCreate, db: Session = Depends(get_db)):
    """새 전략 생성"""
    try:
        db_strategy = Strategy(
            name=strategy.name,
            strategy_type=strategy.strategy_type,
            is_active=strategy.is_active,
            investment_amount=strategy.investment_amount,
            target_stocks=json.dumps(strategy.target_stocks),
            parameters=json.dumps(strategy.parameters)
        )
        db.add(db_strategy)
        db.commit()
        db.refresh(db_strategy)
        
        logger.info(f"새 전략 생성: {strategy.name}")
        return db_strategy
    except Exception as e:
        logger.error(f"전략 생성 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to create strategy")

@router.patch("/strategies/{strategy_id}", response_model=StrategyResponse)
async def update_strategy(
    strategy_id: int, 
    strategy_update: StrategyUpdate, 
    db: Session = Depends(get_db)
):
    """전략 정보 업데이트"""
    try:
        db_strategy = db.query(Strategy).filter(Strategy.id == strategy_id).first()
        if not db_strategy:
            raise HTTPException(status_code=404, detail="Strategy not found")
        
        # 업데이트할 필드들만 변경
        update_data = strategy_update.dict(exclude_unset=True)
        
        if 'target_stocks' in update_data:
            update_data['target_stocks'] = json.dumps(update_data['target_stocks'])
        if 'parameters' in update_data:
            update_data['parameters'] = json.dumps(update_data['parameters'])
        
        for field, value in update_data.items():
            setattr(db_strategy, field, value)
        
        db_strategy.updated_at = datetime.utcnow()
        db.commit()
        db.refresh(db_strategy)
        
        logger.info(f"전략 업데이트: {db_strategy.name}")
        return db_strategy
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"전략 업데이트 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to update strategy")

@router.post("/strategies/toggle")
async def toggle_strategy(
    request: dict, 
    db: Session = Depends(get_db),
    background_tasks: BackgroundTasks = BackgroundTasks()
):
    """전략 활성화/비활성화"""
    try:
        strategy_id = request.get("id")
        new_active_state = request.get("active", False)
        
        db_strategy = db.query(Strategy).filter(Strategy.id == strategy_id).first()
        if not db_strategy:
            raise HTTPException(status_code=404, detail="Strategy not found")
        
        db_strategy.is_active = new_active_state
        db_strategy.updated_at = datetime.utcnow()
        db.commit()
        
        # 트레이딩 엔진에 전략 변경 알림 (백그라운드 작업)
        trading_engine = get_trading_engine()
        if new_active_state:
            background_tasks.add_task(trading_engine.activate_strategy, strategy_id)
        else:
            background_tasks.add_task(trading_engine.deactivate_strategy, strategy_id)
        
        status = "활성화" if new_active_state else "비활성화"
        logger.info(f"전략 {status}: {db_strategy.name}")
        
        return {
            "success": True,
            "message": f"전략이 {status}되었습니다.",
            "strategy_id": strategy_id,
            "is_active": new_active_state
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"전략 토글 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to toggle strategy")

# 주문 관리 API
@router.get("/orders", response_model=List[OrderResponse])
async def get_recent_orders(
    limit: int = 50, 
    status: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """최근 주문 내역 조회"""
    try:
        query = db.query(Order)\
            .join(Stock)\
            .join(Strategy)\
            .order_by(Order.order_time.desc())
        
        if status:
            query = query.filter(Order.status == status)
        
        orders = query.limit(limit).all()
        
        return [
            OrderResponse(
                id=order.id,
                strategy_id=order.strategy_id,
                stock_code=order.stock.code,
                stock_name=order.stock.name,
                order_type=order.order_type,
                quantity=order.quantity,
                price=order.price,
                status=order.status,
                order_time=order.order_time,
                fill_time=order.fill_time,
                fill_price=order.fill_price,
                fill_quantity=order.fill_quantity
            )
            for order in orders
        ]
    except Exception as e:
        logger.error(f"주문 내역 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch orders")

@router.post("/orders")
async def create_manual_order(
    order: OrderCreate,
    db: Session = Depends(get_db)
):
    """수동 주문 생성"""
    try:
        # 주식 정보 조회
        stock = db.query(Stock).filter(Stock.code == order.stock_code).first()
        if not stock:
            raise HTTPException(status_code=404, detail="Stock not found")
        
        # 전략 조회
        strategy = db.query(Strategy).filter(Strategy.id == order.strategy_id).first()
        if not strategy:
            raise HTTPException(status_code=404, detail="Strategy not found")
        
        # 주문 생성
        db_order = Order(
            strategy_id=order.strategy_id,
            stock_id=stock.id,
            order_type=order.order_type,
            quantity=order.quantity,
            price=order.price,
            status="pending"
        )
        db.add(db_order)
        db.commit()
        db.refresh(db_order)
        
        # 트레이딩 엔진에 주문 실행 요청
        trading_engine = get_trading_engine()
        await trading_engine.execute_manual_order(db_order.id)
        
        logger.info(f"수동 주문 생성: {stock.name} {order.order_type} {order.quantity}주")
        return {"success": True, "order_id": db_order.id, "message": "주문이 생성되었습니다."}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"수동 주문 생성 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to create order")

# 트레이딩 제어 API
@router.post("/trading/start")
async def start_trading():
    """자동매매 시작"""
    try:
        trading_engine = get_trading_engine()
        await trading_engine.start_trading()
        
        logger.info("자동매매 시작됨")
        return {"success": True, "message": "자동매매가 시작되었습니다."}
        
    except Exception as e:
        logger.error(f"자동매매 시작 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to start trading")

@router.post("/trading/stop")
async def stop_trading():
    """자동매매 중지"""
    try:
        trading_engine = get_trading_engine()
        await trading_engine.stop_trading()
        
        logger.info("자동매매 중지됨")
        return {"success": True, "message": "자동매매가 중지되었습니다."}
        
    except Exception as e:
        logger.error(f"자동매매 중지 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to stop trading")

@router.post("/trading/emergency-stop")
async def emergency_stop():
    """긴급 중단"""
    try:
        trading_engine = get_trading_engine()
        await trading_engine.emergency_stop()
        
        logger.critical("긴급중단 실행됨")
        return {"success": True, "message": "긴급중단이 실행되었습니다."}
        
    except Exception as e:
        logger.error(f"긴급중단 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to emergency stop")

# 종목 정보 API
@router.get("/stocks", response_model=List[StockResponse])
async def get_stocks(db: Session = Depends(get_db)):
    """종목 목록 조회"""
    try:
        stocks = db.query(Stock).all()
        return stocks
    except Exception as e:
        logger.error(f"종목 목록 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch stocks")

@router.get("/stocks/{stock_code}")
async def get_stock_info(stock_code: str, db: Session = Depends(get_db)):
    """특정 종목 정보 조회"""
    try:
        stock = db.query(Stock).filter(Stock.code == stock_code).first()
        if not stock:
            raise HTTPException(status_code=404, detail="Stock not found")
        
        return stock
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"종목 정보 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch stock info")

@router.get("/stocks/{stock_code}/price-history")
async def get_price_history(
    stock_code: str, 
    days: int = 30, 
    db: Session = Depends(get_db)
):
    """종목 가격 히스토리 조회"""
    try:
        stock = db.query(Stock).filter(Stock.code == stock_code).first()
        if not stock:
            raise HTTPException(status_code=404, detail="Stock not found")
        
        start_date = datetime.utcnow() - timedelta(days=days)
        price_history = db.query(PriceHistory)\
            .filter(PriceHistory.stock_id == stock.id)\
            .filter(PriceHistory.timestamp >= start_date)\
            .order_by(PriceHistory.timestamp.desc())\
            .all()
        
        return [
            {
                "price": ph.price,
                "volume": ph.volume,
                "timestamp": ph.timestamp
            }
            for ph in price_history
        ]
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"가격 히스토리 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch price history")

# 백테스트 API
@router.post("/backtest/run", response_model=BacktestResponse)
async def run_backtest(
    backtest_request: BacktestRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """백테스트 실행"""
    try:
        # 백그라운드에서 백테스트 실행
        from trading.backtest import BacktestEngine
        
        backtest_engine = BacktestEngine()
        results = await backtest_engine.run_backtest(
            strategy_type=backtest_request.strategy_type,
            parameters=backtest_request.parameters,
            target_stocks=backtest_request.target_stocks,
            start_date=backtest_request.start_date,
            end_date=backtest_request.end_date,
            initial_capital=backtest_request.initial_capital
        )
        
        # 결과를 데이터베이스에 저장
        backtest_result = BacktestResult(
            strategy_name=backtest_request.strategy_type,
            start_date=backtest_request.start_date,
            end_date=backtest_request.end_date,
            total_return=results['total_return'],
            annual_return=results['annual_return'],
            max_drawdown=results['max_drawdown'],
            sharpe_ratio=results['sharpe_ratio'],
            win_rate=results['win_rate'],
            total_trades=results['total_trades'],
            results_data=json.dumps(results)
        )
        db.add(backtest_result)
        db.commit()
        
        logger.info(f"백테스트 완료: {backtest_request.strategy_type}")
        return BacktestResponse(**results)
        
    except Exception as e:
        logger.error(f"백테스트 실행 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to run backtest")

@router.get("/backtest/history")
async def get_backtest_history(
    limit: int = 10,
    db: Session = Depends(get_db)
):
    """백테스트 히스토리 조회"""
    try:
        results = db.query(BacktestResult)\
            .order_by(BacktestResult.created_at.desc())\
            .limit(limit)\
            .all()
        
        return [
            {
                "id": result.id,
                "strategy_name": result.strategy_name,
                "start_date": result.start_date,
                "end_date": result.end_date,
                "total_return": result.total_return,
                "annual_return": result.annual_return,
                "max_drawdown": result.max_drawdown,
                "sharpe_ratio": result.sharpe_ratio,
                "win_rate": result.win_rate,
                "total_trades": result.total_trades,
                "created_at": result.created_at
            }
            for result in results
        ]
    except Exception as e:
        logger.error(f"백테스트 히스토리 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch backtest history")

# 실시간 데이터 API
@router.get("/realtime/market-data")
async def get_realtime_market_data():
    """실시간 시장 데이터 조회"""
    try:
        trading_engine = get_trading_engine()
        market_data = await trading_engine.get_market_data()
        
        return market_data
    except Exception as e:
        logger.error(f"실시간 데이터 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch market data")

@router.get("/realtime/signals")
async def get_recent_signals(limit: int = 20):
    """최근 트레이딩 신호 조회"""
    try:
        trading_engine = get_trading_engine()
        signals = await trading_engine.get_recent_signals(limit)
        
        return signals
    except Exception as e:
        logger.error(f"신호 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch signals")

# 리스크 관리 API
@router.get("/risk/metrics", response_model=RiskMetrics)
async def get_risk_metrics():
    """리스크 지표 조회"""
    try:
        trading_engine = get_trading_engine()
        risk_metrics = await trading_engine.get_risk_metrics()
        
        return risk_metrics
    except Exception as e:
        logger.error(f"리스크 지표 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch risk metrics")

@router.post("/risk/update-limits")
async def update_risk_limits(risk_limits: dict):
    """리스크 한도 업데이트"""
    try:
        trading_engine = get_trading_engine()
        await trading_engine.update_risk_limits(risk_limits)
        
        logger.info("리스크 한도 업데이트됨")
        return {"success": True, "message": "리스크 한도가 업데이트되었습니다."}
        
    except Exception as e:
        logger.error(f"리스크 한도 업데이트 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to update risk limits")

# 시스템 정보 API
@router.get("/system/status", response_model=SystemStatus)
async def get_system_status():
    """시스템 상태 조회"""
    try:
        trading_engine = get_trading_engine()
        
        return SystemStatus(
            is_running=trading_engine.is_running,
            api_connected=trading_engine.kiwoom_client.is_connected,
            active_strategies=len(trading_engine.get_active_strategies()),
            current_positions=len(trading_engine.get_current_positions()),
            total_orders_today=trading_engine.get_daily_order_count(),
            last_update=trading_engine.last_update
        )
    except Exception as e:
        logger.error(f"시스템 상태 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch system status")

@router.post("/system/backup")
async def create_backup():
    """데이터베이스 백업 생성"""
    try:
        from database import backup_database
        backup_path = backup_database()
        
        logger.info(f"백업 생성 완료: {backup_path}")
        return {
            "success": True,
            "message": "백업이 생성되었습니다.",
            "backup_path": str(backup_path)
        }
    except Exception as e:
        logger.error(f"백업 생성 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to create backup") 



==================================================
File: C:\Aproject\test\quant_actual\backend\database.py
==================================================
# file: backend/database.py

from sqlalchemy import create_engine, event
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.pool import StaticPool
import sqlite3
from contextlib import contextmanager
import logging
from pathlib import Path

from models import Base
from utils.config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

# 데이터베이스 파일 경로
DATABASE_DIR = Path("data")
DATABASE_DIR.mkdir(exist_ok=True)
DATABASE_URL = f"sqlite:///{DATABASE_DIR}/quantrade.db"

# SQLAlchemy 엔진 생성
engine = create_engine(
    DATABASE_URL,
    connect_args={
        "check_same_thread": False,
        "timeout": 30
    },
    poolclass=StaticPool,
    echo=settings.debug  # 개발 모드에서 SQL 쿼리 로그 출력
)

# 세션 팩토리
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# SQLite 최적화 설정
@event.listens_for(engine, "connect")
def set_sqlite_pragma(dbapi_connection, connection_record):
    """SQLite 연결 시 성능 최적화 설정"""
    if isinstance(dbapi_connection, sqlite3.Connection):
        cursor = dbapi_connection.cursor()
        
        # 성능 최적화 설정
        cursor.execute("PRAGMA journal_mode=WAL")  # Write-Ahead Logging
        cursor.execute("PRAGMA synchronous=NORMAL")  # 빠른 쓰기
        cursor.execute("PRAGMA cache_size=10000")  # 캐시 크기 증가
        cursor.execute("PRAGMA temp_store=MEMORY")  # 임시 데이터를 메모리에
        cursor.execute("PRAGMA mmap_size=268435456")  # 메모리 맵 크기 (256MB)
        
        # 외래키 제약조건 활성화
        cursor.execute("PRAGMA foreign_keys=ON")
        
        cursor.close()

def init_db():
    """데이터베이스 초기화 - 테이블 생성 및 초기 데이터 삽입"""
    try:
        # 모든 테이블 생성
        Base.metadata.create_all(bind=engine)
        logger.info("데이터베이스 테이블 생성 완료")
        
        # 초기 데이터 삽입
        create_initial_data()
        logger.info("초기 데이터 생성 완료")
        
    except Exception as e:
        logger.error(f"데이터베이스 초기화 실패: {e}")
        raise

def create_initial_data():
    """초기 데이터 생성"""
    from models import Strategy, Stock, Portfolio
    import json
    
    with get_db_session() as db:
        # 주요 종목 데이터 생성
        if not db.query(Stock).first():
            initial_stocks = [
                {"code": "005930", "name": "삼성전자", "market": "KOSPI"},
                {"code": "000660", "name": "SK하이닉스", "market": "KOSPI"},
                {"code": "035420", "name": "NAVER", "market": "KOSPI"},
                {"code": "035720", "name": "카카오", "market": "KOSPI"},
                {"code": "051910", "name": "LG화학", "market": "KOSPI"},
                {"code": "006400", "name": "삼성SDI", "market": "KOSPI"},
                {"code": "207940", "name": "삼성바이오로직스", "market": "KOSPI"},
                {"code": "373220", "name": "LG에너지솔루션", "market": "KOSPI"},
            ]
            
            for stock_data in initial_stocks:
                stock = Stock(**stock_data)
                db.add(stock)
        
        # 기본 전략 생성
        if not db.query(Strategy).first():
            strategies = [
                {
                    "name": "볼린저밴드 평균회귀",
                    "strategy_type": "bollinger_bands",
                    "is_active": True,
                    "investment_amount": 10000000.0,  # 1천만원
                    "target_stocks": json.dumps(["005930", "000660", "035420"]),
                    "parameters": json.dumps({
                        "period": 20,
                        "std_multiplier": 2.0,
                        "stop_loss": 0.05,
                        "take_profit": 0.03
                    })
                },
                {
                    "name": "RSI 역추세",
                    "strategy_type": "rsi_reversal",
                    "is_active": True,
                    "investment_amount": 8000000.0,  # 8백만원
                    "target_stocks": json.dumps(["035720", "051910"]),
                    "parameters": json.dumps({
                        "period": 14,
                        "oversold": 30,
                        "overbought": 70,
                        "stop_loss": 0.04
                    })
                },
                {
                    "name": "모멘텀 추세추종",
                    "strategy_type": "momentum",
                    "is_active": False,
                    "investment_amount": 5000000.0,  # 5백만원
                    "target_stocks": json.dumps(["006400", "207940"]),
                    "parameters": json.dumps({
                        "short_period": 12,
                        "long_period": 26,
                        "signal_period": 9
                    })
                },
                {
                    "name": "이동평균 골든크로스",
                    "strategy_type": "moving_average",
                    "is_active": False,
                    "investment_amount": 3000000.0,  # 3백만원
                    "target_stocks": json.dumps(["373220"]),
                    "parameters": json.dumps({
                        "short_ma": 5,
                        "long_ma": 20,
                        "volume_threshold": 1000000
                    })
                }
            ]
            
            for strategy_data in strategies:
                strategy = Strategy(**strategy_data)
                db.add(strategy)
        
        # 초기 포트폴리오 생성
        if not db.query(Portfolio).first():
            initial_portfolio = Portfolio(
                total_value=50000000.0,  # 5천만원
                cash=24000000.0,  # 현금 2천4백만원
                invested_amount=26000000.0,  # 투자금 2천6백만원
                realized_pnl=0.0,
                unrealized_pnl=0.0,
                daily_pnl=0.0,
                total_return=0.0
            )
            db.add(initial_portfolio)
        
        db.commit()

@contextmanager
def get_db_session():
    """데이터베이스 세션 컨텍스트 매니저"""
    db = SessionLocal()
    try:
        yield db
    except Exception as e:
        logger.error(f"데이터베이스 오류: {e}")
        db.rollback()
        raise
    finally:
        db.close()

def get_db():
    """FastAPI 의존성 주입용 데이터베이스 세션"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 데이터베이스 유틸리티 함수들
class DatabaseManager:
    """데이터베이스 관리 클래스"""
    
    @staticmethod
    def get_portfolio_summary():
        """포트폴리오 요약 정보 조회"""
        from models import Portfolio, Position, Stock
        
        with get_db_session() as db:
            # 최신 포트폴리오 정보
            portfolio = db.query(Portfolio).order_by(Portfolio.timestamp.desc()).first()
            
            # 현재 포지션 정보
            positions = db.query(Position)\
                .join(Stock)\
                .filter(Position.quantity > 0)\
                .all()
            
            return {
                "portfolio": portfolio,
                "positions": positions,
                "position_count": len(positions)
            }
    
    @staticmethod
    def get_active_strategies():
        """활성화된 전략 목록 조회"""
        from models import Strategy
        
        with get_db_session() as db:
            return db.query(Strategy).filter(Strategy.is_active == True).all()
    
    @staticmethod
    def get_recent_orders(limit: int = 50):
        """최근 주문 내역 조회"""
        from models import Order, Stock, Strategy
        
        with get_db_session() as db:
            return db.query(Order)\
                .join(Stock)\
                .join(Strategy)\
                .order_by(Order.order_time.desc())\
                .limit(limit)\
                .all()
    
    @staticmethod
    def update_portfolio(portfolio_data: dict):
        """포트폴리오 정보 업데이트"""
        from models import Portfolio
        
        with get_db_session() as db:
            portfolio = Portfolio(**portfolio_data)
            db.add(portfolio)
            db.commit()
            return portfolio
    
    @staticmethod
    def update_stock_price(stock_code: str, price: float, volume: int = 0):
        """종목 가격 업데이트"""
        from models import Stock, PriceHistory
        from datetime import datetime
        
        with get_db_session() as db:
            # 종목 현재가 업데이트
            stock = db.query(Stock).filter(Stock.code == stock_code).first()
            if stock:
                stock.current_price = price
                stock.volume = volume
                stock.updated_at = datetime.utcnow()
                
                # 가격 히스토리 저장
                price_history = PriceHistory(
                    stock_id=stock.id,
                    price=price,
                    volume=volume,
                    timestamp=datetime.utcnow()
                )
                db.add(price_history)
                db.commit()
    
    @staticmethod
    def cleanup_old_data(days: int = 30):
        """오래된 데이터 정리"""
        from models import PriceHistory, Portfolio
        from datetime import datetime, timedelta
        
        cutoff_date = datetime.utcnow() - timedelta(days=days)
        
        with get_db_session() as db:
            # 오래된 가격 히스토리 삭제 (최근 30일만 보관)
            db.query(PriceHistory)\
                .filter(PriceHistory.timestamp < cutoff_date)\
                .delete()
            
            # 오래된 포트폴리오 스냅샷 삭제 (최근 30일만 보관)
            db.query(Portfolio)\
                .filter(Portfolio.timestamp < cutoff_date)\
                .delete()
            
            db.commit()
            logger.info(f"{days}일 이전 데이터 정리 완료")

def backup_database(backup_path: str = None):
    """데이터베이스 백업"""
    from shutil import copy2
    from datetime import datetime
    
    if not backup_path:
        backup_dir = Path("backups")
        backup_dir.mkdir(exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = backup_dir / f"quantrade_backup_{timestamp}.db"
    
    try:
        copy2(DATABASE_DIR / "quantrade.db", backup_path)
        logger.info(f"데이터베이스 백업 완료: {backup_path}")
        return backup_path
    except Exception as e:
        logger.error(f"데이터베이스 백업 실패: {e}")
        raise

# 데이터베이스 상태 체크
def check_database_health():
    """데이터베이스 상태 체크"""
    try:
        with get_db_session() as db:
            # 간단한 쿼리로 연결 테스트
            db.execute("SELECT 1")
            return True
    except Exception as e:
        logger.error(f"데이터베이스 연결 실패: {e}")
        return False



==================================================
File: C:\Aproject\test\quant_actual\backend\main.py
==================================================
# file: backend/main.py

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import asyncio
import uvicorn
from datetime import datetime
import logging
import os

from database import init_db
from api import router
from trading_mode_api import router as mode_router, get_current_trading_mode, get_current_kiwoom_client
from trading.engine import TradingEngine
from utils.logger import setup_logger
from utils.config import get_settings

# 로깅 설정
logger = setup_logger()
settings = get_settings()

# 전역 변수
trading_engine = None
background_task = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    """앱 시작/종료 시 실행될 로직"""
    global trading_engine, background_task
    
    logger.info("퀀트 트레이딩 시스템 시작 중...")
    
    # 데이터베이스 초기화
    init_db()
    
    # 초기 거래 모드 설정 (환경변수 또는 기본값)
    initial_mode = os.getenv("INITIAL_TRADING_MODE", "DEMO")
    logger.info(f"초기 거래 모드: {initial_mode}")
    
    # 키움 클라이언트 초기화 (모드에 따라)
    kiwoom_client = None
    if initial_mode == "REAL":
        try:
            # Windows 환경 체크
            import platform
            if platform.system() != "Windows":
                logger.warning("실거래 모드는 Windows에서만 지원됩니다. Demo 모드로 전환합니다.")
                initial_mode = "DEMO"
            else:
                from data.kiwoom_real import KiwoomRealClient
                kiwoom_client = KiwoomRealClient()
                if not await kiwoom_client.initialize():
                    logger.error("실거래 클라이언트 초기화 실패. Demo 모드로 전환합니다.")
                    initial_mode = "DEMO"
                    kiwoom_client = None
        except Exception as e:
            logger.error(f"실거래 클라이언트 초기화 오류: {e}. Demo 모드로 전환합니다.")
            initial_mode = "DEMO"
            kiwoom_client = None
    
    # Demo 모드 클라이언트 초기화
    if initial_mode == "DEMO" or kiwoom_client is None:
        from data.kiwoom_mock import KiwoomClient
        kiwoom_client = KiwoomClient()
        await kiwoom_client.connect()
    
    # 거래 모드 API에 클라이언트 설정
    from trading_mode_api import CURRENT_TRADING_MODE, KIWOOM_CLIENT_INSTANCE
    global CURRENT_TRADING_MODE, KIWOOM_CLIENT_INSTANCE
    CURRENT_TRADING_MODE = initial_mode
    KIWOOM_CLIENT_INSTANCE = kiwoom_client
    
    # 트레이딩 엔진 초기화 (현재 클라이언트 사용)
    trading_engine = TradingEngine()
    trading_engine.kiwoom_client = kiwoom_client
    await trading_engine.initialize()
    
    # 백그라운드 트레이딩 루프 시작
    background_task = asyncio.create_task(trading_engine.run())
    
    logger.info(f"시스템 초기화 완료 - 모드: {initial_mode}")
    
    yield
    
    # 시스템 종료 시 정리
    logger.info("시스템 종료 중...")
    if background_task:
        background_task.cancel()
    if trading_engine:
        await trading_engine.shutdown()
    if kiwoom_client:
        await kiwoom_client.disconnect()
    logger.info("시스템 종료 완료")

# FastAPI 앱 생성
app = FastAPI(
    title="QuanTrade Pro API",
    description="퀀트 자동매매 시스템 API - Mock/Real 모드 지원",
    version="1.1.0",
    lifespan=lifespan
)

# CORS 설정
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Next.js 개발 서버
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# API 라우터 등록
app.include_router(router, prefix="/api")
app.include_router(mode_router, prefix="/api")  # 거래 모드 API 추가

@app.get("/")
async def root():
    """기본 엔드포인트"""
    current_mode = get_current_trading_mode()
    return {
        "message": "QuanTrade Pro API",
        "version": "1.1.0",
        "status": "running",
        "trading_mode": current_mode,
        "timestamp": datetime.now().isoformat()
    }

@app.get("/health")
async def health_check():
    """헬스 체크 엔드포인트"""
    global trading_engine
    
    try:
        engine_status = "running" if trading_engine and trading_engine.is_running else "stopped"
        current_mode = get_current_trading_mode()
        kiwoom_client = get_current_kiwoom_client()
        api_connected = kiwoom_client.is_connected if kiwoom_client else False
        
        return {
            "status": "healthy",
            "trading_engine": engine_status,
            "trading_mode": current_mode,
            "api_connection": api_connected,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        logger.error(f"헬스 체크 실패: {e}")
        raise HTTPException(status_code=500, detail="System health check failed")

@app.get("/trading/status")
async def get_trading_status():
    """트레이딩 시스템 상태 조회"""
    global trading_engine
    
    if not trading_engine:
        raise HTTPException(status_code=503, detail="Trading engine not initialized")
    
    current_mode = get_current_trading_mode()
    kiwoom_client = get_current_kiwoom_client()
    
    return {
        "is_running": trading_engine.is_running,
        "trading_mode": current_mode,
        "api_connected": kiwoom_client.is_connected if kiwoom_client else False,
        "active_strategies": len(trading_engine.get_active_strategies()),
        "current_positions": len(trading_engine.get_current_positions()),
        "total_orders_today": trading_engine.get_daily_order_count(),
        "last_update": trading_engine.last_update.isoformat() if trading_engine.last_update else None
    }

@app.post("/trading/change-mode")
async def change_trading_mode_endpoint(request: dict):
    """거래 모드 변경 (레거시 지원)"""
    # trading_mode_api.py의 엔드포인트로 리다이렉트
    from trading_mode_api import change_trading_mode, TradingModeRequest
    
    mode_request = TradingModeRequest(mode=request.get("mode", "DEMO"))
    return await change_trading_mode(mode_request)

def get_trading_engine():
    """트레이딩 엔진 인스턴스 반환"""
    global trading_engine
    if not trading_engine:
        raise HTTPException(status_code=503, detail="Trading engine not available")
    return trading_engine

# 개발용 편의 엔드포인트
@app.get("/dev/info")
async def development_info():
    """개발 정보 (개발 환경에서만)"""
    if not settings.debug:
        raise HTTPException(status_code=404, detail="Not found")
    
    import platform
    import sys
    
    current_mode = get_current_trading_mode()
    kiwoom_client = get_current_kiwoom_client()
    
    return {
        "system": {
            "os": platform.system(),
            "python_version": sys.version,
            "trading_mode": current_mode
        },
        "client": {
            "type": type(kiwoom_client).__name__ if kiwoom_client else None,
            "connected": kiwoom_client.is_connected if kiwoom_client else False
        },
        "engine": {
            "running": trading_engine.is_running if trading_engine else False,
            "strategies": len(trading_engine.get_active_strategies()) if trading_engine else 0
        }
    }

if __name__ == "__main__":
    # 환경변수에서 설정 로드
    host = os.getenv("HOST", "0.0.0.0")
    port = int(os.getenv("PORT", "8000"))
    reload = os.getenv("RELOAD", "True").lower() == "true"
    
    logger.info(f"서버 시작: http://{host}:{port}")
    logger.info(f"API 문서: http://{host}:{port}/docs")
    
    uvicorn.run(
        "main:app",
        host=host,
        port=port,
        reload=reload,
        log_level="info"
    )




    


==================================================
File: C:\Aproject\test\quant_actual\backend\models.py
==================================================
# file: backend/models.py

from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean, Text, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, validator
from enum import Enum

Base = declarative_base()

# Enum 정의
class OrderStatus(str, Enum):
    PENDING = "pending"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"

class OrderType(str, Enum):
    BUY = "buy"
    SELL = "sell"

class StrategyType(str, Enum):
    BOLLINGER_BANDS = "bollinger_bands"
    RSI_REVERSAL = "rsi_reversal"
    MOMENTUM = "momentum"
    MOVING_AVERAGE = "moving_average"

# SQLAlchemy 모델 (데이터베이스 테이블)
class Strategy(Base):
    __tablename__ = "strategies"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, index=True)
    strategy_type = Column(String)
    is_active = Column(Boolean, default=False)
    investment_amount = Column(Float)
    target_stocks = Column(Text)  # JSON 문자열로 저장
    parameters = Column(Text)  # JSON 문자열로 저장
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # 관계 설정
    orders = relationship("Order", back_populates="strategy")
    positions = relationship("Position", back_populates="strategy")

class Stock(Base):
    __tablename__ = "stocks"
    
    id = Column(Integer, primary_key=True, index=True)
    code = Column(String, unique=True, index=True)  # 종목코드 (예: 005930)
    name = Column(String)  # 종목명 (예: 삼성전자)
    market = Column(String)  # 시장구분 (KOSPI, KOSDAQ)
    current_price = Column(Float)
    prev_close = Column(Float)
    volume = Column(Integer)
    market_cap = Column(Float)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # 관계 설정
    orders = relationship("Order", back_populates="stock")
    positions = relationship("Position", back_populates="stock")
    price_history = relationship("PriceHistory", back_populates="stock")

class Order(Base):
    __tablename__ = "orders"
    
    id = Column(Integer, primary_key=True, index=True)
    strategy_id = Column(Integer, ForeignKey("strategies.id"))
    stock_id = Column(Integer, ForeignKey("stocks.id"))
    order_type = Column(String)  # buy, sell
    quantity = Column(Integer)
    price = Column(Float)
    status = Column(String, default="pending")
    order_time = Column(DateTime, default=datetime.utcnow)
    fill_time = Column(DateTime)
    fill_price = Column(Float)
    fill_quantity = Column(Integer)
    commission = Column(Float, default=0.0)
    kiwoom_order_id = Column(String)  # 키움 API 주문번호
    
    # 관계 설정
    strategy = relationship("Strategy", back_populates="orders")
    stock = relationship("Stock", back_populates="orders")

class Position(Base):
    __tablename__ = "positions"
    
    id = Column(Integer, primary_key=True, index=True)
    strategy_id = Column(Integer, ForeignKey("strategies.id"))
    stock_id = Column(Integer, ForeignKey("stocks.id"))
    quantity = Column(Integer)
    avg_price = Column(Float)
    current_price = Column(Float)
    unrealized_pnl = Column(Float, default=0.0)
    realized_pnl = Column(Float, default=0.0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # 관계 설정
    strategy = relationship("Strategy", back_populates="positions")
    stock = relationship("Stock", back_populates="positions")

class Portfolio(Base):
    __tablename__ = "portfolio"
    
    id = Column(Integer, primary_key=True, index=True)
    total_value = Column(Float)
    cash = Column(Float)
    invested_amount = Column(Float)
    realized_pnl = Column(Float, default=0.0)
    unrealized_pnl = Column(Float, default=0.0)
    daily_pnl = Column(Float, default=0.0)
    total_return = Column(Float, default=0.0)
    timestamp = Column(DateTime, default=datetime.utcnow)

class PriceHistory(Base):
    __tablename__ = "price_history"
    
    id = Column(Integer, primary_key=True, index=True)
    stock_id = Column(Integer, ForeignKey("stocks.id"))
    price = Column(Float)
    volume = Column(Integer)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    
    # 관계 설정
    stock = relationship("Stock", back_populates="price_history")

class BacktestResult(Base):
    __tablename__ = "backtest_results"
    
    id = Column(Integer, primary_key=True, index=True)
    strategy_name = Column(String)
    start_date = Column(DateTime)
    end_date = Column(DateTime)
    total_return = Column(Float)
    annual_return = Column(Float)
    max_drawdown = Column(Float)
    sharpe_ratio = Column(Float)
    win_rate = Column(Float)
    total_trades = Column(Integer)
    results_data = Column(Text)  # JSON으로 상세 결과 저장
    created_at = Column(DateTime, default=datetime.utcnow)

# Pydantic 모델 (API 요청/응답)
class StrategyBase(BaseModel):
    name: str
    strategy_type: StrategyType
    is_active: bool = False
    investment_amount: float
    target_stocks: list[str] = []
    parameters: dict = {}

class StrategyCreate(StrategyBase):
    pass

class StrategyUpdate(BaseModel):
    name: Optional[str] = None
    is_active: Optional[bool] = None
    investment_amount: Optional[float] = None
    target_stocks: Optional[list[str]] = None
    parameters: Optional[dict] = None

class StrategyResponse(StrategyBase):
    id: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class StockBase(BaseModel):
    code: str
    name: str
    market: str = "KOSPI"

class StockResponse(StockBase):
    id: int
    current_price: Optional[float] = None
    prev_close: Optional[float] = None
    volume: Optional[int] = None
    updated_at: datetime
    
    class Config:
        from_attributes = True

class OrderBase(BaseModel):
    strategy_id: int
    stock_code: str
    order_type: OrderType
    quantity: int
    price: float

class OrderCreate(OrderBase):
    pass

class OrderResponse(BaseModel):
    id: int
    strategy_id: int
    stock_code: str
    stock_name: str
    order_type: str
    quantity: int
    price: float
    status: str
    order_time: datetime
    fill_time: Optional[datetime] = None
    fill_price: Optional[float] = None
    fill_quantity: Optional[int] = None
    
    class Config:
        from_attributes = True

class PositionResponse(BaseModel):
    id: int
    strategy_name: str
    stock_code: str
    stock_name: str
    quantity: int
    avg_price: float
    current_price: float
    unrealized_pnl: float
    realized_pnl: float
    
    class Config:
        from_attributes = True

class PortfolioResponse(BaseModel):
    total_value: float
    cash: float
    invested_amount: float
    realized_pnl: float
    unrealized_pnl: float
    daily_pnl: float
    total_return: float
    timestamp: datetime
    
    class Config:
        from_attributes = True

class TradingSignal(BaseModel):
    stock_code: str
    strategy_name: str
    signal_type: OrderType
    quantity: int
    price: float
    confidence: float
    timestamp: datetime = datetime.now()

class BacktestRequest(BaseModel):
    strategy_type: StrategyType
    parameters: dict
    target_stocks: list[str]
    start_date: datetime
    end_date: datetime
    initial_capital: float = 10000000  # 1천만원

class BacktestResponse(BaseModel):
    total_return: float
    annual_return: float
    max_drawdown: float
    sharpe_ratio: float
    win_rate: float
    total_trades: int
    strategy_performance: dict
    
    @validator('total_return', 'annual_return', 'max_drawdown', 'sharpe_ratio', 'win_rate')
    def round_percentages(cls, v):
        return round(v, 2)

class RiskMetrics(BaseModel):
    daily_loss_limit: float = -0.02  # -2%
    position_size_limit: float = 0.05  # 5%
    max_positions: int = 10
    current_daily_loss: float = 0.0
    is_safe_to_trade: bool = True

class MarketDataResponse(BaseModel):
    stock_code: str
    price: float
    volume: int
    timestamp: datetime
    
class SystemStatus(BaseModel):
    is_running: bool
    api_connected: bool
    active_strategies: int
    current_positions: int
    total_orders_today: int
    last_update: Optional[datetime] = None



==================================================
File: C:\Aproject\test\quant_actual\backend\run.py
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\backend\trading_engine_manager.py
==================================================
# file: backend/trading_engine_manager.py

from trading.engine import TradingEngine

# 전역 트레이딩 엔진 인스턴스
_trading_engine = None

def get_trading_engine():
    """전역 트레이딩 엔진 인스턴스 반환"""
    global _trading_engine
    if _trading_engine is None:
        raise RuntimeError("트레이딩 엔진이 초기화되지 않았습니다")
    return _trading_engine

def set_trading_engine(engine: TradingEngine):
    """전역 트레이딩 엔진 인스턴스 설정"""
    global _trading_engine
    _trading_engine = engine



==================================================
File: C:\Aproject\test\quant_actual\backend\trading_mode_api.py
==================================================
"""
file: trading_mode_api.py
거래 모드 전환 API
Mock ↔ Real 모드 전환을 위한 엔드포인트
"""

import os
import platform
import logging
from typing import Dict, Any
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel

from utils.config import get_settings
from database import get_db_session

logger = logging.getLogger(__name__)

# 전역 변수로 현재 모드 저장
CURRENT_TRADING_MODE = "DEMO"  # DEMO or REAL
KIWOOM_CLIENT_INSTANCE = None

class TradingModeRequest(BaseModel):
    mode: str  # "DEMO" or "REAL"

class SystemStatusResponse(BaseModel):
    current_mode: str
    is_windows: bool
    kiwoom_api_available: bool
    account_connected: bool
    account_info: Dict[str, Any] = None

router = APIRouter()

def check_windows_environment() -> bool:
    """Windows 환경 체크"""
    return platform.system() == "Windows"

def check_kiwoom_api_available() -> bool:
    """키움 API 사용 가능성 체크"""
    if not check_windows_environment():
        return False
    
    try:
        # PyQt5와 pythoncom 모듈 체크
        import PyQt5
        import pythoncom
        
        # 키움 API 파일 존재 체크 (일반적인 설치 경로)
        kiwoom_paths = [
            "C:\\OpenAPI\\",
            "C:\\Program Files\\OpenAPI\\",
            "C:\\Program Files (x86)\\OpenAPI\\"
        ]
        
        for path in kiwoom_paths:
            if os.path.exists(path):
                return True
        
        # 레지스트리에서 키움 API 확인 (선택적)
        try:
            import winreg
            key = winreg.OpenKey(winreg.HKEY_CLASSES_ROOT, "KHOPENAPI.KHOpenAPICtrl.1")
            winreg.CloseKey(key)
            return True
        except:
            pass
        
        return False
        
    except ImportError:
        return False

async def get_account_info():
    """계좌 정보 조회"""
    global KIWOOM_CLIENT_INSTANCE
    
    if CURRENT_TRADING_MODE == "REAL" and KIWOOM_CLIENT_INSTANCE:
        try:
            account_info = await KIWOOM_CLIENT_INSTANCE.get_account_info()
            return account_info
        except Exception as e:
            logger.error(f"실거래 계좌 정보 조회 실패: {e}")
            return None
    else:
        # Mock 모드 계좌 정보
        return {
            "account_number": "8012345-01",
            "server_type": "DEMO",
            "available_cash": 50000000,
            "total_cash": 50000000
        }

@router.get("/system/trading-mode", response_model=SystemStatusResponse)
async def get_trading_mode_status():
    """현재 거래 모드 상태 조회"""
    try:
        is_windows = check_windows_environment()
        kiwoom_available = check_kiwoom_api_available()
        
        # 계좌 연결 상태 체크
        account_connected = False
        account_info = None
        
        if CURRENT_TRADING_MODE == "REAL" and KIWOOM_CLIENT_INSTANCE:
            account_connected = KIWOOM_CLIENT_INSTANCE.is_connected
            if account_connected:
                account_info = await get_account_info()
        elif CURRENT_TRADING_MODE == "DEMO":
            account_connected = True  # Mock 모드에서는 항상 연결됨
            account_info = await get_account_info()
        
        return SystemStatusResponse(
            current_mode=CURRENT_TRADING_MODE,
            is_windows=is_windows,
            kiwoom_api_available=kiwoom_available,
            account_connected=account_connected,
            account_info=account_info
        )
        
    except Exception as e:
        logger.error(f"거래 모드 상태 조회 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to get trading mode status")

@router.post("/system/change-trading-mode")
async def change_trading_mode(request: TradingModeRequest):
    """거래 모드 변경"""
    global CURRENT_TRADING_MODE, KIWOOM_CLIENT_INSTANCE
    
    try:
        new_mode = request.mode.upper()
        
        if new_mode not in ["DEMO", "REAL"]:
            raise HTTPException(status_code=400, detail="Invalid trading mode")
        
        if new_mode == CURRENT_TRADING_MODE:
            return {"success": True, "message": f"이미 {new_mode} 모드입니다."}
        
        # 실거래 모드 전환 시 추가 검증
        if new_mode == "REAL":
            if not check_windows_environment():
                raise HTTPException(
                    status_code=400, 
                    detail="실거래 모드는 Windows 환경에서만 사용 가능합니다."
                )
            
            if not check_kiwoom_api_available():
                raise HTTPException(
                    status_code=400, 
                    detail="키움 Open API가 설치되지 않았습니다."
                )
            
            # 환경변수 체크
            if not os.getenv("KIWOOM_ACCOUNT"):
                raise HTTPException(
                    status_code=400, 
                    detail="KIWOOM_ACCOUNT 환경변수가 설정되지 않았습니다."
                )
            
            if not os.getenv("KIWOOM_PASSWORD"):
                raise HTTPException(
                    status_code=400, 
                    detail="KIWOOM_PASSWORD 환경변수가 설정되지 않았습니다."
                )
        
        # 기존 연결 해제
        if KIWOOM_CLIENT_INSTANCE:
            try:
                await KIWOOM_CLIENT_INSTANCE.disconnect()
            except:
                pass
            KIWOOM_CLIENT_INSTANCE = None
        
        # 새로운 모드로 전환
        if new_mode == "REAL":
            # 실거래 클라이언트 초기화
            from data.kiwoom_real import KiwoomRealClient
            KIWOOM_CLIENT_INSTANCE = KiwoomRealClient()
            
            # 연결 시도
            if not await KIWOOM_CLIENT_INSTANCE.initialize():
                raise HTTPException(status_code=500, detail="키움 API 초기화 실패")
            
            if not await KIWOOM_CLIENT_INSTANCE.connect():
                raise HTTPException(status_code=500, detail="키움 API 연결 실패")
            
            logger.warning("실거래 모드로 전환됨")
            
        else:  # DEMO 모드
            # Mock 클라이언트 초기화
            from data.kiwoom_mock import KiwoomClient
            KIWOOM_CLIENT_INSTANCE = KiwoomClient()
            await KIWOOM_CLIENT_INSTANCE.connect()
            
            logger.info("모의투자 모드로 전환됨")
        
        # 모드 변경
        CURRENT_TRADING_MODE = new_mode
        
        # 트레이딩 엔진에 새로운 클라이언트 적용
        from main import get_trading_engine
        trading_engine = get_trading_engine()
        trading_engine.kiwoom_client = KIWOOM_CLIENT_INSTANCE
        
        # 데이터베이스에 모드 변경 기록
        with get_db_session() as db:
            # 실제로는 SystemLog 테이블에 기록
            pass
        
        return {
            "success": True,
            "message": f"{new_mode} 모드로 변경되었습니다.",
            "mode": new_mode,
            "account_connected": KIWOOM_CLIENT_INSTANCE.is_connected if KIWOOM_CLIENT_INSTANCE else False
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"거래 모드 변경 실패: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to change trading mode: {str(e)}")

@router.get("/system/environment-check")
async def check_environment():
    """환경 체크 및 설치 가이드"""
    try:
        checks = {
            "operating_system": {
                "name": platform.system(),
                "version": platform.version(),
                "is_windows": check_windows_environment(),
                "status": "✅" if check_windows_environment() else "❌"
            },
            "python_version": {
                "version": platform.python_version(),
                "is_compatible": platform.python_version() >= "3.9",
                "status": "✅" if platform.python_version() >= "3.9" else "❌"
            },
            "required_packages": {},
            "kiwoom_api": {
                "available": check_kiwoom_api_available(),
                "status": "✅" if check_kiwoom_api_available() else "❌"
            },
            "environment_variables": {
                "kiwoom_account": bool(os.getenv("KIWOOM_ACCOUNT")),
                "kiwoom_password": bool(os.getenv("KIWOOM_PASSWORD")),
                "status": "✅" if (os.getenv("KIWOOM_ACCOUNT") and os.getenv("KIWOOM_PASSWORD")) else "❌"
            }
        }
        
        # Python 패키지 체크
        required_packages = ["PyQt5", "pythoncom", "fastapi", "sqlalchemy", "pandas", "numpy"]
        
        for package in required_packages:
            try:
                __import__(package.lower())
                checks["required_packages"][package] = {"installed": True, "status": "✅"}
            except ImportError:
                checks["required_packages"][package] = {"installed": False, "status": "❌"}
        
        # 전체 상태 판정
        overall_status = "READY" if all([
            checks["operating_system"]["is_windows"],
            checks["python_version"]["is_compatible"],
            all(pkg["installed"] for pkg in checks["required_packages"].values()),
            checks["kiwoom_api"]["available"]
        ]) else "NOT_READY"
        
        return {
            "overall_status": overall_status,
            "checks": checks,
            "recommendations": get_installation_recommendations(checks)
        }
        
    except Exception as e:
        logger.error(f"환경 체크 실패: {e}")
        raise HTTPException(status_code=500, detail="Failed to check environment")

def get_installation_recommendations(checks: Dict) -> list[str]:
    """설치 권장사항 생성"""
    recommendations = []
    
    if not checks["operating_system"]["is_windows"]:
        recommendations.append("실거래를 위해서는 Windows 환경이 필요합니다.")
    
    if not checks["python_version"]["is_compatible"]:
        recommendations.append("Python 3.9 이상으로 업그레이드가 필요합니다.")
    
    missing_packages = [
        pkg for pkg, info in checks["required_packages"].items() 
        if not info["installed"]
    ]
    
    if missing_packages:
        recommendations.append(f"다음 패키지 설치 필요: {', '.join(missing_packages)}")
        recommendations.append("pip install " + " ".join(missing_packages))
    
    if not checks["kiwoom_api"]["available"]:
        recommendations.extend([
            "키움 Open API+ 설치가 필요합니다:",
            "1. 키움증권 홈페이지 → 고객지원 → API",
            "2. Open API+ 다운로드 및 설치",
            "3. 시스템 재부팅 후 재시도"
        ])
    
    if not checks["environment_variables"]["kiwoom_account"]:
        recommendations.extend([
            "환경변수 설정이 필요합니다:",
            "KIWOOM_ACCOUNT=실제계좌번호",
            "KIWOOM_PASSWORD=실제비밀번호"
        ])
    
    if not recommendations:
        recommendations.append("모든 요구사항이 충족되었습니다. 실거래 준비 완료!")
    
    return recommendations

@router.post("/system/test-connection")
async def test_connection(request: TradingModeRequest):
    """연결 테스트"""
    try:
        mode = request.mode.upper()
        
        if mode == "DEMO":
            # Mock 연결 테스트
            from data.kiwoom_mock import KiwoomClient
            test_client = KiwoomClient()
            
            if await test_client.connect():
                await test_client.disconnect()
                return {
                    "success": True,
                    "message": "모의투자 연결 테스트 성공",
                    "details": {
                        "mode": "DEMO",
                        "connection_time": "< 1초",
                        "account": "모의계좌"
                    }
                }
            else:
                raise HTTPException(status_code=500, detail="모의투자 연결 실패")
        
        elif mode == "REAL":
            # 실거래 연결 테스트
            if not check_windows_environment():
                raise HTTPException(status_code=400, detail="Windows 환경이 아닙니다")
            
            if not check_kiwoom_api_available():
                raise HTTPException(status_code=400, detail="키움 API가 설치되지 않았습니다")
            
            from data.kiwoom_real import KiwoomRealClient
            test_client = KiwoomRealClient()
            
            if await test_client.initialize():
                if await test_client.connect():
                    account_info = await test_client.get_account_info()
                    await test_client.disconnect()
                    
                    return {
                        "success": True,
                        "message": "실거래 연결 테스트 성공",
                        "details": {
                            "mode": "REAL",
                            "account": account_info.get("account_number", "확인불가"),
                            "server_type": account_info.get("server_type", "REAL"),
                            "available_cash": account_info.get("available_cash", 0)
                        }
                    }
                else:
                    raise HTTPException(status_code=500, detail="키움 API 로그인 실패")
            else:
                raise HTTPException(status_code=500, detail="키움 API 초기화 실패")
        
        else:
            raise HTTPException(status_code=400, detail="잘못된 모드입니다")
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"연결 테스트 실패: {e}")
        raise HTTPException(status_code=500, detail=f"Connection test failed: {str(e)}")

@router.get("/system/trading-mode-guide")
async def get_trading_mode_guide():
    """거래 모드 가이드"""
    return {
        "modes": {
            "DEMO": {
                "name": "모의투자 모드",
                "description": "가상의 돈으로 안전하게 거래 연습",
                "pros": [
                    "실제 돈 손실 위험 없음",
                    "모든 플랫폼에서 실행 가능",
                    "무제한 테스트 가능",
                    "전략 개발 및 검증에 최적"
                ],
                "cons": [
                    "실제 수익 불가능",
                    "시뮬레이션 데이터 사용",
                    "실제 시장과 미세한 차이 가능"
                ],
                "recommended_for": [
                    "퀀트 트레이딩 초보자",
                    "새로운 전략 테스트",
                    "시스템 안정성 확인",
                    "교육 목적"
                ]
            },
            "REAL": {
                "name": "실거래 모드",
                "description": "실제 돈으로 진짜 거래 실행",
                "pros": [
                    "실제 수익 가능",
                    "진짜 시장 데이터 사용",
                    "완전한 거래 경험"
                ],
                "cons": [
                    "투자 손실 위험",
                    "Windows 환경 필수",
                    "키움증권 계좌 필요",
                    "시스템 오류 시 실제 손실 가능"
                ],
                "recommended_for": [
                    "충분한 경험자",
                    "모의투자 검증 완료자",
                    "소액 투자 가능자",
                    "실시간 모니터링 가능자"
                ],
                "requirements": [
                    "Windows 10 이상",
                    "키움증권 계좌",
                    "키움 Open API+ 설치",
                    "Python 3.9+",
                    "안정적인 인터넷 연결"
                ]
            }
        },
        "transition_guide": {
            "step1": "모의투자로 최소 1개월 테스트",
            "step2": "모든 전략의 수익성 검증",
            "step3": "리스크 관리 설정 최적화",
            "step4": "Windows 환경 및 키움 API 설치",
            "step5": "실거래 환경변수 설정",
            "step6": "소액(5-10만원)으로 실거래 시작",
            "step7": "안정성 확인 후 점진적 증액"
        },
        "safety_tips": [
            "항상 손절선을 설정하세요",
            "일일 손실 한도를 설정하세요",
            "투자 가능한 돈으로만 거래하세요",
            "시스템을 실시간 모니터링하세요",
            "정기적으로 백업을 생성하세요",
            "네트워크 연결 상태를 확인하세요",
            "긴급상황 시 수동 개입 방법을 숙지하세요"
        ]
    }

def get_current_trading_mode():
    """현재 거래 모드 반환"""
    return CURRENT_TRADING_MODE

def get_current_kiwoom_client():
    """현재 키움 클라이언트 반환"""
    return KIWOOM_CLIENT_INSTANCE

# 의존성 주입용 함수들
def get_trading_mode():
    """거래 모드 의존성"""
    return CURRENT_TRADING_MODE

def get_kiwoom_client():
    """키움 클라이언트 의존성"""
    if KIWOOM_CLIENT_INSTANCE is None:
        raise HTTPException(status_code=503, detail="키움 클라이언트가 초기화되지 않았습니다")
    return KIWOOM_CLIENT_INSTANCE


==================================================
File: C:\Aproject\test\quant_actual\backend\data\kiwoom_mock.py
==================================================
#file: backend/data/kiwoom_mock.py

import asyncio
import logging
import random
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
import json
import uuid

logger = logging.getLogger(__name__)

class KiwoomClient:
    """키움 Open API 모의 클라이언트"""
    
    def __init__(self):
        self.is_connected = False
        self.account_number = "8012345-01"
        self.server_type = "DEMO"  # DEMO or REAL
        
        # 모의 데이터
        self.mock_prices = {}
        self.mock_orders = {}
        self.order_counter = 1000
        
        # 초기 가격 설정
        self.initialize_mock_data()
        
        # 가격 변동 시뮬레이션 태스크
        self.price_update_task = None
    
    def initialize_mock_data(self):
        """모의 데이터 초기화"""
        # 주요 종목의 초기 가격 설정
        self.mock_prices = {
            '005930': {  # 삼성전자
                'current_price': 71200,
                'prev_close': 70800,
                'volume': 12450000,
                'high': 71800,
                'low': 70500,
                'market_cap': 425000000000000,
                'last_update': datetime.now()
            },
            '000660': {  # SK하이닉스
                'current_price': 124500,
                'prev_close': 123000,
                'volume': 8200000,
                'high': 125800,
                'low': 123200,
                'market_cap': 90000000000000,
                'last_update': datetime.now()
            },
            '035420': {  # NAVER
                'current_price': 198000,
                'prev_close': 195000,
                'volume': 1800000,
                'high': 199500,
                'low': 196000,
                'market_cap': 32000000000000,
                'last_update': datetime.now()
            },
            '035720': {  # 카카오
                'current_price': 89500,
                'prev_close': 87200,
                'volume': 3200000,
                'high': 90200,
                'low': 88100,
                'market_cap': 38000000000000,
                'last_update': datetime.now()
            },
            '051910': {  # LG화학
                'current_price': 486000,
                'prev_close': 482000,
                'volume': 450000,
                'high': 489000,
                'low': 483000,
                'market_cap': 34000000000000,
                'last_update': datetime.now()
            },
            '006400': {  # 삼성SDI
                'current_price': 425000,
                'prev_close': 420000,
                'volume': 380000,
                'high': 428000,
                'low': 422000,
                'market_cap': 28000000000000,
                'last_update': datetime.now()
            },
            '207940': {  # 삼성바이오로직스
                'current_price': 785000,
                'prev_close': 780000,
                'volume': 120000,
                'high': 790000,
                'low': 775000,
                'market_cap': 53000000000000,
                'last_update': datetime.now()
            },
            '373220': {  # LG에너지솔루션
                'current_price': 412000,
                'prev_close': 408000,
                'volume': 680000,
                'high': 415000,
                'low': 409000,
                'market_cap': 96000000000000,
                'last_update': datetime.now()
            }
        }
    
    async def connect(self):
        """키움 API 연결"""
        try:
            logger.info("키움 API 연결 시도 중...")
            
            # 연결 시뮬레이션 (2초 대기)
            await asyncio.sleep(2)
            
            self.is_connected = True
            
            # 실시간 가격 업데이트 시작
            self.price_update_task = asyncio.create_task(self.simulate_price_updates())
            
            logger.info("키움 API 연결 완료 (모의투자 모드)")
            return True
            
        except Exception as e:
            logger.error(f"키움 API 연결 실패: {e}")
            self.is_connected = False
            return False
    
    async def disconnect(self):
        """키움 API 연결 해제"""
        try:
            self.is_connected = False
            
            if self.price_update_task:
                self.price_update_task.cancel()
            
            logger.info("키움 API 연결 해제됨")
            
        except Exception as e:
            logger.error(f"키움 API 연결 해제 실패: {e}")
    
    async def simulate_price_updates(self):
        """실시간 가격 변동 시뮬레이션"""
        try:
            while self.is_connected:
                await asyncio.sleep(1)  # 1초마다 업데이트
                
                for stock_code in self.mock_prices:
                    await self.update_mock_price(stock_code)
                    
        except asyncio.CancelledError:
            logger.info("가격 업데이트 시뮬레이션 종료")
        except Exception as e:
            logger.error(f"가격 업데이트 시뮬레이션 오류: {e}")
    
    async def update_mock_price(self, stock_code: str):
        """개별 종목 가격 업데이트"""
        try:
            if stock_code not in self.mock_prices:
                return
            
            price_data = self.mock_prices[stock_code]
            current_price = price_data['current_price']
            
            # 가격 변동 시뮬레이션 (±2% 범위)
            change_rate = random.uniform(-0.02, 0.02)
            new_price = current_price * (1 + change_rate)
            
            # 일정 범위 내에서만 변동하도록 제한
            prev_close = price_data['prev_close']
            max_price = prev_close * 1.30  # 상한가 30%
            min_price = prev_close * 0.70  # 하한가 -30%
            
            new_price = max(min_price, min(max_price, new_price))
            
            # 가격 데이터 업데이트
            price_data['current_price'] = int(new_price)
            price_data['volume'] += random.randint(1000, 10000)
            price_data['high'] = max(price_data['high'], int(new_price))
            price_data['low'] = min(price_data['low'], int(new_price))
            price_data['last_update'] = datetime.now()
            
        except Exception as e:
            logger.error(f"가격 업데이트 오류 {stock_code}: {e}")
    
    async def get_current_price(self, stock_code: str) -> Dict[str, Any]:
        """현재 시세 조회"""
        try:
            if not self.is_connected:
                raise Exception("API 연결되지 않음")
            
            if stock_code not in self.mock_prices:
                # 새로운 종목인 경우 기본 데이터 생성
                self.mock_prices[stock_code] = {
                    'current_price': random.randint(50000, 500000),
                    'prev_close': random.randint(50000, 500000),
                    'volume': random.randint(100000, 5000000),
                    'high': 0,
                    'low': 999999999,
                    'market_cap': random.randint(1000000000000, 100000000000000),
                    'last_update': datetime.now()
                }
            
            price_data = self.mock_prices[stock_code].copy()
            
            # 추가 정보 계산
            price_change = price_data['current_price'] - price_data['prev_close']
            change_rate = (price_change / price_data['prev_close']) * 100
            
            price_data.update({
                'price_change': price_change,
                'change_rate': change_rate,
                'bid_price': price_data['current_price'] - 100,
                'ask_price': price_data['current_price'] + 100,
                'timestamp': datetime.now().isoformat()
            })
            
            return price_data
            
        except Exception as e:
            logger.error(f"시세 조회 오류 {stock_code}: {e}")
            return {
                'current_price': 100000,
                'prev_close': 100000,
                'volume': 0,
                'error': str(e)
            }
    
    async def send_order(self, stock_code: str, order_type: str, quantity: int, price: float) -> str:
        """주문 전송"""
        try:
            if not self.is_connected:
                raise Exception("API 연결되지 않음")
            
            # 주문 번호 생성
            order_id = f"ORD{self.order_counter:06d}"
            self.order_counter += 1
            
            # 주문 데이터 생성
            order_data = {
                'order_id': order_id,
                'stock_code': stock_code,
                'order_type': order_type.upper(),
                'quantity': quantity,
                'price': price,
                'status': 'pending',
                'order_time': datetime.now(),
                'fill_time': None,
                'fill_price': None,
                'fill_quantity': None,
                'remaining_quantity': quantity,
                'account_number': self.account_number
            }
            
            # 주문 저장
            self.mock_orders[order_id] = order_data
            
            # 주문 처리 시뮬레이션 시작
            asyncio.create_task(self.simulate_order_fill(order_id))
            
            logger.info(f"주문 전송 완료: {stock_code} {order_type} {quantity}주 @ {price}")
            return order_id
            
        except Exception as e:
            logger.error(f"주문 전송 실패: {e}")
            raise
    
    async def simulate_order_fill(self, order_id: str):
        """주문 체결 시뮬레이션"""
        try:
            await asyncio.sleep(random.uniform(1, 5))  # 1-5초 후 체결
            
            if order_id not in self.mock_orders:
                return
            
            order = self.mock_orders[order_id]
            
            # 체결 확률 (90%)
            if random.random() < 0.9:
                # 체결 처리
                stock_code = order['stock_code']
                current_market_price = self.mock_prices.get(stock_code, {}).get('current_price', order['price'])
                
                # 체결가 결정 (주문가 근처에서 체결)
                if order['order_type'] == 'BUY':
                    fill_price = min(order['price'], current_market_price + random.randint(-500, 500))
                else:  # SELL
                    fill_price = max(order['price'], current_market_price + random.randint(-500, 500))
                
                fill_quantity = order['quantity']  # 전량 체결
                
                # 주문 상태 업데이트
                order.update({
                    'status': 'filled',
                    'fill_time': datetime.now(),
                    'fill_price': fill_price,
                    'fill_quantity': fill_quantity,
                    'remaining_quantity': 0,
                    'commission': self.calculate_commission(fill_price * fill_quantity)
                })
                
                logger.info(f"주문 체결: {order_id} - {fill_quantity}주 @ {fill_price}")
                
            else:
                # 주문 취소 또는 거부
                order['status'] = random.choice(['cancelled', 'rejected'])
                logger.info(f"주문 {order['status']}: {order_id}")
                
        except Exception as e:
            logger.error(f"주문 체결 시뮬레이션 오류 {order_id}: {e}")
    
    def calculate_commission(self, trade_amount: float) -> float:
        """수수료 계산"""
        # 간단한 수수료 계산 (거래금액의 0.015%)
        commission_rate = 0.00015
        return trade_amount * commission_rate
    
    async def get_order_status(self, order_id: str) -> Dict[str, Any]:
        """주문 상태 조회"""
        try:
            if order_id not in self.mock_orders:
                return {'status': 'not_found', 'error': '주문을 찾을 수 없음'}
            
            order = self.mock_orders[order_id].copy()
            return order
            
        except Exception as e:
            logger.error(f"주문 상태 조회 오류 {order_id}: {e}")
            return {'status': 'error', 'error': str(e)}
    
    async def cancel_order(self, order_id: str) -> bool:
        """주문 취소"""
        try:
            if order_id not in self.mock_orders:
                return False
            
            order = self.mock_orders[order_id]
            
            if order['status'] == 'pending':
                order['status'] = 'cancelled'
                order['cancel_time'] = datetime.now()
                logger.info(f"주문 취소됨: {order_id}")
                return True
            else:
                logger.warning(f"취소할 수 없는 주문 상태: {order_id} ({order['status']})")
                return False
                
        except Exception as e:
            logger.error(f"주문 취소 오류 {order_id}: {e}")
            return False
    
    async def get_account_info(self) -> Dict[str, Any]:
        """계좌 정보 조회"""
        try:
            if not self.is_connected:
                raise Exception("API 연결되지 않음")
            
            # 모의 계좌 정보
            account_info = {
                'account_number': self.account_number,
                'account_name': '모의투자계좌',
                'total_cash': 50000000,  # 5천만원
                'available_cash': 24000000,  # 2천4백만원
                'total_evaluation': 50000000,
                'total_profit_loss': 0,
                'profit_loss_rate': 0.0,
                'server_type': self.server_type
            }
            
            return account_info
            
        except Exception as e:
            logger.error(f"계좌 정보 조회 오류: {e}")
            return {}
    
    async def get_balance(self) -> List[Dict[str, Any]]:
        """잔고 조회"""
        try:
            if not self.is_connected:
                raise Exception("API 연결되지 않음")
            
            # 모의 잔고 데이터
            balance = []
            
            # 현재 보유 종목 시뮬레이션
            holdings = {
                '005930': {'quantity': 50, 'avg_price': 70000},
                '035720': {'quantity': 30, 'avg_price': 88000}
            }
            
            for stock_code, holding in holdings.items():
                current_price_data = await self.get_current_price(stock_code)
                current_price = current_price_data['current_price']
                
                quantity = holding['quantity']
                avg_price = holding['avg_price']
                current_value = current_price * quantity
                purchase_value = avg_price * quantity
                profit_loss = current_value - purchase_value
                profit_loss_rate = (profit_loss / purchase_value) * 100
                
                balance_item = {
                    'stock_code': stock_code,
                    'stock_name': self.get_stock_name(stock_code),
                    'quantity': quantity,
                    'avg_price': avg_price,
                    'current_price': current_price,
                    'current_value': current_value,
                    'purchase_value': purchase_value,
                    'profit_loss': profit_loss,
                    'profit_loss_rate': profit_loss_rate,
                    'loan_amount': 0  # 신용거래 없음
                }
                
                balance.append(balance_item)
            
            return balance
            
        except Exception as e:
            logger.error(f"잔고 조회 오류: {e}")
            return []
    
    def get_stock_name(self, stock_code: str) -> str:
        """종목명 조회"""
        stock_names = {
            '005930': '삼성전자',
            '000660': 'SK하이닉스',
            '035420': 'NAVER',
            '035720': '카카오',
            '051910': 'LG화학',
            '006400': '삼성SDI',
            '207940': '삼성바이오로직스',
            '373220': 'LG에너지솔루션'
        }
        return stock_names.get(stock_code, f'종목{stock_code}')
    
    async def get_order_history(self, days: int = 30) -> List[Dict[str, Any]]:
        """주문 내역 조회"""
        try:
            if not self.is_connected:
                raise Exception("API 연결되지 않음")
            
            # 날짜 범위 설정
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)
            
            # 조건에 맞는 주문들 필터링
            history = []
            for order_id, order in self.mock_orders.items():
                order_time = order['order_time']
                if start_date <= order_time <= end_date:
                    history_item = order.copy()
                    history_item['stock_name'] = self.get_stock_name(order['stock_code'])
                    history.append(history_item)
            
            # 주문 시간 역순 정렬
            history.sort(key=lambda x: x['order_time'], reverse=True)
            
            return history
            
        except Exception as e:
            logger.error(f"주문 내역 조회 오류: {e}")
            return []
    
    async def get_market_status(self) -> Dict[str, Any]:
        """시장 상태 조회"""
        try:
            current_time = datetime.now()
            current_hour = current_time.hour
            current_minute = current_time.minute
            
            # 시장 개장 시간 체크 (9:00 - 15:30)
            is_market_open = False
            market_status = "장마감"
            
            if current_time.weekday() < 5:  # 평일
                if (current_hour == 9 and current_minute >= 0) or \
                   (9 < current_hour < 15) or \
                   (current_hour == 15 and current_minute <= 30):
                    is_market_open = True
                    market_status = "정규장"
                elif current_hour == 8 and current_minute >= 30:
                    market_status = "장전동시호가"
                elif current_hour == 15 and 30 < current_minute <= 40:
                    market_status = "장후동시호가"
            
            return {
                'is_open': is_market_open,
                'status': market_status,
                'server_time': current_time.isoformat(),
                'kospi_index': random.randint(2400, 2800),
                'kosdaq_index': random.randint(800, 1000),
                'exchange_rate': random.uniform(1300, 1400)  # 달러 환율
            }
            
        except Exception as e:
            logger.error(f"시장 상태 조회 오류: {e}")
            return {'is_open': False, 'status': 'error'}
    
    async def get_stock_info(self, stock_code: str) -> Dict[str, Any]:
        """종목 상세 정보 조회"""
        try:
            if not self.is_connected:
                raise Exception("API 연결되지 않음")
            
            # 기본 시세 정보 조회
            price_data = await self.get_current_price(stock_code)
            
            # 추가 종목 정보
            stock_info = {
                'stock_code': stock_code,
                'stock_name': self.get_stock_name(stock_code),
                'market': 'KOSPI' if stock_code.startswith(('00', '05')) else 'KOSDAQ',
                'sector': self.get_stock_sector(stock_code),
                'market_cap': price_data.get('market_cap', 0),
                'shares_outstanding': random.randint(100000000, 1000000000),
                'per': random.uniform(8.0, 25.0),
                'pbr': random.uniform(0.8, 3.0),
                'roe': random.uniform(5.0, 20.0),
                'dividend_yield': random.uniform(1.0, 5.0),
                'foreign_ownership': random.uniform(10.0, 70.0),
                '52_week_high': int(price_data['current_price'] * random.uniform(1.2, 1.8)),
                '52_week_low': int(price_data['current_price'] * random.uniform(0.6, 0.9))
            }
            
            stock_info.update(price_data)
            
            return stock_info
            
        except Exception as e:
            logger.error(f"종목 정보 조회 오류 {stock_code}: {e}")
            return {}
    
    def get_stock_sector(self, stock_code: str) -> str:
        """종목 섹터 조회"""
        sector_map = {
            '005930': '반도체',
            '000660': '반도체',
            '035420': '인터넷',
            '035720': '인터넷',
            '051910': '화학',
            '006400': '배터리',
            '207940': '바이오',
            '373220': '배터리'
        }
        return sector_map.get(stock_code, '기타')
    
    async def get_candle_data(self, stock_code: str, period: str = 'D', count: int = 100) -> List[Dict[str, Any]]:
        """캔들 데이터 조회"""
        try:
            if not self.is_connected:
                raise Exception("API 연결되지 않음")
            
            # 현재 가격 기준으로 과거 캔들 데이터 시뮬레이션
            current_price_data = await self.get_current_price(stock_code)
            base_price = current_price_data['current_price']
            
            candles = []
            current_date = datetime.now()
            
            for i in range(count):
                # 날짜 계산
                if period == 'D':
                    date = current_date - timedelta(days=i)
                elif period == 'W':
                    date = current_date - timedelta(weeks=i)
                elif period == 'M':
                    date = current_date - timedelta(days=i*30)
                else:  # minute
                    date = current_date - timedelta(minutes=i)
                
                # 가격 시뮬레이션
                price_variation = random.uniform(0.9, 1.1)
                open_price = int(base_price * price_variation)
                
                high_variation = random.uniform(1.0, 1.05)
                high_price = int(open_price * high_variation)
                
                low_variation = random.uniform(0.95, 1.0)
                low_price = int(open_price * low_variation)
                
                close_variation = random.uniform(0.98, 1.02)
                close_price = int(open_price * close_variation)
                
                volume = random.randint(100000, 5000000)
                
                candle = {
                    'date': date.strftime('%Y%m%d'),
                    'time': date.strftime('%H%M%S') if period in ['1', '5', '15', '30', '60'] else None,
                    'open': open_price,
                    'high': high_price,
                    'low': low_price,
                    'close': close_price,
                    'volume': volume,
                    'amount': close_price * volume
                }
                
                candles.append(candle)
                
                # 다음 계산을 위해 base_price 조정
                base_price = close_price
            
            # 시간순 정렬
            candles.reverse()
            
            return candles
            
        except Exception as e:
            logger.error(f"캔들 데이터 조회 오류 {stock_code}: {e}")
            return []
    
    async def get_market_capitalization(self, market: str = 'KOSPI') -> List[Dict[str, Any]]:
        """시가총액 상위 종목 조회"""
        try:
            if not self.is_connected:
                raise Exception("API 연결되지 않음")
            
            # 시가총액 상위 종목 시뮬레이션
            top_stocks = []
            
            if market == 'KOSPI':
                stock_list = ['005930', '000660', '035420', '051910', '006400', '207940', '373220']
            else:  # KOSDAQ
                stock_list = ['035720']
            
            for i, stock_code in enumerate(stock_list):
                price_data = await self.get_current_price(stock_code)
                
                stock_info = {
                    'rank': i + 1,
                    'stock_code': stock_code,
                    'stock_name': self.get_stock_name(stock_code),
                    'current_price': price_data['current_price'],
                    'change_rate': price_data.get('change_rate', 0),
                    'market_cap': price_data.get('market_cap', 0),
                    'volume': price_data['volume']
                }
                
                top_stocks.append(stock_info)
            
            # 시가총액 기준 정렬
            top_stocks.sort(key=lambda x: x['market_cap'], reverse=True)
            
            return top_stocks
            
        except Exception as e:
            logger.error(f"시가총액 조회 오류: {e}")
            return []
    
    async def search_stock(self, keyword: str) -> List[Dict[str, Any]]:
        """종목 검색"""
        try:
            if not self.is_connected:
                raise Exception("API 연결되지 않음")
            
            results = []
            
            # 모든 종목에서 검색
            for stock_code in self.mock_prices.keys():
                stock_name = self.get_stock_name(stock_code)
                
                # 종목코드나 종목명에 키워드가 포함된 경우
                if keyword.lower() in stock_code.lower() or keyword in stock_name:
                    price_data = await self.get_current_price(stock_code)
                    
                    result = {
                        'stock_code': stock_code,
                        'stock_name': stock_name,
                        'current_price': price_data['current_price'],
                        'change_rate': price_data.get('change_rate', 0),
                        'market': 'KOSPI' if stock_code.startswith(('00', '05')) else 'KOSDAQ'
                    }
                    
                    results.append(result)
            
            return results
            
        except Exception as e:
            logger.error(f"종목 검색 오류: {e}")
            return []
    
    async def get_news(self, stock_code: str = None, count: int = 10) -> List[Dict[str, Any]]:
        """뉴스 조회"""
        try:
            if not self.is_connected:
                raise Exception("API 연결되지 않음")
            
            # 모의 뉴스 데이터 생성
            news_titles = [
                "반도체 업황 개선 기대감 확산",
                "4분기 실적 전망 양호",
                "신제품 출시로 매출 증대 예상",
                "해외 시장 진출 계획 발표",
                "ESG 경영 강화 방안 공개",
                "디지털 전환 투자 확대",
                "친환경 기술 개발 박차",
                "글로벌 파트너십 체결"
            ]
            
            news_list = []
            
            for i in range(count):
                news_time = datetime.now() - timedelta(hours=random.randint(1, 48))
                
                news_item = {
                    'title': random.choice(news_titles),
                    'content': "관련 뉴스 내용입니다.",
                    'source': random.choice(['연합뉴스', '이데일리', '매일경제', '한국경제']),
                    'datetime': news_time.isoformat(),
                    'stock_code': stock_code if stock_code else random.choice(list(self.mock_prices.keys())),
                    'url': f"http://example.com/news/{i+1}"
                }
                
                news_list.append(news_item)
            
            # 시간순 정렬
            news_list.sort(key=lambda x: x['datetime'], reverse=True)
            
            return news_list
            
        except Exception as e:
            logger.error(f"뉴스 조회 오류: {e}")
            return []
    
    def get_connection_status(self) -> Dict[str, Any]:
        """연결 상태 확인"""
        return {
            'is_connected': self.is_connected,
            'account_number': self.account_number if self.is_connected else None,
            'server_type': self.server_type,
            'api_version': '1.0.0',
            'connection_time': datetime.now().isoformat() if self.is_connected else None
        } 



==================================================
File: C:\Aproject\test\quant_actual\backend\data\market_data.py
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\backend\data\__init__.py
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\backend\trading\engine.py
==================================================
# file: backend/trading/engine.py

import asyncio
import logging
from datetime import datetime, time, timedelta
from typing import Dict, List, Optional
import json

from models import *
from database import get_db_session, DatabaseManager
from trading.strategies import StrategyManager
from trading.risk_manager import RiskManager
from data.kiwoom_mock import KiwoomClient
from utils.config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

class TradingEngine:
    """메인 트레이딩 엔진"""
    
    def __init__(self):
        self.is_running = False
        self.is_trading_enabled = False
        self.kiwoom_client = None
        self.strategy_manager = None
        self.risk_manager = None
        self.current_positions = {}
        self.active_strategies = {}
        self.market_data = {}
        self.daily_pnl = 0.0
        self.last_update = None
        
        # 시장 시간 설정
        self.market_open_time = time(9, 0)    # 오전 9시
        self.market_close_time = time(15, 30)  # 오후 3시 30분
        
    async def initialize(self):
        """트레이딩 엔진 초기화"""
        try:
            logger.info("트레이딩 엔진 초기화 시작...")
            
            # 키움 클라이언트 초기화
            self.kiwoom_client = KiwoomClient()
            await self.kiwoom_client.connect()
            
            # 전략 매니저 초기화
            self.strategy_manager = StrategyManager()
            await self.strategy_manager.initialize()
            
            # 리스크 매니저 초기화
            self.risk_manager = RiskManager()
            
            # 활성 전략 로드
            await self.load_active_strategies()
            
            # 현재 포지션 로드
            await self.load_current_positions()
            
            logger.info("트레이딩 엔진 초기화 완료")
            
        except Exception as e:
            logger.error(f"트레이딩 엔진 초기화 실패: {e}")
            raise
    
    async def run(self):
        """메인 트레이딩 루프"""
        self.is_running = True
        logger.info("트레이딩 루프 시작")
        
        try:
            while self.is_running:
                current_time = datetime.now().time()
                
                # 시장 시간인지 확인
                if self.is_market_hours(current_time):
                    if not self.is_trading_enabled:
                        self.is_trading_enabled = True
                        logger.info("시장 시간 - 트레이딩 활성화")
                    
                    await self.trading_cycle()
                else:
                    if self.is_trading_enabled:
                        self.is_trading_enabled = False
                        logger.info("시장 종료 - 트레이딩 비활성화")
                    
                    # 시장 외 시간에는 데이터 정리 작업
                    await self.after_market_tasks()
                
                # 1초 대기
                await asyncio.sleep(1)
                
        except asyncio.CancelledError:
            logger.info("트레이딩 루프 취소됨")
        except Exception as e:
            logger.error(f"트레이딩 루프 오류: {e}")
        finally:
            self.is_running = False
            logger.info("트레이딩 루프 종료")
    
    async def trading_cycle(self):
        """단일 트레이딩 사이클 (1초마다 실행)"""
        try:
            # 1. 실시간 시장 데이터 수신
            await self.update_market_data()
            
            # 2. 포지션 상태 업데이트
            await self.update_positions()
            
            # 3. 각 전략별 신호 생성 및 처리
            for strategy_id, strategy in self.active_strategies.items():
                try:
                    # 전략별 신호 계산
                    signals = await self.strategy_manager.generate_signals(
                        strategy_id, self.market_data
                    )
                    
                    # 신호가 있으면 처리
                    if signals:
                        await self.process_signals(signals, strategy_id)
                        
                except Exception as e:
                    logger.error(f"전략 {strategy_id} 처리 중 오류: {e}")
            
            # 4. 포트폴리오 상태 업데이트
            await self.update_portfolio()
            
            # 5. 리스크 체크
            await self.check_risk_limits()
            
            self.last_update = datetime.now()
            
        except Exception as e:
            logger.error(f"트레이딩 사이클 오류: {e}")
    
    async def update_market_data(self):
        """실시간 시장 데이터 업데이트"""
        try:
            # 모든 관심 종목의 현재가 조회
            stock_codes = set()
            
            # 활성 전략의 대상 종목들 수집
            for strategy in self.active_strategies.values():
                target_stocks = json.loads(strategy.target_stocks)
                stock_codes.update(target_stocks)
            
            # 현재 보유 종목들 추가
            for position in self.current_positions.values():
                stock_codes.add(position['stock_code'])
            
            # 키움 API를 통한 실시간 데이터 수신
            for stock_code in stock_codes:
                price_data = await self.kiwoom_client.get_current_price(stock_code)
                self.market_data[stock_code] = price_data
                
                # 데이터베이스에 가격 업데이트
                DatabaseManager.update_stock_price(
                    stock_code, 
                    price_data['current_price'], 
                    price_data['volume']
                )
            
        except Exception as e:
            logger.error(f"시장 데이터 업데이트 실패: {e}")
    
    async def process_signals(self, signals: List[TradingSignal], strategy_id: int):
        """트레이딩 신호 처리"""
        for signal in signals:
            try:
                # 리스크 검증
                if not await self.risk_manager.validate_signal(signal, self.current_positions):
                    logger.warning(f"리스크 검증 실패 - 신호 무시: {signal.stock_code} {signal.signal_type}")
                    continue
                
                # 주문 생성 및 실행
                order_id = await self.create_and_execute_order(signal, strategy_id)
                
                if order_id:
                    logger.info(f"주문 실행: {signal.stock_code} {signal.signal_type} {signal.quantity}주")
                
            except Exception as e:
                logger.error(f"신호 처리 실패 {signal.stock_code}: {e}")
    
    async def create_and_execute_order(self, signal: TradingSignal, strategy_id: int) -> Optional[int]:
        """주문 생성 및 실행"""
        try:
            with get_db_session() as db:
                # 종목 정보 조회
                stock = db.query(Stock).filter(Stock.code == signal.stock_code).first()
                if not stock:
                    logger.error(f"종목을 찾을 수 없음: {signal.stock_code}")
                    return None
                
                # 주문 생성
                order = Order(
                    strategy_id=strategy_id,
                    stock_id=stock.id,
                    order_type=signal.signal_type,
                    quantity=signal.quantity,
                    price=signal.price,
                    status=OrderStatus.PENDING,
                    order_time=datetime.now()
                )
                
                db.add(order)
                db.commit()
                db.refresh(order)
                
                # 키움 API를 통한 주문 전송
                kiwoom_order_id = await self.kiwoom_client.send_order(
                    stock_code=signal.stock_code,
                    order_type=signal.signal_type,
                    quantity=signal.quantity,
                    price=signal.price
                )
                
                # 키움 주문 번호 업데이트
                order.kiwoom_order_id = kiwoom_order_id
                db.commit()
                
                # 주문 상태 모니터링 시작
                asyncio.create_task(self.monitor_order(order.id))
                
                return order.id
                
        except Exception as e:
            logger.error(f"주문 생성 실패: {e}")
            return None
    
    async def monitor_order(self, order_id: int):
        """주문 상태 모니터링"""
        try:
            max_wait_time = 300  # 5분 최대 대기
            start_time = datetime.now()
            
            while (datetime.now() - start_time).seconds < max_wait_time:
                with get_db_session() as db:
                    order = db.query(Order).filter(Order.id == order_id).first()
                    if not order:
                        break
                    
                    # 키움 API에서 주문 상태 조회
                    order_status = await self.kiwoom_client.get_order_status(order.kiwoom_order_id)
                    
                    if order_status['status'] == 'filled':
                        # 주문 체결 처리
                        order.status = OrderStatus.FILLED
                        order.fill_time = datetime.now()
                        order.fill_price = order_status['fill_price']
                        order.fill_quantity = order_status['fill_quantity']
                        order.commission = order_status.get('commission', 0.0)
                        
                        db.commit()
                        
                        # 포지션 업데이트
                        await self.update_position_from_order(order)
                        
                        logger.info(f"주문 체결: {order.id} - {order_status['fill_quantity']}주 @ {order_status['fill_price']}")
                        break
                    
                    elif order_status['status'] == 'cancelled':
                        order.status = OrderStatus.CANCELLED
                        db.commit()
                        logger.info(f"주문 취소: {order.id}")
                        break
                    
                    elif order_status['status'] == 'rejected':
                        order.status = OrderStatus.REJECTED
                        db.commit()
                        logger.warning(f"주문 거부: {order.id}")
                        break
                
                await asyncio.sleep(1)  # 1초마다 체크
                
        except Exception as e:
            logger.error(f"주문 모니터링 실패 {order_id}: {e}")
    
    async def update_position_from_order(self, order: Order):
        """주문 체결 후 포지션 업데이트"""
        try:
            with get_db_session() as db:
                stock = db.query(Stock).filter(Stock.id == order.stock_id).first()
                
                # 기존 포지션 조회
                position = db.query(Position)\
                    .filter(Position.strategy_id == order.strategy_id)\
                    .filter(Position.stock_id == order.stock_id)\
                    .first()
                
                if order.order_type == OrderType.BUY:
                    if position:
                        # 기존 포지션에 추가
                        total_cost = (position.quantity * position.avg_price) + (order.fill_quantity * order.fill_price)
                        total_quantity = position.quantity + order.fill_quantity
                        position.avg_price = total_cost / total_quantity
                        position.quantity = total_quantity
                    else:
                        # 새 포지션 생성
                        position = Position(
                            strategy_id=order.strategy_id,
                            stock_id=order.stock_id,
                            quantity=order.fill_quantity,
                            avg_price=order.fill_price,
                            current_price=order.fill_price
                        )
                        db.add(position)
                
                elif order.order_type == OrderType.SELL and position:
                    # 매도 처리
                    sell_quantity = min(order.fill_quantity, position.quantity)
                    
                    # 실현손익 계산
                    realized_pnl = (order.fill_price - position.avg_price) * sell_quantity - order.commission
                    position.realized_pnl += realized_pnl
                    position.quantity -= sell_quantity
                    
                    # 포지션이 0이 되면 삭제하지 않고 유지 (히스토리 목적)
                    if position.quantity <= 0:
                        position.quantity = 0
                
                if position:
                    position.updated_at = datetime.now()
                
                db.commit()
                
                # 메모리 상의 포지션 정보도 업데이트
                await self.load_current_positions()
                
        except Exception as e:
            logger.error(f"포지션 업데이트 실패: {e}")
    
    async def update_positions(self):
        """포지션의 현재가 및 미실현손익 업데이트"""
        try:
            with get_db_session() as db:
                positions = db.query(Position)\
                    .filter(Position.quantity > 0)\
                    .all()
                
                for position in positions:
                    stock = db.query(Stock).filter(Stock.id == position.stock_id).first()
                    if stock and stock.code in self.market_data:
                        current_price = self.market_data[stock.code]['current_price']
                        position.current_price = current_price
                        
                        # 미실현손익 계산
                        position.unrealized_pnl = (current_price - position.avg_price) * position.quantity
                        position.updated_at = datetime.now()
                
                db.commit()
                
        except Exception as e:
            logger.error(f"포지션 업데이트 실패: {e}")
    
    async def update_portfolio(self):
        """포트폴리오 상태 업데이트"""
        try:
            with get_db_session() as db:
                # 현재 포지션들의 정보 수집
                positions = db.query(Position)\
                    .filter(Position.quantity > 0)\
                    .all()
                
                total_invested = sum(pos.avg_price * pos.quantity for pos in positions)
                total_current_value = sum((pos.current_price or pos.avg_price) * pos.quantity for pos in positions)
                total_unrealized_pnl = sum(pos.unrealized_pnl for pos in positions)
                total_realized_pnl = sum(pos.realized_pnl for pos in positions)
                
                # 현금 잔고 (초기 자본에서 투자금 차감)
                initial_cash = 50000000.0  # 5천만원
                cash_balance = initial_cash - total_invested + total_realized_pnl
                
                # 총 포트폴리오 가치
                total_portfolio_value = cash_balance + total_current_value
                
                # 일일 손익 계산 (오늘 거래분만)
                today = datetime.now().date()
                today_orders = db.query(Order)\
                    .filter(Order.fill_time >= datetime.combine(today, time.min))\
                    .filter(Order.status == OrderStatus.FILLED)\
                    .all()
                
                daily_realized_pnl = 0.0
                for order in today_orders:
                    if order.order_type == OrderType.SELL:
                        # 간단한 일일 실현손익 계산
                        position = db.query(Position)\
                            .filter(Position.strategy_id == order.strategy_id)\
                            .filter(Position.stock_id == order.stock_id)\
                            .first()
                        if position:
                            daily_realized_pnl += (order.fill_price - position.avg_price) * order.fill_quantity
                
                # 포트폴리오 레코드 생성
                portfolio_record = Portfolio(
                    total_value=total_portfolio_value,
                    cash=cash_balance,
                    invested_amount=total_invested,
                    realized_pnl=total_realized_pnl,
                    unrealized_pnl=total_unrealized_pnl,
                    daily_pnl=daily_realized_pnl + total_unrealized_pnl,
                    total_return=((total_portfolio_value - initial_cash) / initial_cash) * 100,
                    timestamp=datetime.now()
                )
                
                db.add(portfolio_record)
                db.commit()
                
                self.daily_pnl = portfolio_record.daily_pnl
                
        except Exception as e:
            logger.error(f"포트폴리오 업데이트 실패: {e}")
    
    async def check_risk_limits(self):
        """리스크 한도 체크"""
        try:
            risk_check = await self.risk_manager.check_daily_limits(
                current_pnl=self.daily_pnl,
                current_positions=self.current_positions
            )
            
            if not risk_check['is_safe']:
                logger.warning(f"리스크 한도 초과: {risk_check['message']}")
                
                # 심각한 리스크인 경우 자동 중단
                if risk_check['severity'] == 'critical':
                    await self.emergency_stop()
                    
        except Exception as e:
            logger.error(f"리스크 체크 실패: {e}")
    
    async def load_active_strategies(self):
        """활성화된 전략 로드"""
        try:
            with get_db_session() as db:
                strategies = db.query(Strategy).filter(Strategy.is_active == True).all()
                
                self.active_strategies = {}
                for strategy in strategies:
                    self.active_strategies[strategy.id] = strategy
                    logger.info(f"활성 전략 로드: {strategy.name}")
                    
        except Exception as e:
            logger.error(f"활성 전략 로드 실패: {e}")
    
    async def load_current_positions(self):
        """현재 포지션 로드"""
        try:
            with get_db_session() as db:
                positions = db.query(Position)\
                    .join(Stock)\
                    .filter(Position.quantity > 0)\
                    .all()
                
                self.current_positions = {}
                for pos in positions:
                    key = f"{pos.strategy_id}_{pos.stock_id}"
                    self.current_positions[key] = {
                        'strategy_id': pos.strategy_id,
                        'stock_id': pos.stock_id,
                        'stock_code': pos.stock.code,
                        'quantity': pos.quantity,
                        'avg_price': pos.avg_price,
                        'current_price': pos.current_price,
                        'unrealized_pnl': pos.unrealized_pnl
                    }
                    
        except Exception as e:
            logger.error(f"포지션 로드 실패: {e}")
    
    async def after_market_tasks(self):
        """장 마감 후 작업들"""
        try:
            # 5분마다 한 번씩 실행
            if datetime.now().minute % 5 == 0:
                # 오래된 데이터 정리
                DatabaseManager.cleanup_old_data(days=30)
                
                # 백업 생성 (일주일에 한 번)
                if datetime.now().weekday() == 6:  # 일요일
                    from database import backup_database
                    backup_database()
                    
        except Exception as e:
            logger.error(f"장 마감 후 작업 실패: {e}")
    
    def is_market_hours(self, current_time: time) -> bool:
        """시장 시간인지 확인"""
        # 주말 제외
        if datetime.now().weekday() >= 5:  # 토요일(5), 일요일(6)
            return False
        
        # 시장 시간 체크
        return self.market_open_time <= current_time <= self.market_close_time
    
    async def start_trading(self):
        """자동매매 수동 시작"""
        self.is_trading_enabled = True
        logger.info("자동매매 수동 시작됨")
    
    async def stop_trading(self):
        """자동매매 중지"""
        self.is_trading_enabled = False
        logger.info("자동매매 중지됨")
    
    async def emergency_stop(self):
        """긴급 중단"""
        try:
            logger.critical("긴급중단 실행 시작")
            
            # 1. 모든 트레이딩 중지
            self.is_trading_enabled = False
            
            # 2. 대기중인 주문 모두 취소
            with get_db_session() as db:
                pending_orders = db.query(Order)\
                    .filter(Order.status == OrderStatus.PENDING)\
                    .all()
                
                for order in pending_orders:
                    try:
                        await self.kiwoom_client.cancel_order(order.kiwoom_order_id)
                        order.status = OrderStatus.CANCELLED
                        logger.info(f"주문 취소: {order.id}")
                    except Exception as e:
                        logger.error(f"주문 취소 실패 {order.id}: {e}")
                
                db.commit()
            
            # 3. 모든 포지션 시장가 매도 (선택적)
            if settings.emergency_sell_all:
                await self.sell_all_positions()
            
            # 4. 알림 발송
            await self.send_emergency_notification()
            
            logger.critical("긴급중단 실행 완료")
            
        except Exception as e:
            logger.error(f"긴급중단 실행 실패: {e}")
            raise
    
    async def sell_all_positions(self):
        """모든 포지션 강제 매도"""
        try:
            with get_db_session() as db:
                positions = db.query(Position)\
                    .join(Stock)\
                    .filter(Position.quantity > 0)\
                    .all()
                
                for position in positions:
                    try:
                        # 시장가 매도 주문
                        current_price = self.market_data.get(position.stock.code, {}).get('current_price', position.avg_price)
                        
                        order = Order(
                            strategy_id=position.strategy_id,
                            stock_id=position.stock_id,
                            order_type=OrderType.SELL,
                            quantity=position.quantity,
                            price=current_price * 0.95,  # 현재가의 95%로 시장가 매도
                            status=OrderStatus.PENDING,
                            order_time=datetime.now()
                        )
                        
                        db.add(order)
                        db.commit()
                        
                        # 키움 API로 주문 전송
                        kiwoom_order_id = await self.kiwoom_client.send_order(
                            stock_code=position.stock.code,
                            order_type=OrderType.SELL,
                            quantity=position.quantity,
                            price=order.price
                        )
                        
                        order.kiwoom_order_id = kiwoom_order_id
                        db.commit()
                        
                        logger.info(f"긴급 매도 주문: {position.stock.code} {position.quantity}주")
                        
                    except Exception as e:
                        logger.error(f"긴급 매도 실패 {position.stock.code}: {e}")
                        
        except Exception as e:
            logger.error(f"전체 포지션 매도 실패: {e}")
    
    async def send_emergency_notification(self):
        """긴급상황 알림 발송"""
        try:
            # 이메일, SMS, 슬랙 등으로 알림 발송
            # 실제 구현에서는 적절한 알림 서비스 사용
            logger.critical("긴급중단 알림 발송됨")
            
        except Exception as e:
            logger.error(f"긴급 알림 발송 실패: {e}")
    
    async def shutdown(self):
        """트레이딩 엔진 종료"""
        try:
            logger.info("트레이딩 엔진 종료 중...")
            
            # 트레이딩 중지
            self.is_running = False
            self.is_trading_enabled = False
            
            # 키움 연결 해제
            if self.kiwoom_client:
                await self.kiwoom_client.disconnect()
            
            logger.info("트레이딩 엔진 종료 완료")
            
        except Exception as e:
            logger.error(f"트레이딩 엔진 종료 실패: {e}")
    
    # API에서 사용하는 헬퍼 메서드들
    async def activate_strategy(self, strategy_id: int):
        """전략 활성화"""
        await self.load_active_strategies()
        logger.info(f"전략 활성화: {strategy_id}")
    
    async def deactivate_strategy(self, strategy_id: int):
        """전략 비활성화"""
        if strategy_id in self.active_strategies:
            del self.active_strategies[strategy_id]
        logger.info(f"전략 비활성화: {strategy_id}")
    
    async def execute_manual_order(self, order_id: int):
        """수동 주문 실행"""
        try:
            with get_db_session() as db:
                order = db.query(Order).filter(Order.id == order_id).first()
                if order:
                    await self.monitor_order(order_id)
                    
        except Exception as e:
            logger.error(f"수동 주문 실행 실패: {e}")
    
    def get_active_strategies(self):
        """활성 전략 목록 반환"""
        return list(self.active_strategies.values())
    
    def get_current_positions(self):
        """현재 포지션 목록 반환"""
        return list(self.current_positions.values())
    
    def get_daily_order_count(self):
        """오늘 주문 수 반환"""
        try:
            with get_db_session() as db:
                today = datetime.now().date()
                count = db.query(Order)\
                    .filter(Order.order_time >= datetime.combine(today, time.min))\
                    .count()
                return count
        except:
            return 0
    
    async def get_market_data(self):
        """현재 시장 데이터 반환"""
        return self.market_data
    
    async def get_recent_signals(self, limit: int = 20):
        """최근 신호 목록 반환"""
        # 실제로는 신호 히스토리를 저장하고 조회해야 함
        return []
    
    async def get_risk_metrics(self):
        """리스크 지표 반환"""
        return await self.risk_manager.get_current_metrics()
    
    async def update_risk_limits(self, risk_limits: dict):
        """리스크 한도 업데이트"""
        await self.risk_manager.update_limits(risk_limits) 



==================================================
File: C:\Aproject\test\quant_actual\backend\trading\indicators.py
==================================================
# file: backend/trading/indicators.py

import numpy as np
import pandas as pd
from typing import List, Dict, Optional, Union
import logging

logger = logging.getLogger(__name__)

class TechnicalIndicators:
    """기술적 지표 계산 클래스"""
    
    @staticmethod
    def moving_average(prices: List[float], period: int) -> List[float]:
        """단순 이동평균 (SMA) 계산"""
        if len(prices) < period:
            return []
        
        try:
            df = pd.Series(prices)
            ma = df.rolling(window=period).mean()
            return ma.dropna().tolist()
        except Exception as e:
            logger.error(f"이동평균 계산 오류: {e}")
            return []
    
    @staticmethod
    def exponential_moving_average(prices: List[float], period: int) -> List[float]:
        """지수 이동평균 (EMA) 계산"""
        if len(prices) < period:
            return []
        
        try:
            df = pd.Series(prices)
            ema = df.ewm(span=period, adjust=False).mean()
            return ema.tolist()
        except Exception as e:
            logger.error(f"지수이동평균 계산 오류: {e}")
            return []
    
    @staticmethod
    def bollinger_bands(prices: List[float], period: int = 20, std_dev: float = 2.0) -> Optional[Dict[str, List[float]]]:
        """볼린저 밴드 계산"""
        if len(prices) < period:
            return None
        
        try:
            df = pd.Series(prices)
            
            # 후행스팬 (Chikou Span)
            chikou_span = close_df.shift(-kijun_period)
            
            return {
                'tenkan_sen': tenkan_sen.dropna().tolist(),
                'kijun_sen': kijun_sen.dropna().tolist(),
                'senkou_span_a': senkou_span_a.dropna().tolist(),
                'senkou_span_b': senkou_span_b.dropna().tolist(),
                'chikou_span': chikou_span.dropna().tolist()
            }
        except Exception as e:
            logger.error(f"일목균형표 계산 오류: {e}")
            return None

class PatternRecognition:
    """캔들 패턴 인식 클래스"""
    
    @staticmethod
    def is_doji(open_price: float, high_price: float, low_price: float, close_price: float, threshold: float = 0.1) -> bool:
        """도지 패턴 인식"""
        try:
            body = abs(close_price - open_price)
            range_price = high_price - low_price
            
            if range_price == 0:
                return False
                
            body_ratio = body / range_price
            return body_ratio <= threshold
        except:
            return False
    
    @staticmethod
    def is_hammer(open_price: float, high_price: float, low_price: float, close_price: float) -> bool:
        """해머 패턴 인식"""
        try:
            body = abs(close_price - open_price)
            upper_shadow = high_price - max(open_price, close_price)
            lower_shadow = min(open_price, close_price) - low_price
            
            # 해머 조건: 짧은 몸통, 긴 아래꼬리, 짧은 위꼬리
            return (lower_shadow >= 2 * body and 
                   upper_shadow <= body * 0.5 and
                   body > 0)
        except:
            return False
    
    @staticmethod
    def is_shooting_star(open_price: float, high_price: float, low_price: float, close_price: float) -> bool:
        """유성 패턴 인식"""
        try:
            body = abs(close_price - open_price)
            upper_shadow = high_price - max(open_price, close_price)
            lower_shadow = min(open_price, close_price) - low_price
            
            # 유성 조건: 짧은 몸통, 긴 위꼬리, 짧은 아래꼬리
            return (upper_shadow >= 2 * body and 
                   lower_shadow <= body * 0.5 and
                   body > 0)
        except:
            return False
    
    @staticmethod
    def is_engulfing_bullish(candle1: Dict[str, float], candle2: Dict[str, float]) -> bool:
        """강세 포용선 패턴 인식"""
        try:
            # 첫 번째 캔들: 음봉
            first_bearish = candle1['close'] < candle1['open']
            
            # 두 번째 캔들: 양봉이고 첫 번째 캔들을 완전히 포용
            second_bullish = candle2['close'] > candle2['open']
            engulfs = (candle2['open'] < candle1['close'] and 
                      candle2['close'] > candle1['open'])
            
            return first_bearish and second_bullish and engulfs
        except:
            return False
    
    @staticmethod
    def is_engulfing_bearish(candle1: Dict[str, float], candle2: Dict[str, float]) -> bool:
        """약세 포용선 패턴 인식"""
        try:
            # 첫 번째 캔들: 양봉
            first_bullish = candle1['close'] > candle1['open']
            
            # 두 번째 캔들: 음봉이고 첫 번째 캔들을 완전히 포용
            second_bearish = candle2['close'] < candle2['open']
            engulfs = (candle2['open'] > candle1['close'] and 
                      candle2['close'] < candle1['open'])
            
            return first_bullish and second_bearish and engulfs
        except:
            return False

class TrendAnalysis:
    """추세 분석 클래스"""
    
    @staticmethod
    def identify_trend(prices: List[float], period: int = 20) -> str:
        """추세 식별 (상승/하락/횡보)"""
        if len(prices) < period * 2:
            return "insufficient_data"
        
        try:
            # 최근 기간과 이전 기간의 평균 비교
            recent_avg = np.mean(prices[-period:])
            previous_avg = np.mean(prices[-(period*2):-period])
            
            change_rate = (recent_avg - previous_avg) / previous_avg
            
            if change_rate > 0.02:  # 2% 이상 상승
                return "uptrend"
            elif change_rate < -0.02:  # 2% 이상 하락
                return "downtrend"
            else:
                return "sideways"
        except:
            return "unknown"
    
    @staticmethod
    def calculate_trend_strength(prices: List[float], period: int = 20) -> float:
        """추세 강도 계산 (0~1)"""
        if len(prices) < period:
            return 0.0
        
        try:
            # 선형 회귀를 이용한 추세 강도
            x = np.arange(len(prices[-period:]))
            y = np.array(prices[-period:])
            
            correlation = np.corrcoef(x, y)[0, 1]
            return abs(correlation) if not np.isnan(correlation) else 0.0
        except:
            return 0.0
    
    @staticmethod
    def detect_breakout(prices: List[float], resistance_level: float, support_level: float, 
                       current_price: float, volume_increase: bool = False) -> Dict[str, bool]:
        """돌파 패턴 감지"""
        try:
            # 저항선 돌파
            resistance_breakout = current_price > resistance_level * 1.01  # 1% 마진
            
            # 지지선 하락
            support_breakdown = current_price < support_level * 0.99  # 1% 마진
            
            return {
                'resistance_breakout': resistance_breakout and volume_increase,
                'support_breakdown': support_breakdown and volume_increase,
                'breakout_confirmed': (resistance_breakout or support_breakdown) and volume_increase
            }
        except:
            return {'resistance_breakout': False, 'support_breakdown': False, 'breakout_confirmed': False}

class RiskMetrics:
    """리스크 지표 계산 클래스"""
    
    @staticmethod
    def calculate_var(returns: List[float], confidence_level: float = 0.05) -> float:
        """VaR (Value at Risk) 계산"""
        if not returns:
            return 0.0
        
        try:
            return np.percentile(returns, confidence_level * 100)
        except:
            return 0.0
    
    @staticmethod
    def calculate_cvar(returns: List[float], confidence_level: float = 0.05) -> float:
        """CVaR (Conditional Value at Risk) 계산"""
        if not returns:
            return 0.0
        
        try:
            var = RiskMetrics.calculate_var(returns, confidence_level)
            tail_losses = [r for r in returns if r <= var]
            return np.mean(tail_losses) if tail_losses else 0.0
        except:
            return 0.0
    
    @staticmethod
    def calculate_sharpe_ratio(returns: List[float], risk_free_rate: float = 0.02) -> float:
        """샤프 비율 계산"""
        if not returns:
            return 0.0
        
        try:
            excess_returns = np.array(returns) - risk_free_rate / 252  # 일간 무위험 수익률
            return np.mean(excess_returns) / np.std(excess_returns) * np.sqrt(252) if np.std(excess_returns) != 0 else 0.0
        except:
            return 0.0
    
    @staticmethod
    def calculate_sortino_ratio(returns: List[float], risk_free_rate: float = 0.02) -> float:
        """소르티노 비율 계산"""
        if not returns:
            return 0.0
        
        try:
            excess_returns = np.array(returns) - risk_free_rate / 252
            downside_returns = excess_returns[excess_returns < 0]
            downside_std = np.std(downside_returns) if len(downside_returns) > 0 else 0.0
            
            return np.mean(excess_returns) / downside_std * np.sqrt(252) if downside_std != 0 else 0.0
        except:
            return 0.0
    
    @staticmethod
    def calculate_max_drawdown(prices: List[float]) -> Dict[str, float]:
        """최대 낙폭 계산"""
        if not prices:
            return {'max_drawdown': 0.0, 'max_drawdown_pct': 0.0}
        
        try:
            peak = prices[0]
            max_drawdown = 0.0
            max_drawdown_pct = 0.0
            
            for price in prices:
                if price > peak:
                    peak = price
                else:
                    drawdown = peak - price
                    drawdown_pct = drawdown / peak
                    
                    if drawdown > max_drawdown:
                        max_drawdown = drawdown
                        max_drawdown_pct = drawdown_pct
            
            return {
                'max_drawdown': max_drawdown,
                'max_drawdown_pct': max_drawdown_pct
            }
        # except:
        #     return {'max_drawdown': 0.0, 'max_drawdown_pct': 0.0} 
        #     middle = df.rolling(window=period).mean()
            
        #     # 표준편차
        #     std = df.rolling(window=period).std()
            
        #     # 상단선, 하단선
        #     upper = middle + (std * std_dev)
        #     lower = middle - (std * std_dev)
            
        #     return {
        #         'upper': upper.dropna().tolist(),
        #         'middle': middle.dropna().tolist(),
        #         'lower': lower.dropna().tolist()
        #     }
        except Exception as e:
            logger.error(f"볼린저밴드 계산 오류: {e}")
            return None
    
    @staticmethod
    def rsi(prices: List[float], period: int = 14) -> List[float]:
        """RSI (Relative Strength Index) 계산"""
        if len(prices) < period + 1:
            return []
        
        try:
            df = pd.Series(prices)
            
            # 가격 변화 계산
            delta = df.diff()
            
            # 상승분과 하락분 분리
            gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
            
            # RS 계산
            rs = gain / loss
            
            # RSI 계산
            rsi = 100 - (100 / (1 + rs))
            
            return rsi.dropna().tolist()
        except Exception as e:
            logger.error(f"RSI 계산 오류: {e}")
            return []
    
    @staticmethod
    def macd(prices: List[float], fast_period: int = 12, slow_period: int = 26, signal_period: int = 9) -> Optional[Dict[str, List[float]]]:
        """MACD (Moving Average Convergence Divergence) 계산"""
        if len(prices) < slow_period:
            return None
        
        try:
            df = pd.Series(prices)
            
            # 빠른 EMA와 느린 EMA 계산
            ema_fast = df.ewm(span=fast_period).mean()
            ema_slow = df.ewm(span=slow_period).mean()
            
            # MACD 라인
            macd_line = ema_fast - ema_slow
            
            # 신호선 (MACD의 EMA)
            signal_line = macd_line.ewm(span=signal_period).mean()
            
            # 히스토그램
            histogram = macd_line - signal_line
            
            return {
                'macd': macd_line.dropna().tolist(),
                'signal': signal_line.dropna().tolist(),
                'histogram': histogram.dropna().tolist()
            }
        except Exception as e:
            logger.error(f"MACD 계산 오류: {e}")
            return None
    
    @staticmethod
    def stochastic(high_prices: List[float], low_prices: List[float], close_prices: List[float], 
                  k_period: int = 14, d_period: int = 3) -> Optional[Dict[str, List[float]]]:
        """스토캐스틱 오실레이터 계산"""
        if len(high_prices) < k_period or len(low_prices) < k_period or len(close_prices) < k_period:
            return None
        
        try:
            high_df = pd.Series(high_prices)
            low_df = pd.Series(low_prices)
            close_df = pd.Series(close_prices)
            
            # %K 계산
            lowest_low = low_df.rolling(window=k_period).min()
            highest_high = high_df.rolling(window=k_period).max()
            
            k_percent = 100 * ((close_df - lowest_low) / (highest_high - lowest_low))
            
            # %D 계산 (%K의 이동평균)
            d_percent = k_percent.rolling(window=d_period).mean()
            
            return {
                'k': k_percent.dropna().tolist(),
                'd': d_percent.dropna().tolist()
            }
        except Exception as e:
            logger.error(f"스토캐스틱 계산 오류: {e}")
            return None
    
    @staticmethod
    def williams_r(high_prices: List[float], low_prices: List[float], close_prices: List[float], 
                  period: int = 14) -> List[float]:
        """윌리엄스 %R 계산"""
        if len(high_prices) < period:
            return []
        
        try:
            high_df = pd.Series(high_prices)
            low_df = pd.Series(low_prices)
            close_df = pd.Series(close_prices)
            
            highest_high = high_df.rolling(window=period).max()
            lowest_low = low_df.rolling(window=period).min()
            
            williams_r = -100 * ((highest_high - close_df) / (highest_high - lowest_low))
            
            return williams_r.dropna().tolist()
        except Exception as e:
            logger.error(f"윌리엄스 %R 계산 오류: {e}")
            return []
    
    @staticmethod
    def cci(high_prices: List[float], low_prices: List[float], close_prices: List[float], 
            period: int = 20) -> List[float]:
        """CCI (Commodity Channel Index) 계산"""
        if len(high_prices) < period:
            return []
        
        try:
            high_df = pd.Series(high_prices)
            low_df = pd.Series(low_prices)
            close_df = pd.Series(close_prices)
            
            # 일반적인 가격 (Typical Price)
            tp = (high_df + low_df + close_df) / 3
            
            # 이동평균
            ma_tp = tp.rolling(window=period).mean()
            
            # 평균절대편차
            mad = tp.rolling(window=period).apply(lambda x: np.abs(x - x.mean()).mean())
            
            # CCI 계산
            cci = (tp - ma_tp) / (0.015 * mad)
            
            return cci.dropna().tolist()
        except Exception as e:
            logger.error(f"CCI 계산 오류: {e}")
            return []
    
    @staticmethod
    def atr(high_prices: List[float], low_prices: List[float], close_prices: List[float], 
            period: int = 14) -> List[float]:
        """ATR (Average True Range) 계산"""
        if len(high_prices) < period + 1:
            return []
        
        try:
            high_df = pd.Series(high_prices)
            low_df = pd.Series(low_prices)
            close_df = pd.Series(close_prices)
            
            # True Range 계산
            prev_close = close_df.shift(1)
            
            tr1 = high_df - low_df
            tr2 = abs(high_df - prev_close)
            tr3 = abs(low_df - prev_close)
            
            true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
            
            # ATR 계산 (True Range의 이동평균)
            atr = true_range.rolling(window=period).mean()
            
            return atr.dropna().tolist()
        except Exception as e:
            logger.error(f"ATR 계산 오류: {e}")
            return []
    
    @staticmethod
    def obv(close_prices: List[float], volumes: List[int]) -> List[float]:
        """OBV (On-Balance Volume) 계산"""
        if len(close_prices) != len(volumes) or len(close_prices) < 2:
            return []
        
        try:
            close_df = pd.Series(close_prices)
            volume_df = pd.Series(volumes)
            
            # 가격 변화 방향
            price_change = close_df.diff()
            
            # OBV 계산
            obv_values = []
            obv = 0
            
            for i, (price_diff, volume) in enumerate(zip(price_change, volume_df)):
                if i == 0:  # 첫 번째 값
                    obv = volume
                elif price_diff > 0:  # 가격 상승
                    obv += volume
                elif price_diff < 0:  # 가격 하락
                    obv -= volume
                # 가격 변화 없으면 OBV 변화 없음
                
                obv_values.append(obv)
            
            return obv_values
        except Exception as e:
            logger.error(f"OBV 계산 오류: {e}")
            return []
    
    @staticmethod
    def fibonacci_retracement(high_price: float, low_price: float) -> Dict[str, float]:
        """피보나치 되돌림 계산"""
        try:
            diff = high_price - low_price
            
            return {
                '0%': high_price,
                '23.6%': high_price - (diff * 0.236),
                '38.2%': high_price - (diff * 0.382),
                '50%': high_price - (diff * 0.5),
                '61.8%': high_price - (diff * 0.618),
                '100%': low_price
            }
        except Exception as e:
            logger.error(f"피보나치 되돌림 계산 오류: {e}")
            return {}
    
    @staticmethod
    def pivot_points(high_price: float, low_price: float, close_price: float) -> Dict[str, float]:
        """피벗 포인트 계산"""
        try:
            pivot = (high_price + low_price + close_price) / 3
            
            return {
                'pivot': pivot,
                'r1': 2 * pivot - low_price,
                'r2': pivot + (high_price - low_price),
                'r3': high_price + 2 * (pivot - low_price),
                's1': 2 * pivot - high_price,
                's2': pivot - (high_price - low_price),
                's3': low_price - 2 * (high_price - pivot)
            }
        except Exception as e:
            logger.error(f"피벗 포인트 계산 오류: {e}")
            return {}
    
    @staticmethod
    def support_resistance(prices: List[float], window: int = 20, min_touches: int = 2) -> Dict[str, List[float]]:
        """지지선/저항선 계산"""
        if len(prices) < window * 2:
            return {'support': [], 'resistance': []}
        
        try:
            df = pd.Series(prices)
            
            # 국지적 고점과 저점 찾기
            highs = []
            lows = []
            
            for i in range(window, len(prices) - window):
                # 고점 체크
                if all(prices[i] >= prices[j] for j in range(i - window, i + window + 1) if j != i):
                    highs.append((i, prices[i]))
                
                # 저점 체크
                if all(prices[i] <= prices[j] for j in range(i - window, i + window + 1) if j != i):
                    lows.append((i, prices[i]))
            
            # 저항선과 지지선 레벨 그룹화
            resistance_levels = []
            support_levels = []
            
            # 비슷한 가격대의 고점들을 그룹화
            tolerance = 0.02  # 2% 허용오차
            
            for _, price in highs:
                found_group = False
                for level in resistance_levels:
                    if abs(price - level) / level < tolerance:
                        found_group = True
                        break
                if not found_group:
                    resistance_levels.append(price)
            
            # 비슷한 가격대의 저점들을 그룹화
            for _, price in lows:
                found_group = False
                for level in support_levels:
                    if abs(price - level) / level < tolerance:
                        found_group = True
                        break
                if not found_group:
                    support_levels.append(price)
            
            return {
                'support': sorted(support_levels),
                'resistance': sorted(resistance_levels, reverse=True)
            }
        except Exception as e:
            logger.error(f"지지/저항선 계산 오류: {e}")
            return {'support': [], 'resistance': []}
    
    @staticmethod
    def calculate_volatility(prices: List[float], period: int = 20) -> float:
        """변동성 계산 (표준편차 기반)"""
        if len(prices) < period:
            return 0.0
        
        try:
            df = pd.Series(prices)
            returns = df.pct_change().dropna()
            volatility = returns.rolling(window=period).std().iloc[-1]
            
            # 연율화 (일간 변동성을 연간으로 변환)
            return volatility * np.sqrt(252)  # 252 = 연간 거래일수
        except Exception as e:
            logger.error(f"변동성 계산 오류: {e}")
            return 0.0
    
    @staticmethod
    def calculate_correlation(prices1: List[float], prices2: List[float], period: int = 20) -> float:
        """두 자산간 상관계수 계산"""
        if len(prices1) < period or len(prices2) < period or len(prices1) != len(prices2):
            return 0.0
        
        try:
            df1 = pd.Series(prices1)
            df2 = pd.Series(prices2)
            
            returns1 = df1.pct_change().dropna()
            returns2 = df2.pct_change().dropna()
            
            correlation = returns1.rolling(window=period).corr(returns2).iloc[-1]
            
            return correlation if not np.isnan(correlation) else 0.0
        except Exception as e:
            logger.error(f"상관계수 계산 오류: {e}")
            return 0.0
        
    # @staticmethod
    #     def ichimoku_cloud(high_prices: List[float], low_prices: List[float], close_prices: List[float], tenkan_period: int = 9, kijun_period: int = 26, senkou_span_b_period: int = 52) -> Optional[Dict[str, List[float]]]:
    #         """일목균형표 계산"""
    #         if len(high_prices) < senkou_span_b_period:
    #             return None
            
    #         try:
    #             high_df = pd.Series(high_prices)
    #             low_df = pd.Series(low_prices)
    #             close_df = pd.Series(close_prices)
                
    #             # 전환선 (Tenkan-sen)
    #             tenkan_high = high_df.rolling(window=tenkan_period).max()
    #             tenkan_low = low_df.rolling(window=tenkan_period).min()
    #             tenkan_sen = (tenkan_high + tenkan_low) / 2
                
    #             # 기준선 (Kijun-sen)
    #             kijun_high = high_df.rolling(window=kijun_period).max()
    #             kijun_low = low_df.rolling(window=kijun_period).min()
    #             kijun_sen = (kijun_high + kijun_low) / 2
                
    #             # 선행스팬 A (Senkou Span A)
    #             senkou_span_a = ((tenkan_sen + kijun_sen) / 2).shift(kijun_period)
                
    #             # 선행스팬 B (Senkou Span B)
    #             senkou_high = high_df.rolling(window=senkou_span_b_period).max()
    #             senkou_low = low_df.rolling(window=senkou_span_b_period).min()
    #             senkou_span_b = ((senkou_high + senkou_low) / 2).shift(kijun_period)
                
    #             # 후행스팬 (Chikou Span)
    #             chikou_span = close_df.shift(-kijun_period)
                
    #             return {
    #                 'tenkan_sen': tenkan_sen.dropna().tolist(),
    #                 'kijun_sen': kijun_sen.dropna().tolist(),
    #                 'senkou_span_a': senkou_span_a.dropna().tolist(),
    #                 'senkou_span_b': senkou_span_b.dropna().tolist(),
    #                 'chikou_span': chikou_span.dropna().tolist()
    #             }
    #         except Exception as e:
    #             logger.error(f"일목균형표 계산 오류: {e}")
    #             return None

class PatternRecognition:
    """캔들 패턴 인식 클래스"""
    
    @staticmethod
    def is_doji(open_price: float, high_price: float, low_price: float, close_price: float, threshold: float = 0.1) -> bool:
        """도지 패턴 인식"""
        try:
            body = abs(close_price - open_price)
            range_price = high_price - low_price
            
            if range_price == 0:
                return False
                
            body_ratio = body / range_price
            return body_ratio <= threshold
        except:
            return False
    
    @staticmethod
    def is_hammer(open_price: float, high_price: float, low_price: float, close_price: float) -> bool:
        """해머 패턴 인식"""
        try:
            body = abs(close_price - open_price)
            upper_shadow = high_price - max(open_price, close_price)
            lower_shadow = min(open_price, close_price) - low_price
            
            # 해머 조건: 짧은 몸통, 긴 아래꼬리, 짧은 위꼬리
            return (lower_shadow >= 2 * body and 
                   upper_shadow <= body * 0.5 and
                   body > 0)
        except:
            return False
    
    @staticmethod
    def is_shooting_star(open_price: float, high_price: float, low_price: float, close_price: float) -> bool:
        """유성 패턴 인식"""
        try:
            body = abs(close_price - open_price)
            upper_shadow = high_price - max(open_price, close_price)
            lower_shadow = min(open_price, close_price) - low_price
            
            # 유성 조건: 짧은 몸통, 긴 위꼬리, 짧은 아래꼬리
            return (upper_shadow >= 2 * body and 
                   lower_shadow <= body * 0.5 and
                   body > 0)
        except:
            return False
    
    @staticmethod
    def is_engulfing_bullish(candle1: Dict[str, float], candle2: Dict[str, float]) -> bool:
        """강세 포용선 패턴 인식"""
        try:
            # 첫 번째 캔들: 음봉
            first_bearish = candle1['close'] < candle1['open']
            
            # 두 번째 캔들: 양봉이고 첫 번째 캔들을 완전히 포용
            second_bullish = candle2['close'] > candle2['open']
            engulfs = (candle2['open'] < candle1['close'] and 
                      candle2['close'] > candle1['open'])
            
            return first_bearish and second_bullish and engulfs
        except:
            return False
    
    @staticmethod
    def is_engulfing_bearish(candle1: Dict[str, float], candle2: Dict[str, float]) -> bool:
        """약세 포용선 패턴 인식"""
        try:
            # 첫 번째 캔들: 양봉
            first_bullish = candle1['close'] > candle1['open']
            
            # 두 번째 캔들: 음봉이고 첫 번째 캔들을 완전히 포용
            second_bearish = candle2['close'] < candle2['open']
            engulfs = (candle2['open'] > candle1['close'] and 
                      candle2['close'] < candle1['open'])
            
            return first_bullish and second_bearish and engulfs
        except:
            return False

class TrendAnalysis:
    """추세 분석 클래스"""
    
    @staticmethod
    def identify_trend(prices: List[float], period: int = 20) -> str:
        """추세 식별 (상승/하락/횡보)"""
        if len(prices) < period * 2:
            return "insufficient_data"
        
        try:
            # 최근 기간과 이전 기간의 평균 비교
            recent_avg = np.mean(prices[-period:])
            previous_avg = np.mean(prices[-(period*2):-period])
            
            change_rate = (recent_avg - previous_avg) / previous_avg
            
            if change_rate > 0.02:  # 2% 이상 상승
                return "uptrend"
            elif change_rate < -0.02:  # 2% 이상 하락
                return "downtrend"
            else:
                return "sideways"
        except:
            return "unknown"
    
    @staticmethod
    def calculate_trend_strength(prices: List[float], period: int = 20) -> float:
        """추세 강도 계산 (0~1)"""
        if len(prices) < period:
            return 0.0
        
        try:
            # 선형 회귀를 이용한 추세 강도
            x = np.arange(len(prices[-period:]))
            y = np.array(prices[-period:])
            
            correlation = np.corrcoef(x, y)[0, 1]
            return abs(correlation) if not np.isnan(correlation) else 0.0
        except:
            return 0.0
    
    @staticmethod
    def detect_breakout(prices: List[float], resistance_level: float, support_level: float, 
                       current_price: float, volume_increase: bool = False) -> Dict[str, bool]:
        """돌파 패턴 감지"""
        try:
            # 저항선 돌파
            resistance_breakout = current_price > resistance_level * 1.01  # 1% 마진
            
            # 지지선 하락
            support_breakdown = current_price < support_level * 0.99  # 1% 마진
            
            return {
                'resistance_breakout': resistance_breakout and volume_increase,
                'support_breakdown': support_breakdown and volume_increase,
                'breakout_confirmed': (resistance_breakout or support_breakdown) and volume_increase
            }
        except:
            return {'resistance_breakout': False, 'support_breakdown': False, 'breakout_confirmed': False}

class RiskMetrics:
    """리스크 지표 계산 클래스"""
    
    @staticmethod
    def calculate_var(returns: List[float], confidence_level: float = 0.05) -> float:
        """VaR (Value at Risk) 계산"""
        if not returns:
            return 0.0
        
        try:
            return np.percentile(returns, confidence_level * 100)
        except:
            return 0.0
    
    @staticmethod
    def calculate_cvar(returns: List[float], confidence_level: float = 0.05) -> float:
        """CVaR (Conditional Value at Risk) 계산"""
        if not returns:
            return 0.0
        
        try:
            var = RiskMetrics.calculate_var(returns, confidence_level)
            tail_losses = [r for r in returns if r <= var]
            return np.mean(tail_losses) if tail_losses else 0.0
        except:
            return 0.0
    
    @staticmethod
    def calculate_sharpe_ratio(returns: List[float], risk_free_rate: float = 0.02) -> float:
        """샤프 비율 계산"""
        if not returns:
            return 0.0
        
        try:
            excess_returns = np.array(returns) - risk_free_rate / 252  # 일간 무위험 수익률
            return np.mean(excess_returns) / np.std(excess_returns) * np.sqrt(252) if np.std(excess_returns) != 0 else 0.0
        except:
            return 0.0
    
    @staticmethod
    def calculate_sortino_ratio(returns: List[float], risk_free_rate: float = 0.02) -> float:
        """소르티노 비율 계산"""
        if not returns:
            return 0.0
        
        try:
            excess_returns = np.array(returns) - risk_free_rate / 252
            downside_returns = excess_returns[excess_returns < 0]
            downside_std = np.std(downside_returns) if len(downside_returns) > 0 else 0.0
            
            return np.mean(excess_returns) / downside_std * np.sqrt(252) if downside_std != 0 else 0.0
        except:
            return 0.0
    
    @staticmethod
    def calculate_max_drawdown(prices: List[float]) -> Dict[str, float]:
        """최대 낙폭 계산"""
        if not prices:
            return {'max_drawdown': 0.0, 'max_drawdown_pct': 0.0}
        
        try:
            peak = prices[0]
            max_drawdown = 0.0
            max_drawdown_pct = 0.0
            
            for price in prices:
                if price > peak:
                    peak = price
                else:
                    drawdown = peak - price
                    drawdown_pct = drawdown / peak
                    
                    if drawdown > max_drawdown:
                        max_drawdown = drawdown
                        max_drawdown_pct = drawdown_pct
            
            return {
                'max_drawdown': max_drawdown,
                'max_drawdown_pct': max_drawdown_pct
            }
        except:
            return {'max_drawdown': 0.0, 'max_drawdown_pct': 0.0}


==================================================
File: C:\Aproject\test\quant_actual\backend\trading\risk_manager.py
==================================================
# file: backend/trading/risk_manager.py

import logging
from typing import Dict, List, Any, Optional
from datetime import datetime, date, time
import json

from models import TradingSignal, RiskMetrics
from database import get_db_session
from utils.config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

class RiskManager:
    """리스크 관리 클래스"""
    
    def __init__(self):
        # 기본 리스크 한도 설정
        self.daily_loss_limit = -0.02  # -2%
        self.position_size_limit = 0.05  # 5%
        self.max_positions = 10
        self.max_single_stock_weight = 0.15  # 15%
        self.max_sector_weight = 0.3  # 30%
        
        # 동적 리스크 추적
        self.current_daily_loss = 0.0
        self.current_positions_count = 0
        self.sector_exposure = {}
        
        # 리스크 상태
        self.risk_level = "LOW"  # LOW, MEDIUM, HIGH, CRITICAL
        self.trading_allowed = True
        
    async def validate_signal(self, signal: TradingSignal, current_positions: Dict[str, Any]) -> bool:
        """트레이딩 신호의 리스크 검증"""
        try:
            # 1. 기본 리스크 체크
            if not self.trading_allowed:
                logger.warning("트레이딩이 비활성화됨 - 신호 거부")
                return False
            
            # 2. 일일 손실 한도 체크
            if not await self.check_daily_loss_limit():
                logger.warning("일일 손실 한도 초과 - 신호 거부")
                return False
            
            # 3. 포지션 수 한도 체크
            if signal.signal_type == "buy" and not self.check_position_count_limit(current_positions):
                logger.warning("최대 포지션 수 초과 - 매수 신호 거부")
                return False
            
            # 4. 포지션 크기 한도 체크
            if not await self.check_position_size_limit(signal):
                logger.warning("포지션 크기 한도 초과 - 신호 거부")
                return False
            
            # 5. 종목별 집중도 체크
            if not await self.check_concentration_risk(signal, current_positions):
                logger.warning("집중도 리스크 - 신호 거부")
                return False
            
            # 6. 시장 시간 체크
            if not self.check_market_hours():
                logger.warning("시장 시간 외 - 신호 거부")
                return False
            
            # 7. 변동성 체크
            if not await self.check_volatility_risk(signal):
                logger.warning("변동성 리스크 높음 - 신호 거부")
                return False
            
            logger.info(f"리스크 검증 통과: {signal.stock_code} {signal.signal_type}")
            return True
            
        except Exception as e:
            logger.error(f"리스크 검증 오류: {e}")
            return False
    
    async def check_daily_loss_limit(self) -> bool:
        """일일 손실 한도 체크"""
        try:
            # 오늘의 실현 손익 조회
            today_pnl = await self.get_today_pnl()
            self.current_daily_loss = today_pnl
            
            # 손실 한도 비교
            if today_pnl < self.daily_loss_limit:
                self.risk_level = "CRITICAL"
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"일일 손실 한도 체크 오류: {e}")
            return True  # 오류 시 안전하게 허용
    
    def check_position_count_limit(self, current_positions: Dict[str, Any]) -> bool:
        """포지션 수 한도 체크"""
        try:
            active_positions = len([pos for pos in current_positions.values() if pos['quantity'] > 0])
            self.current_positions_count = active_positions
            
            return active_positions < self.max_positions
            
        except Exception as e:
            logger.error(f"포지션 수 체크 오류: {e}")
            return True
    
    async def check_position_size_limit(self, signal: TradingSignal) -> bool:
        """포지션 크기 한도 체크"""
        try:
            # 현재 포트폴리오 총 가치 조회
            total_portfolio_value = await self.get_total_portfolio_value()
            
            # 신호의 투자 금액 계산
            signal_value = signal.quantity * signal.price
            
            # 포트폴리오 대비 비중 계산
            position_weight = signal_value / total_portfolio_value
            
            return position_weight <= self.position_size_limit
            
        except Exception as e:
            logger.error(f"포지션 크기 체크 오류: {e}")
            return True
    
    async def check_concentration_risk(self, signal: TradingSignal, current_positions: Dict[str, Any]) -> bool:
        """집중도 리스크 체크"""
        try:
            if signal.signal_type != "buy":
                return True  # 매도는 집중도 감소
            
            # 총 포트폴리오 가치
            total_value = await self.get_total_portfolio_value()
            
            # 동일 종목 집중도 체크
            current_stock_value = 0
            for pos in current_positions.values():
                if pos['stock_code'] == signal.stock_code:
                    current_stock_value += pos['quantity'] * pos['current_price']
            
            new_investment = signal.quantity * signal.price
            total_stock_value = current_stock_value + new_investment
            stock_weight = total_stock_value / total_value
            
            if stock_weight > self.max_single_stock_weight:
                logger.warning(f"종목 집중도 초과: {signal.stock_code} {stock_weight:.1%}")
                return False
            
            # 섹터 집중도 체크 (실제로는 종목-섹터 매핑 데이터 필요)
            sector = await self.get_stock_sector(signal.stock_code)
            if sector:
                sector_weight = await self.calculate_sector_weight(sector, current_positions, signal)
                if sector_weight > self.max_sector_weight:
                    logger.warning(f"섹터 집중도 초과: {sector} {sector_weight:.1%}")
                    return False
            
            return True
            
        except Exception as e:
            logger.error(f"집중도 리스크 체크 오류: {e}")
            return True
    
    def check_market_hours(self) -> bool:
        """시장 시간 체크"""
        try:
            now = datetime.now()
            
            # 주말 체크
            if now.weekday() >= 5:  # 토요일(5), 일요일(6)
                return False
            
            # 시장 시간 체크 (9:00 - 15:30)
            market_open = time(9, 0)
            market_close = time(15, 30)
            current_time = now.time()
            
            return market_open <= current_time <= market_close
            
        except Exception as e:
            logger.error(f"시장 시간 체크 오류: {e}")
            return False
    
    async def check_volatility_risk(self, signal: TradingSignal) -> bool:
        """변동성 리스크 체크"""
        try:
            # 종목의 최근 변동성 조회
            volatility = await self.get_stock_volatility(signal.stock_code)
            
            # 높은 변동성 종목의 경우 포지션 크기 제한
            high_volatility_threshold = 0.4  # 40% 연 변동성
            
            if volatility > high_volatility_threshold:
                # 신호의 신뢰도가 높은 경우만 허용
                return signal.confidence > 0.8
            
            return True
            
        except Exception as e:
            logger.error(f"변동성 리스크 체크 오류: {e}")
            return True
    
    async def check_daily_limits(self, current_pnl: float, current_positions: Dict[str, Any]) -> Dict[str, Any]:
        """일일 리스크 한도 체크"""
        try:
            risk_status = {
                'is_safe': True,
                'risk_level': 'LOW',
                'message': '',
                'severity': 'normal'
            }
            
            # 1. 일일 손실 체크
            loss_ratio = current_pnl / await self.get_total_portfolio_value()
            
            if loss_ratio <= self.daily_loss_limit:
                risk_status.update({
                    'is_safe': False,
                    'risk_level': 'CRITICAL',
                    'message': f'일일 손실 한도 초과: {loss_ratio:.2%}',
                    'severity': 'critical'
                })
            elif loss_ratio <= self.daily_loss_limit * 0.7:
                risk_status.update({
                    'risk_level': 'HIGH',
                    'message': f'일일 손실 경고: {loss_ratio:.2%}',
                    'severity': 'high'
                })
            elif loss_ratio <= self.daily_loss_limit * 0.5:
                risk_status.update({
                    'risk_level': 'MEDIUM',
                    'message': f'일일 손실 주의: {loss_ratio:.2%}',
                    'severity': 'medium'
                })
            
            # 2. 포지션 수 체크
            position_count = len([pos for pos in current_positions.values() if pos['quantity'] > 0])
            if position_count >= self.max_positions:
                risk_status.update({
                    'risk_level': 'HIGH',
                    'message': f'최대 포지션 수 도달: {position_count}',
                    'severity': 'high'
                })
            
            # 3. 집중도 리스크 체크
            concentration_risk = await self.check_portfolio_concentration(current_positions)
            if concentration_risk['high_concentration']:
                risk_status.update({
                    'risk_level': 'MEDIUM',
                    'message': concentration_risk['message'],
                    'severity': 'medium'
                })
            
            return risk_status
            
        except Exception as e:
            logger.error(f"일일 리스크 체크 오류: {e}")
            return {'is_safe': True, 'risk_level': 'UNKNOWN', 'message': 'Risk check failed'}
    
    async def get_current_metrics(self) -> RiskMetrics:
        """현재 리스크 지표 반환"""
        try:
            return RiskMetrics(
                daily_loss_limit=self.daily_loss_limit,
                position_size_limit=self.position_size_limit,
                max_positions=self.max_positions,
                current_daily_loss=self.current_daily_loss,
                is_safe_to_trade=self.trading_allowed
            )
        except Exception as e:
            logger.error(f"리스크 지표 조회 오류: {e}")
            return RiskMetrics()
    
    async def update_limits(self, new_limits: Dict[str, Any]):
        """리스크 한도 업데이트"""
        try:
            if 'daily_loss_limit' in new_limits:
                self.daily_loss_limit = new_limits['daily_loss_limit']
            
            if 'position_size_limit' in new_limits:
                self.position_size_limit = new_limits['position_size_limit']
            
            if 'max_positions' in new_limits:
                self.max_positions = new_limits['max_positions']
            
            if 'max_single_stock_weight' in new_limits:
                self.max_single_stock_weight = new_limits['max_single_stock_weight']
            
            if 'max_sector_weight' in new_limits:
                self.max_sector_weight = new_limits['max_sector_weight']
            
            logger.info("리스크 한도 업데이트 완료")
            
        except Exception as e:
            logger.error(f"리스크 한도 업데이트 오류: {e}")
    
    # 헬퍼 메서드들
    async def get_today_pnl(self) -> float:
        """오늘의 실현 손익 조회"""
        try:
            from models import Order, OrderStatus
            
            with get_db_session() as db:
                today = date.today()
                today_orders = db.query(Order)\
                    .filter(Order.fill_time >= datetime.combine(today, time.min))\
                    .filter(Order.status == OrderStatus.FILLED)\
                    .all()
                
                total_pnl = 0.0
                for order in today_orders:
                    if order.order_type == "sell":
                        # 간단한 손익 계산 (실제로는 더 정교한 계산 필요)
                        total_pnl += (order.fill_price - order.price) * order.fill_quantity
                
                return total_pnl
                
        except Exception as e:
            logger.error(f"오늘 손익 조회 오류: {e}")
            return 0.0
    
    async def get_total_portfolio_value(self) -> float:
        """총 포트폴리오 가치 조회"""
        try:
            from models import Portfolio
            
            with get_db_session() as db:
                latest_portfolio = db.query(Portfolio)\
                    .order_by(Portfolio.timestamp.desc())\
                    .first()
                
                return latest_portfolio.total_value if latest_portfolio else 50000000.0
                
        except Exception as e:
            logger.error(f"포트폴리오 가치 조회 오류: {e}")
            return 50000000.0  # 기본값
    
    async def get_stock_sector(self, stock_code: str) -> Optional[str]:
        """종목의 섹터 정보 조회"""
        try:
            # 간단한 섹터 매핑 (실제로는 데이터베이스나 API에서 조회)
            sector_map = {
                '005930': 'Technology',  # 삼성전자
                '000660': 'Technology',  # SK하이닉스
                '035420': 'Technology',  # NAVER
                '035720': 'Technology',  # 카카오
                '051910': 'Chemical',    # LG화학
                '006400': 'Technology',  # 삼성SDI
                '207940': 'Biotech',     # 삼성바이오로직스
                '373220': 'Battery',     # LG에너지솔루션
            }
            
            return sector_map.get(stock_code)
            
        except Exception as e:
            logger.error(f"섹터 정보 조회 오류: {e}")
            return None
    
    async def calculate_sector_weight(self, sector: str, current_positions: Dict[str, Any], 
                                   new_signal: TradingSignal) -> float:
        """섹터별 투자 비중 계산"""
        try:
            total_value = await self.get_total_portfolio_value()
            sector_value = 0.0
            
            # 현재 섹터 투자 금액 계산
            for pos in current_positions.values():
                stock_sector = await self.get_stock_sector(pos['stock_code'])
                if stock_sector == sector:
                    sector_value += pos['quantity'] * pos['current_price']
            
            # 신규 투자 금액 추가
            if new_signal.signal_type == "buy":
                signal_sector = await self.get_stock_sector(new_signal.stock_code)
                if signal_sector == sector:
                    sector_value += new_signal.quantity * new_signal.price
            
            return sector_value / total_value
            
        except Exception as e:
            logger.error(f"섹터 비중 계산 오류: {e}")
            return 0.0
    
    async def get_stock_volatility(self, stock_code: str, days: int = 30) -> float:
        """종목 변동성 계산"""
        try:
            from models import Stock, PriceHistory
            from trading.indicators import TechnicalIndicators
            
            with get_db_session() as db:
                stock = db.query(Stock).filter(Stock.code == stock_code).first()
                if not stock:
                    return 0.0
                
                # 최근 30일 가격 데이터 조회
                price_records = db.query(PriceHistory)\
                    .filter(PriceHistory.stock_id == stock.id)\
                    .order_by(PriceHistory.timestamp.desc())\
                    .limit(days)\
                    .all()
                
                if len(price_records) < 10:
                    return 0.0
                
                prices = [record.price for record in reversed(price_records)]
                return TechnicalIndicators.calculate_volatility(prices, min(20, len(prices)))
                
        except Exception as e:
            logger.error(f"변동성 계산 오류: {e}")
            return 0.0
    
    async def check_portfolio_concentration(self, current_positions: Dict[str, Any]) -> Dict[str, Any]:
        """포트폴리오 집중도 체크"""
        try:
            total_value = await self.get_total_portfolio_value()
            
            # 종목별 비중 계산
            stock_weights = {}
            for pos in current_positions.values():
                stock_value = pos['quantity'] * pos['current_price']
                weight = stock_value / total_value
                stock_weights[pos['stock_code']] = weight
            
            # 최대 종목 비중 체크
            max_weight = max(stock_weights.values()) if stock_weights else 0.0
            high_concentration = max_weight > self.max_single_stock_weight
            
            result = {
                'high_concentration': high_concentration,
                'max_stock_weight': max_weight,
                'message': f'최대 종목 비중: {max_weight:.1%}' if high_concentration else ''
            }
            
            return result
            
        except Exception as e:
            logger.error(f"집중도 체크 오류: {e}")
            return {'high_concentration': False, 'max_stock_weight': 0.0, 'message': ''}
    
    def enable_trading(self):
        """트레이딩 활성화"""
        self.trading_allowed = True
        logger.info("트레이딩 활성화됨")
    
    def disable_trading(self):
        """트레이딩 비활성화"""
        self.trading_allowed = False
        logger.warning("트레이딩 비활성화됨")
    
    def set_risk_level(self, level: str):
        """리스크 레벨 설정"""
        valid_levels = ["LOW", "MEDIUM", "HIGH", "CRITICAL"]
        if level in valid_levels:
            self.risk_level = level
            logger.info(f"리스크 레벨 설정: {level}")
            
            # 리스크 레벨에 따른 트레이딩 제한
            if level == "CRITICAL":
                self.disable_trading()
            elif level in ["LOW", "MEDIUM"]:
                self.enable_trading()

class PositionSizer:
    """포지션 크기 계산 클래스"""
    
    def __init__(self, risk_manager: RiskManager):
        self.risk_manager = risk_manager
    
    def calculate_position_size(self, signal: TradingSignal, portfolio_value: float, 
                              volatility: float = 0.2) -> int:
        """포지션 크기 계산 (Kelly Criterion 기반)"""
        try:
            # 기본 포지션 크기 (포트폴리오의 5%)
            base_position_value = portfolio_value * self.risk_manager.position_size_limit
            
            # 신호 신뢰도에 따른 조정
            confidence_multiplier = min(1.5, signal.confidence * 1.5)
            
            # 변동성에 따른 조정 (변동성이 높을수록 포지션 크기 감소)
            volatility_multiplier = max(0.5, 1 - volatility)
            
            # 최종 포지션 값 계산
            adjusted_position_value = base_position_value * confidence_multiplier * volatility_multiplier
            
            # 주식 수량 계산 (100주 단위)
            quantity = int(adjusted_position_value / signal.price / 100) * 100
            
            return max(100, quantity)  # 최소 100주
            
        except Exception as e:
            logger.error(f"포지션 크기 계산 오류: {e}")
            return 100
    
    def calculate_stop_loss_price(self, entry_price: float, atr: float, 
                                 multiplier: float = 2.0) -> float:
        """손절가 계산 (ATR 기반)"""
        try:
            return entry_price - (atr * multiplier)
        except:
            return entry_price * 0.95  # 기본 5% 손절
    
    def calculate_take_profit_price(self, entry_price: float, atr: float, 
                                  risk_reward_ratio: float = 2.0) -> float:
        """익절가 계산"""
        try:
            stop_loss = self.calculate_stop_loss_price(entry_price, atr)
            risk_amount = entry_price - stop_loss
            return entry_price + (risk_amount * risk_reward_ratio)
        except:
            return entry_price * 1.1  # 기본 10% 익절

class DrawdownManager:
    """낙폭 관리 클래스"""
    
    def __init__(self):
        self.peak_portfolio_value = 0.0
        self.current_drawdown = 0.0
        self.max_drawdown = 0.0
        self.max_drawdown_allowed = 0.15  # 15%
        
    def update_drawdown(self, current_portfolio_value: float):
        """낙폭 업데이트"""
        try:
            # 신고점 업데이트
            if current_portfolio_value > self.peak_portfolio_value:
                self.peak_portfolio_value = current_portfolio_value
                self.current_drawdown = 0.0
            else:
                # 현재 낙폭 계산
                self.current_drawdown = (self.peak_portfolio_value - current_portfolio_value) / self.peak_portfolio_value
                
                # 최대 낙폭 업데이트
                if self.current_drawdown > self.max_drawdown:
                    self.max_drawdown = self.current_drawdown
            
        except Exception as e:
            logger.error(f"낙폭 업데이트 오류: {e}")
    
    def is_drawdown_acceptable(self) -> bool:
        """낙폭이 허용 범위 내인지 확인"""
        return self.current_drawdown < self.max_drawdown_allowed
    
    def get_drawdown_status(self) -> Dict[str, float]:
        """낙폭 상태 반환"""
        return {
            'current_drawdown': self.current_drawdown,
            'max_drawdown': self.max_drawdown,
            'peak_value': self.peak_portfolio_value,
            'is_acceptable': self.is_drawdown_acceptable()
        }

class CorrelationManager:
    """상관관계 관리 클래스"""
    
    def __init__(self):
        self.correlation_matrix = {}
        self.max_correlation = 0.7  # 최대 허용 상관계수
    
    async def update_correlations(self, stock_codes: List[str], days: int = 60):
        """종목간 상관관계 업데이트"""
        try:
            from models import Stock, PriceHistory
            from trading.indicators import TechnicalIndicators
            
            price_data = {}
            
            # 각 종목의 가격 데이터 수집
            with get_db_session() as db:
                for stock_code in stock_codes:
                    stock = db.query(Stock).filter(Stock.code == stock_code).first()
                    if stock:
                        price_records = db.query(PriceHistory)\
                            .filter(PriceHistory.stock_id == stock.id)\
                            .order_by(PriceHistory.timestamp)\
                            .limit(days)\
                            .all()
                        
                        prices = [record.price for record in price_records]
                        if len(prices) >= days // 2:
                            price_data[stock_code] = prices
            
            # 상관계수 행렬 계산
            for code1 in price_data:
                for code2 in price_data:
                    if code1 != code2:
                        correlation = TechnicalIndicators.calculate_correlation(
                            price_data[code1], price_data[code2]
                        )
                        self.correlation_matrix[f"{code1}_{code2}"] = correlation
            
        except Exception as e:
            logger.error(f"상관관계 업데이트 오류: {e}")
    
    def check_correlation_risk(self, new_stock: str, existing_stocks: List[str]) -> bool:
        """새로운 종목 추가시 상관관계 리스크 체크"""
        try:
            for existing_stock in existing_stocks:
                key = f"{new_stock}_{existing_stock}"
                reverse_key = f"{existing_stock}_{new_stock}"
                
                correlation = self.correlation_matrix.get(key) or self.correlation_matrix.get(reverse_key, 0)
                
                if abs(correlation) > self.max_correlation:
                    logger.warning(f"높은 상관관계 감지: {new_stock} - {existing_stock} ({correlation:.2f})")
                    return False
            
            return True
            
        except Exception as e:
            logger.error(f"상관관계 체크 오류: {e}")
            return True

class RiskAlert:
    """리스크 알림 클래스"""
    
    def __init__(self):
        self.alert_thresholds = {
            'daily_loss': -0.015,  # -1.5%
            'drawdown': 0.10,      # 10%
            'volatility': 0.35     # 35%
        }
    
    async def check_and_send_alerts(self, portfolio_data: Dict[str, Any]):
        """리스크 알림 체크 및 발송"""
        try:
            alerts = []
            
            # 일일 손실 알림
            daily_loss_ratio = portfolio_data.get('daily_pnl', 0) / portfolio_data.get('total_value', 1)
            if daily_loss_ratio <= self.alert_thresholds['daily_loss']:
                alerts.append({
                    'type': 'daily_loss',
                    'severity': 'high',
                    'message': f'일일 손실 경고: {daily_loss_ratio:.2%}',
                    'timestamp': datetime.now()
                })
            
            # 낙폭 알림
            drawdown = portfolio_data.get('current_drawdown', 0)
            if drawdown >= self.alert_thresholds['drawdown']:
                alerts.append({
                    'type': 'drawdown',
                    'severity': 'high',
                    'message': f'낙폭 경고: {drawdown:.2%}',
                    'timestamp': datetime.now()
                })
            
            # 변동성 알림
            portfolio_volatility = portfolio_data.get('volatility', 0)
            if portfolio_volatility >= self.alert_thresholds['volatility']:
                alerts.append({
                    'type': 'volatility',
                    'severity': 'medium',
                    'message': f'높은 변동성 감지: {portfolio_volatility:.2%}',
                    'timestamp': datetime.now()
                })
            
            # 알림 발송
            for alert in alerts:
                await self.send_alert(alert)
            
        except Exception as e:
            logger.error(f"리스크 알림 체크 오류: {e}")
    
    async def send_alert(self, alert: Dict[str, Any]):
        """알림 발송"""
        try:
            # 실제로는 이메일, SMS, 슬랙 등으로 알림 발송
            logger.warning(f"리스크 알림: {alert['message']}")
            
            # 데이터베이스에 알림 기록 저장
            await self.save_alert_to_db(alert)
            
        except Exception as e:
            logger.error(f"알림 발송 오류: {e}")
    
    async def save_alert_to_db(self, alert: Dict[str, Any]):
        """알림을 데이터베이스에 저장"""
        try:
            # 실제 구현에서는 Alert 테이블에 저장
            pass
        except Exception as e:
            logger.error(f"알림 저장 오류: {e}")

class EmergencyManager:
    """비상 관리 클래스"""
    
    def __init__(self, risk_manager: RiskManager):
        self.risk_manager = risk_manager
        self.emergency_triggers = {
            'flash_crash': -0.05,  # 5% 급락
            'circuit_breaker': -0.08,  # 8% 급락
            'system_error': True
        }
    
    async def check_emergency_conditions(self, market_data: Dict[str, Any]) -> Dict[str, Any]:
        """비상 상황 체크"""
        try:
            emergency_status = {
                'emergency': False,
                'type': None,
                'severity': 'normal',
                'action_required': None
            }
            
            # 급락 체크
            portfolio_change = market_data.get('portfolio_change_rate', 0)
            
            if portfolio_change <= self.emergency_triggers['circuit_breaker']:
                emergency_status.update({
                    'emergency': True,
                    'type': 'circuit_breaker',
                    'severity': 'critical',
                    'action_required': 'emergency_stop'
                })
            elif portfolio_change <= self.emergency_triggers['flash_crash']:
                emergency_status.update({
                    'emergency': True,
                    'type': 'flash_crash',
                    'severity': 'high',
                    'action_required': 'stop_trading'
                })
            
            # 시스템 오류 체크
            if market_data.get('api_error', False):
                emergency_status.update({
                    'emergency': True,
                    'type': 'system_error',
                    'severity': 'high',
                    'action_required': 'emergency_stop'
                })
            
            return emergency_status
            
        except Exception as e:
            logger.error(f"비상 상황 체크 오류: {e}")
            return {'emergency': False}
    
    async def execute_emergency_action(self, action: str):
        """비상 조치 실행"""
        try:
            if action == 'emergency_stop':
                self.risk_manager.disable_trading()
                logger.critical("비상 중단 실행됨")
                
            elif action == 'stop_trading':
                self.risk_manager.disable_trading()
                logger.warning("트레이딩 중지됨")
                
            elif action == 'reduce_positions':
                # 포지션 크기 축소 로직
                logger.info("포지션 축소 모드 활성화")
                
        except Exception as e:
            logger.error(f"비상 조치 실행 오류: {e}") 



==================================================
File: C:\Aproject\test\quant_actual\backend\trading\strategies.py
==================================================
# file: backend/trading/strategies.py

import json
import logging
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
import numpy as np
import pandas as pd

from models import TradingSignal, OrderType, Strategy
from trading.indicators import TechnicalIndicators
from database import get_db_session

logger = logging.getLogger(__name__)

class BaseStrategy(ABC):
    """전략 베이스 클래스"""
    
    def __init__(self, strategy_config: Strategy):
        self.config = strategy_config
        self.name = strategy_config.name
        self.strategy_type = strategy_config.strategy_type
        self.target_stocks = json.loads(strategy_config.target_stocks)
        self.parameters = json.loads(strategy_config.parameters)
        self.indicators = TechnicalIndicators()
    
    @abstractmethod
    async def generate_signals(self, market_data: Dict[str, Any]) -> List[TradingSignal]:
        """매매 신호 생성 - 각 전략에서 구현"""
        pass
    
    def get_position_size(self, stock_code: str, current_price: float) -> int:
        """포지션 크기 계산"""
        try:
            investment_amount = self.config.investment_amount
            max_position_value = investment_amount * 0.3  # 전략 자금의 30%까지
            quantity = int(max_position_value / current_price / 100) * 100  # 100주 단위
            return max(100, quantity)  # 최소 100주
        except:
            return 100
    
    async def get_price_history(self, stock_code: str, days: int = 30) -> List[float]:
        """종목의 과거 가격 데이터 조회"""
        try:
            from models import Stock, PriceHistory
            
            with get_db_session() as db:
                stock = db.query(Stock).filter(Stock.code == stock_code).first()
                if not stock:
                    return []
                
                start_date = datetime.now() - timedelta(days=days)
                price_records = db.query(PriceHistory)\
                    .filter(PriceHistory.stock_id == stock.id)\
                    .filter(PriceHistory.timestamp >= start_date)\
                    .order_by(PriceHistory.timestamp)\
                    .all()
                
                return [record.price for record in price_records]
                
        except Exception as e:
            logger.error(f"가격 히스토리 조회 실패 {stock_code}: {e}")
            return []
    
    async def get_volume_history(self, stock_code: str, days: int = 5) -> List[int]:
        """종목의 과거 거래량 데이터 조회"""
        try:
            from models import Stock, PriceHistory
            
            with get_db_session() as db:
                stock = db.query(Stock).filter(Stock.code == stock_code).first()
                if not stock:
                    return []
                
                start_date = datetime.now() - timedelta(days=days)
                volume_records = db.query(PriceHistory)\
                    .filter(PriceHistory.stock_id == stock.id)\
                    .filter(PriceHistory.timestamp >= start_date)\
                    .order_by(PriceHistory.timestamp)\
                    .all()
                
                return [record.volume for record in volume_records if record.volume]
                
        except Exception as e:
            logger.error(f"거래량 히스토리 조회 실패 {stock_code}: {e}")
            return []
    
    async def get_current_position(self, stock_code: str) -> Optional[Dict[str, Any]]:
        """현재 보유 포지션 조회"""
        try:
            from models import Position, Stock
            
            with get_db_session() as db:
                position = db.query(Position)\
                    .join(Stock)\
                    .filter(Stock.code == stock_code)\
                    .filter(Position.strategy_id == self.config.id)\
                    .filter(Position.quantity > 0)\
                    .first()
                
                if position:
                    return {
                        'quantity': position.quantity,
                        'avg_price': position.avg_price,
                        'current_price': position.current_price,
                        'unrealized_pnl': position.unrealized_pnl
                    }
                return None
                
        except Exception as e:
            logger.error(f"포지션 조회 실패 {stock_code}: {e}")
            return None
    
    def should_stop_loss(self, position: Dict[str, Any], current_price: float) -> bool:
        """손절 여부 판단"""
        try:
            stop_loss_rate = self.parameters.get('stop_loss', 0.05)  # 기본 5% 손절
            avg_price = position['avg_price']
            loss_rate = (avg_price - current_price) / avg_price
            
            return loss_rate >= stop_loss_rate
            
        except:
            return False
    
    def should_take_profit(self, position: Dict[str, Any], current_price: float) -> bool:
        """익절 여부 판단"""
        try:
            take_profit_rate = self.parameters.get('take_profit', 0.1)  # 기본 10% 익절
            avg_price = position['avg_price']
            profit_rate = (current_price - avg_price) / avg_price
            
            return profit_rate >= take_profit_rate
            
        except:
            return False

class BollingerBandStrategy(BaseStrategy):
    """볼린저밴드 평균회귀 전략"""
    
    async def generate_signals(self, market_data: Dict[str, Any]) -> List[TradingSignal]:
        signals = []
        
        for stock_code in self.target_stocks:
            try:
                if stock_code not in market_data:
                    continue
                
                current_data = market_data[stock_code]
                current_price = current_data['current_price']
                
                # 과거 가격 데이터 조회
                price_history = await self.get_price_history(stock_code, days=30)
                if len(price_history) < self.parameters.get('period', 20):
                    continue
                
                # 볼린저밴드 계산
                period = self.parameters.get('period', 20)
                std_multiplier = self.parameters.get('std_multiplier', 2.0)
                
                bb_result = self.indicators.bollinger_bands(
                    price_history, period, std_multiplier
                )
                
                if not bb_result:
                    continue
                
                upper_band = bb_result['upper'][-1]
                lower_band = bb_result['lower'][-1]
                middle_band = bb_result['middle'][-1]
                
                # 현재 포지션 확인
                current_position = await self.get_current_position(stock_code)
                
                # 매수 신호: 가격이 하단선 아래로 내려갔을 때
                if current_price <= lower_band and not current_position:
                    quantity = self.get_position_size(stock_code, current_price)
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.BUY,
                        quantity=quantity,
                        price=current_price,
                        confidence=self.calculate_confidence(current_price, lower_band, middle_band),
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"볼린저밴드 매수 신호: {stock_code} @ {current_price}")
                
                # 매도 신호: 가격이 상단선 위로 올라갔을 때 또는 중간선 회귀
                elif current_position and (current_price >= upper_band or 
                    (current_price >= middle_band and self.should_take_profit(current_position, current_price))):
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.8,
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"볼린저밴드 매도 신호: {stock_code} @ {current_price}")
                
                # 손절 체크
                elif current_position and self.should_stop_loss(current_position, current_price):
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.9,  # 손절은 높은 확신도
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"볼린저밴드 손절 신호: {stock_code} @ {current_price}")
                    
            except Exception as e:
                logger.error(f"볼린저밴드 전략 오류 {stock_code}: {e}")
        
        return signals
    
    def calculate_confidence(self, current_price: float, lower_band: float, middle_band: float) -> float:
        """신호의 신뢰도 계산"""
        # 하단선에서 멀수록 높은 신뢰도
        distance_ratio = (lower_band - current_price) / (middle_band - lower_band)
        return min(0.95, max(0.5, 0.7 + distance_ratio * 0.3))

class RSIReversalStrategy(BaseStrategy):
    """RSI 역추세 전략"""
    
    async def generate_signals(self, market_data: Dict[str, Any]) -> List[TradingSignal]:
        signals = []
        
        for stock_code in self.target_stocks:
            try:
                if stock_code not in market_data:
                    continue
                
                current_data = market_data[stock_code]
                current_price = current_data['current_price']
                
                # 과거 가격 데이터 조회
                price_history = await self.get_price_history(stock_code, days=30)
                rsi_period = self.parameters.get('period', 14)
                
                if len(price_history) < rsi_period + 1:
                    continue
                
                # RSI 계산
                rsi_values = self.indicators.rsi(price_history, rsi_period)
                if not rsi_values or len(rsi_values) == 0:
                    continue
                
                current_rsi = rsi_values[-1]
                oversold_level = self.parameters.get('oversold', 30)
                overbought_level = self.parameters.get('overbought', 70)
                
                # 현재 포지션 확인
                current_position = await self.get_current_position(stock_code)
                
                # 매수 신호: RSI가 과매도 영역에서 반등
                if (current_rsi <= oversold_level and 
                    len(rsi_values) >= 2 and rsi_values[-2] < rsi_values[-1] and
                    not current_position):
                    
                    quantity = self.get_position_size(stock_code, current_price)
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.BUY,
                        quantity=quantity,
                        price=current_price,
                        confidence=self.calculate_rsi_confidence(current_rsi, oversold_level),
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"RSI 매수 신호: {stock_code} @ {current_price} (RSI: {current_rsi:.1f})")
                
                # 매도 신호: RSI가 과매수 영역에 진입
                elif (current_position and current_rsi >= overbought_level):
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=self.calculate_rsi_confidence(current_rsi, overbought_level, is_sell=True),
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"RSI 매도 신호: {stock_code} @ {current_price} (RSI: {current_rsi:.1f})")
                
                # 손절 체크
                elif current_position and self.should_stop_loss(current_position, current_price):
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.9,
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"RSI 손절 신호: {stock_code} @ {current_price}")
                    
            except Exception as e:
                logger.error(f"RSI 전략 오류 {stock_code}: {e}")
        
        return signals
    
    def calculate_rsi_confidence(self, rsi_value: float, threshold: float, is_sell: bool = False) -> float:
        """RSI 기반 신뢰도 계산"""
        if is_sell:
            # 과매수 영역에서 높을수록 신뢰도 높음
            excess = max(0, rsi_value - threshold)
            return min(0.95, 0.6 + excess * 0.01)
        else:
            # 과매도 영역에서 낮을수록 신뢰도 높음
            excess = max(0, threshold - rsi_value)
            return min(0.95, 0.6 + excess * 0.01)

class MomentumStrategy(BaseStrategy):
    """모멘텀 추세추종 전략"""
    
    async def generate_signals(self, market_data: Dict[str, Any]) -> List[TradingSignal]:
        signals = []
        
        for stock_code in self.target_stocks:
            try:
                if stock_code not in market_data:
                    continue
                
                current_data = market_data[stock_code]
                current_price = current_data['current_price']
                volume = current_data.get('volume', 0)
                
                # 과거 가격 데이터 조회
                price_history = await self.get_price_history(stock_code, days=60)
                if len(price_history) < 30:
                    continue
                
                # MACD 계산
                short_period = self.parameters.get('short_period', 12)
                long_period = self.parameters.get('long_period', 26)
                signal_period = self.parameters.get('signal_period', 9)
                
                macd_result = self.indicators.macd(
                    price_history, short_period, long_period, signal_period
                )
                
                if not macd_result or len(macd_result['macd']) < 2:
                    continue
                
                current_macd = macd_result['macd'][-1]
                current_signal_line = macd_result['signal'][-1]
                prev_macd = macd_result['macd'][-2]
                prev_signal_line = macd_result['signal'][-2]
                
                # 현재 포지션 확인
                current_position = await self.get_current_position(stock_code)
                
                # 매수 신호: MACD가 시그널선을 상향돌파 + 거래량 증가
                if (current_macd > current_signal_line and 
                    prev_macd <= prev_signal_line and
                    not current_position and
                    await self.is_volume_increasing(stock_code, volume)):
                    
                    quantity = self.get_position_size(stock_code, current_price)
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.BUY,
                        quantity=quantity,
                        price=current_price,
                        confidence=self.calculate_momentum_confidence(macd_result, volume),
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"모멘텀 매수 신호: {stock_code} @ {current_price}")
                
                # 매도 신호: MACD가 시그널선을 하향돌파
                elif (current_position and 
                      current_macd < current_signal_line and 
                      prev_macd >= prev_signal_line):
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.8,
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"모멘텀 매도 신호: {stock_code} @ {current_price}")
                
                # 손절 체크
                elif current_position and self.should_stop_loss(current_position, current_price):
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.9,
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
            except Exception as e:
                logger.error(f"모멘텀 전략 오류 {stock_code}: {e}")
        
        return signals
    
    async def is_volume_increasing(self, stock_code: str, current_volume: int) -> bool:
        """거래량 증가 확인"""
        try:
            # 최근 5일 평균 거래량과 비교
            volume_history = await self.get_volume_history(stock_code, days=5)
            if len(volume_history) < 3:
                return True  # 데이터 부족시 true
            
            avg_volume = sum(volume_history) / len(volume_history)
            return current_volume > avg_volume * 1.2  # 20% 이상 증가
            
        except:
            return True
    
    def calculate_momentum_confidence(self, macd_result: dict, volume: int) -> float:
        """모멘텀 신뢰도 계산"""
        try:
            # MACD 히스토그램의 강도와 거래량을 고려
            histogram = macd_result.get('histogram', [0])
            if len(histogram) > 0:
                current_histogram = abs(histogram[-1])
                base_confidence = 0.6
                histogram_bonus = min(0.3, current_histogram * 0.1)
                return base_confidence + histogram_bonus
            return 0.7
        except:
            return 0.7

class MovingAverageStrategy(BaseStrategy):
    """이동평균 골든크로스 전략"""
    
    async def generate_signals(self, market_data: Dict[str, Any]) -> List[TradingSignal]:
        signals = []
        
        for stock_code in self.target_stocks:
            try:
                if stock_code not in market_data:
                    continue
                
                current_data = market_data[stock_code]
                current_price = current_data['current_price']
                volume = current_data.get('volume', 0)
                
                # 과거 가격 데이터 조회
                price_history = await self.get_price_history(stock_code, days=40)
                short_ma_period = self.parameters.get('short_ma', 5)
                long_ma_period = self.parameters.get('long_ma', 20)
                
                if len(price_history) < long_ma_period + 1:
                    continue
                
                # 이동평균 계산
                short_ma = self.indicators.moving_average(price_history, short_ma_period)
                long_ma = self.indicators.moving_average(price_history, long_ma_period)
                
                if len(short_ma) < 2 or len(long_ma) < 2:
                    continue
                
                current_short_ma = short_ma[-1]
                current_long_ma = long_ma[-1]
                prev_short_ma = short_ma[-2]
                prev_long_ma = long_ma[-2]
                
                # 현재 포지션 확인
                current_position = await self.get_current_position(stock_code)
                
                # 골든크로스: 단기 이동평균이 장기 이동평균을 상향돌파
                if (current_short_ma > current_long_ma and 
                    prev_short_ma <= prev_long_ma and
                    not current_position and
                    volume > self.parameters.get('volume_threshold', 1000000)):
                    
                    quantity = self.get_position_size(stock_code, current_price)
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.BUY,
                        quantity=quantity,
                        price=current_price,
                        confidence=self.calculate_ma_confidence(current_price, current_short_ma, current_long_ma),
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"골든크로스 매수 신호: {stock_code} @ {current_price}")
                
                # 데드크로스: 단기 이동평균이 장기 이동평균을 하향돌파
                elif (current_position and 
                      current_short_ma < current_long_ma and 
                      prev_short_ma >= prev_long_ma):
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.8,
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"데드크로스 매도 신호: {stock_code} @ {current_price}")
                
                # 손절 체크
                elif current_position and self.should_stop_loss(current_position, current_price):
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.9,
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
            except Exception as e:
                logger.error(f"이동평균 전략 오류 {stock_code}: {e}")
        
        return signals
    
    def calculate_ma_confidence(self, current_price: float, short_ma: float, long_ma: float) -> float:
        """이동평균 기반 신뢰도 계산"""
        # 현재가가 두 이동평균보다 높고, 이동평균간 간격이 클수록 신뢰도 높음
        if current_price > short_ma > long_ma:
            gap_ratio = (short_ma - long_ma) / long_ma
            return min(0.95, 0.6 + gap_ratio * 10)
        return 0.5

class StrategyManager:
    """전략 관리자"""
    
    def __init__(self):
        self.strategies = {}
        
    async def initialize(self):
        """전략 매니저 초기화"""
        try:
            # 데이터베이스에서 활성 전략 로드
            with get_db_session() as db:
                active_strategies = db.query(Strategy).filter(Strategy.is_active == True).all()
                
                for strategy_config in active_strategies:
                    strategy = self.create_strategy(strategy_config)
                    if strategy:
                        self.strategies[strategy_config.id] = strategy
                        logger.info(f"전략 초기화: {strategy_config.name}")
            
        except Exception as e:
            logger.error(f"전략 매니저 초기화 실패: {e}")
            raise
    
    def create_strategy(self, strategy_config: Strategy) -> Optional[BaseStrategy]:
        """전략 타입에 따른 전략 인스턴스 생성"""
        try:
            strategy_map = {
                "bollinger_bands": BollingerBandStrategy,
                "rsi_reversal": RSIReversalStrategy,
                "momentum": MomentumStrategy,
                "moving_average": MovingAverageStrategy
            }
            
            strategy_class = strategy_map.get(strategy_config.strategy_type)
            if strategy_class:
                return strategy_class(strategy_config)
            else:
                logger.warning(f"알 수 없는 전략 타입: {strategy_config.strategy_type}")
                return None
                
        except Exception as e:
            logger.error(f"전략 생성 실패 {strategy_config.name}: {e}")
            return None
    
    async def generate_signals(self, strategy_id: int, market_data: Dict[str, Any]) -> List[TradingSignal]:
        """특정 전략의 신호 생성"""
        try:
            if strategy_id not in self.strategies:
                return []
            
            strategy = self.strategies[strategy_id]
            signals = await strategy.generate_signals(market_data)
            
            return signals
            
        except Exception as e:
            logger.error(f"신호 생성 실패 {strategy_id}: {e}")
            return []
    
    async def add_strategy(self, strategy_config: Strategy):
        """새 전략 추가"""
        strategy = self.create_strategy(strategy_config)
        if strategy:
            self.strategies[strategy_config.id] = strategy
            logger.info(f"새 전략 추가: {strategy_config.name}")
    
    async def remove_strategy(self, strategy_id: int):
        """전략 제거"""
        if strategy_id in self.strategies:
            strategy_name = self.strategies[strategy_id].name
            del self.strategies[strategy_id]
            logger.info(f"전략 제거: {strategy_name}")
    
    async def update_strategy(self, strategy_config: Strategy):
        """전략 업데이트"""
        # 기존 전략 제거 후 새로 추가
        await self.remove_strategy(strategy_config.id)
        await self.add_strategy(strategy_config)


==================================================
File: C:\Aproject\test\quant_actual\backend\trading\__init__.py
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\backend\utils\config.py
==================================================
# file: backend/utils/config.py

import os
import json
from pathlib import Path
from typing import Dict, Any, Optional
from pydantic_settings import BaseSettings
from pydantic import Field
import logging

logger = logging.getLogger(__name__)

class Settings(BaseSettings):
    """애플리케이션 설정"""
    
    # 애플리케이션 기본 설정
    app_name: str = "QuanTrade Pro"
    app_version: str = "1.0.0"
    debug: bool = False
    environment: str = Field(default="development", description="Environment (development, production)")
    
    # 서버 설정
    host: str = "0.0.0.0"
    port: int = 8000
    reload: bool = True
    
    # 데이터베이스 설정
    database_url: str = "sqlite:///./data/quantrade.db"
    database_echo: bool = False
    
    # 키움 API 설정
    kiwoom_server_type: str = "DEMO"  # DEMO or REAL
    kiwoom_account: str = ""
    kiwoom_password: str = ""
    kiwoom_cert_password: str = ""
    
    # 트레이딩 설정
    initial_capital: float = 50000000.0  # 5천만원
    max_daily_loss: float = -0.02  # -2%
    max_position_size: float = 0.05  # 5%
    max_positions: int = 10
    emergency_sell_all: bool = False
    
    # 리스크 관리 설정
    risk_daily_loss_limit: float = -0.02
    risk_position_size_limit: float = 0.05
    risk_max_positions: int = 10
    risk_max_single_stock_weight: float = 0.15
    risk_max_sector_weight: float = 0.30
    
    # 알림 설정
    email_enabled: bool = False
    email_smtp_server: str = ""
    email_smtp_port: int = 587
    email_username: str = ""
    email_password: str = ""
    email_recipients: list = []
    
    slack_enabled: bool = False
    slack_webhook_url: str = ""
    slack_channel: str = "#trading"
    
    # 로깅 설정
    log_level: str = "INFO"
    log_file: str = "logs/quantrade.log"
    log_max_size: int = 10485760  # 10MB
    log_backup_count: int = 5
    
    # 시장 시간 설정
    market_open_time: str = "09:00"
    market_close_time: str = "15:30"
    market_timezone: str = "Asia/Seoul"
    
    # 백테스트 설정
    backtest_initial_capital: float = 10000000.0  # 1천만원
    backtest_commission_rate: float = 0.00015  # 0.015%
    backtest_slippage: float = 0.001  # 0.1%
    
    # 캐시 설정
    redis_url: str = "redis://localhost:6379"
    cache_ttl: int = 300  # 5분
    
    # 보안 설정
    secret_key: str = "your-secret-key-here"
    access_token_expire_minutes: int = 1440  # 24시간
    
    # API 제한 설정
    rate_limit_per_minute: int = 60
    max_concurrent_requests: int = 10
    
    class Config:
        env_file = ".env"
        case_sensitive = False

class ConfigManager:
    """설정 관리자"""
    
    def __init__(self, config_dir: str = "config"):
        self.config_dir = Path(config_dir)
        self.config_dir.mkdir(exist_ok=True)
        
        self.settings = Settings()
        self.strategy_configs = {}
        self.risk_configs = {}
        
        # 설정 파일 로드
        self.load_all_configs()
    
    def load_all_configs(self):
        """모든 설정 파일 로드"""
        try:
            self.load_strategy_configs()
            self.load_risk_configs()
            logger.info("모든 설정 파일 로드 완료")
        except Exception as e:
            logger.error(f"설정 파일 로드 실패: {e}")
    
    def load_strategy_configs(self):
        """전략 설정 로드"""
        try:
            config_file = self.config_dir / "strategies.json"
            
            if config_file.exists():
                with open(config_file, 'r', encoding='utf-8') as f:
                    self.strategy_configs = json.load(f)
            else:
                # 기본 전략 설정 생성
                self.strategy_configs = self.get_default_strategy_configs()
                self.save_strategy_configs()
            
            logger.info(f"전략 설정 로드 완료: {len(self.strategy_configs)}개")
            
        except Exception as e:
            logger.error(f"전략 설정 로드 실패: {e}")
            self.strategy_configs = self.get_default_strategy_configs()
    
    def load_risk_configs(self):
        """리스크 설정 로드"""
        try:
            config_file = self.config_dir / "risk_limits.json"
            
            if config_file.exists():
                with open(config_file, 'r', encoding='utf-8') as f:
                    self.risk_configs = json.load(f)
            else:
                # 기본 리스크 설정 생성
                self.risk_configs = self.get_default_risk_configs()
                self.save_risk_configs()
            
            logger.info("리스크 설정 로드 완료")
            
        except Exception as e:
            logger.error(f"리스크 설정 로드 실패: {e}")
            self.risk_configs = self.get_default_risk_configs()
    
    def get_default_strategy_configs(self) -> Dict[str, Any]:
        """기본 전략 설정 반환"""
        return {
            "bollinger_bands": {
                "name": "볼린저밴드 평균회귀",
                "enabled": True,
                "parameters": {
                    "period": 20,
                    "std_multiplier": 2.0,
                    "stop_loss": 0.05,
                    "take_profit": 0.03,
                    "min_volume": 100000
                },
                "target_stocks": ["005930", "000660", "035420"],
                "investment_amount": 10000000,
                "max_position_size": 0.05,
                "confidence_threshold": 0.6
            },
            "rsi_reversal": {
                "name": "RSI 역추세",
                "enabled": True,
                "parameters": {
                    "period": 14,
                    "oversold": 30,
                    "overbought": 70,
                    "stop_loss": 0.04,
                    "min_rsi_change": 2
                },
                "target_stocks": ["035720", "051910"],
                "investment_amount": 8000000,
                "max_position_size": 0.04,
                "confidence_threshold": 0.7
            },
            "momentum": {
                "name": "모멘텀 추세추종",
                "enabled": False,
                "parameters": {
                    "short_period": 12,
                    "long_period": 26,
                    "signal_period": 9,
                    "volume_threshold": 1.2,
                    "trend_strength_min": 0.6
                },
                "target_stocks": ["006400", "207940"],
                "investment_amount": 5000000,
                "max_position_size": 0.03,
                "confidence_threshold": 0.8
            },
            "moving_average": {
                "name": "이동평균 골든크로스",
                "enabled": False,
                "parameters": {
                    "short_ma": 5,
                    "long_ma": 20,
                    "volume_threshold": 1000000,
                    "confirmation_period": 3
                },
                "target_stocks": ["373220"],
                "investment_amount": 3000000,
                "max_position_size": 0.02,
                "confidence_threshold": 0.7
            }
        }
    
    def get_default_risk_configs(self) -> Dict[str, Any]:
        """기본 리스크 설정 반환"""
        return {
            "daily_limits": {
                "max_daily_loss": -0.02,
                "max_daily_trades": 50,
                "max_daily_volume": 100000000
            },
            "position_limits": {
                "max_position_size": 0.05,
                "max_positions": 10,
                "max_single_stock_weight": 0.15,
                "max_sector_weight": 0.30
            },
            "volatility_limits": {
                "max_portfolio_volatility": 0.25,
                "high_volatility_threshold": 0.40,
                "volatility_adjustment": True
            },
            "correlation_limits": {
                "max_correlation": 0.70,
                "correlation_check_enabled": True,
                "correlation_period": 60
            },
            "drawdown_limits": {
                "max_drawdown": 0.15,
                "drawdown_alert_level": 0.10,
                "recovery_time_limit": 30
            },
            "emergency_settings": {
                "auto_stop_on_loss": True,
                "emergency_sell_enabled": False,
                "circuit_breaker_level": -0.08,
                "flash_crash_level": -0.05
            }
        }
    
    def save_strategy_configs(self):
        """전략 설정 저장"""
        try:
            config_file = self.config_dir / "strategies.json"
            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(self.strategy_configs, f, indent=2, ensure_ascii=False)
            logger.info("전략 설정 저장 완료")
        except Exception as e:
            logger.error(f"전략 설정 저장 실패: {e}")
    
    def save_risk_configs(self):
        """리스크 설정 저장"""
        try:
            config_file = self.config_dir / "risk_limits.json"
            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(self.risk_configs, f, indent=2, ensure_ascii=False)
            logger.info("리스크 설정 저장 완료")
        except Exception as e:
            logger.error(f"리스크 설정 저장 실패: {e}")
    
    def get_strategy_config(self, strategy_name: str) -> Optional[Dict[str, Any]]:
        """특정 전략 설정 조회"""
        return self.strategy_configs.get(strategy_name)
    
    def update_strategy_config(self, strategy_name: str, config: Dict[str, Any]):
        """전략 설정 업데이트"""
        try:
            self.strategy_configs[strategy_name] = config
            self.save_strategy_configs()
            logger.info(f"전략 설정 업데이트: {strategy_name}")
        except Exception as e:
            logger.error(f"전략 설정 업데이트 실패: {e}")
    
    def get_risk_config(self, category: str = None) -> Dict[str, Any]:
        """리스크 설정 조회"""
        if category:
            return self.risk_configs.get(category, {})
        return self.risk_configs
    
    def update_risk_config(self, category: str, config: Dict[str, Any]):
        """리스크 설정 업데이트"""
        try:
            self.risk_configs[category] = config
            self.save_risk_configs()
            logger.info(f"리스크 설정 업데이트: {category}")
        except Exception as e:
            logger.error(f"리스크 설정 업데이트 실패: {e}")
    
    def get_market_config(self) -> Dict[str, Any]:
        """시장 설정 조회"""
        return {
            "open_time": self.settings.market_open_time,
            "close_time": self.settings.market_close_time,
            "timezone": self.settings.market_timezone,
            "trading_days": ["monday", "tuesday", "wednesday", "thursday", "friday"]
        }
    
    def get_api_config(self) -> Dict[str, Any]:
        """API 설정 조회"""
        return {
            "kiwoom": {
                "server_type": self.settings.kiwoom_server_type,
                "account": self.settings.kiwoom_account,
                # 비밀번호는 보안상 반환하지 않음
            },
            "rate_limit": self.settings.rate_limit_per_minute,
            "max_concurrent": self.settings.max_concurrent_requests
        }
    
    def get_notification_config(self) -> Dict[str, Any]:
        """알림 설정 조회"""
        return {
            "email": {
                "enabled": self.settings.email_enabled,
                "recipients": self.settings.email_recipients,
                "smtp_server": self.settings.email_smtp_server,
                "smtp_port": self.settings.email_smtp_port
            },
            "slack": {
                "enabled": self.settings.slack_enabled,
                "channel": self.settings.slack_channel
            }
        }
    
    def validate_config(self) -> Dict[str, Any]:
        """설정 유효성 검사"""
        validation_result = {
            "valid": True,
            "errors": [],
            "warnings": []
        }
        
        try:
            # 필수 설정 체크
            if not self.settings.secret_key or self.settings.secret_key == "your-secret-key-here":
                validation_result["errors"].append("SECRET_KEY가 설정되지 않음")
                validation_result["valid"] = False
            
            # 트레이딩 설정 체크
            if self.settings.max_daily_loss >= 0:
                validation_result["errors"].append("일일 손실 한도는 음수여야 함")
                validation_result["valid"] = False
            
            if self.settings.max_position_size <= 0 or self.settings.max_position_size > 1:
                validation_result["errors"].append("포지션 크기 한도는 0과 1 사이여야 함")
                validation_result["valid"] = False
            
            # 전략 설정 체크
            active_strategies = [name for name, config in self.strategy_configs.items() if config.get("enabled")]
            if not active_strategies:
                validation_result["warnings"].append("활성화된 전략이 없음")
            
            # 투자 금액 체크
            total_investment = sum(
                config.get("investment_amount", 0) 
                for config in self.strategy_configs.values() 
                if config.get("enabled")
            )
            
            if total_investment > self.settings.initial_capital:
                validation_result["warnings"].append(
                    f"전략별 투자금액 합계({total_investment:,})가 초기 자본({self.settings.initial_capital:,})을 초과"
                )
            
            # 리스크 설정 체크
            risk_limits = self.risk_configs.get("position_limits", {})
            if risk_limits.get("max_single_stock_weight", 0) > risk_limits.get("max_sector_weight", 1):
                validation_result["warnings"].append("개별 종목 한도가 섹터 한도보다 큼")
            
        except Exception as e:
            validation_result["errors"].append(f"설정 검증 중 오류: {e}")
            validation_result["valid"] = False
        
        return validation_result
    
    def export_config(self, file_path: str):
        """설정을 파일로 내보내기"""
        try:
            export_data = {
                "app_settings": {
                    "app_name": self.settings.app_name,
                    "version": self.settings.app_version,
                    "environment": self.settings.environment,
                    "initial_capital": self.settings.initial_capital
                },
                "trading_settings": {
                    "max_daily_loss": self.settings.max_daily_loss,
                    "max_position_size": self.settings.max_position_size,
                    "max_positions": self.settings.max_positions,
                    "emergency_sell_all": self.settings.emergency_sell_all
                },
                "market_settings": {
                    "open_time": self.settings.market_open_time,
                    "close_time": self.settings.market_close_time,
                    "timezone": self.settings.market_timezone
                },
                "strategies": self.strategy_configs,
                "risk_limits": self.risk_configs,
                "export_timestamp": datetime.now().isoformat()
            }
            
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, indent=2, ensure_ascii=False)
            
            logger.info(f"설정 내보내기 완료: {file_path}")
            
        except Exception as e:
            logger.error(f"설정 내보내기 실패: {e}")
            raise
    
    def import_config(self, file_path: str):
        """파일에서 설정 가져오기"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                import_data = json.load(f)
            
            # 설정 복원
            if "strategies" in import_data:
                self.strategy_configs = import_data["strategies"]
                self.save_strategy_configs()
            
            if "risk_limits" in import_data:
                self.risk_configs = import_data["risk_limits"]
                self.save_risk_configs()
            
            logger.info(f"설정 가져오기 완료: {file_path}")
            
        except Exception as e:
            logger.error(f"설정 가져오기 실패: {e}")
            raise
    
    def reset_to_defaults(self):
        """기본 설정으로 초기화"""
        try:
            self.strategy_configs = self.get_default_strategy_configs()
            self.risk_configs = self.get_default_risk_configs()
            
            self.save_strategy_configs()
            self.save_risk_configs()
            
            logger.info("설정이 기본값으로 초기화됨")
            
        except Exception as e:
            logger.error(f"설정 초기화 실패: {e}")
            raise

class EnvironmentManager:
    """환경별 설정 관리"""
    
    def __init__(self):
        self.current_env = os.getenv("ENVIRONMENT", "development")
    
    def get_database_url(self) -> str:
        """환경별 데이터베이스 URL"""
        if self.current_env == "production":
            return os.getenv("DATABASE_URL", "postgresql://user:pass@localhost/quantrade_prod")
        elif self.current_env == "testing":
            return "sqlite:///:memory:"
        else:  # development
            return "sqlite:///./data/quantrade_dev.db"
    
    def get_log_level(self) -> str:
        """환경별 로그 레벨"""
        env_log_levels = {
            "production": "WARNING",
            "development": "DEBUG",
            "testing": "ERROR"
        }
        return env_log_levels.get(self.current_env, "INFO")
    
    def is_debug_mode(self) -> bool:
        """디버그 모드 여부"""
        return self.current_env == "development"
    
    def get_api_rate_limit(self) -> int:
        """환경별 API 요청 제한"""
        if self.current_env == "production":
            return 30  # 분당 30회
        else:
            return 100  # 개발/테스트 환경에서는 더 많이 허용

class ConfigValidator:
    """설정 유효성 검증 클래스"""
    
    @staticmethod
    def validate_strategy_config(config: Dict[str, Any]) -> Dict[str, Any]:
        """전략 설정 유효성 검사"""
        result = {"valid": True, "errors": []}
        
        # 필수 필드 체크
        required_fields = ["name", "parameters", "target_stocks", "investment_amount"]
        for field in required_fields:
            if field not in config:
                result["errors"].append(f"필수 필드 누락: {field}")
                result["valid"] = False
        
        # 투자 금액 체크
        investment_amount = config.get("investment_amount", 0)
        if investment_amount <= 0:
            result["errors"].append("투자 금액은 0보다 커야 함")
            result["valid"] = False
        
        # 대상 종목 체크
        target_stocks = config.get("target_stocks", [])
        if not target_stocks:
            result["errors"].append("대상 종목이 없음")
            result["valid"] = False
        
        return result
    
    @staticmethod
    def validate_risk_config(config: Dict[str, Any]) -> Dict[str, Any]:
        """리스크 설정 유효성 검사"""
        result = {"valid": True, "errors": []}
        
        # 손실 한도 체크
        daily_loss = config.get("daily_limits", {}).get("max_daily_loss", 0)
        if daily_loss >= 0:
            result["errors"].append("일일 손실 한도는 음수여야 함")
            result["valid"] = False
        
        # 포지션 한도 체크
        position_limits = config.get("position_limits", {})
        max_position_size = position_limits.get("max_position_size", 0)
        
        if max_position_size <= 0 or max_position_size > 1:
            result["errors"].append("포지션 크기 한도는 0과 1 사이여야 함")
            result["valid"] = False
        
        return result

# 전역 설정 인스턴스
_config_manager = None
_settings = None

def get_config_manager() -> ConfigManager:
    """설정 관리자 싱글톤"""
    global _config_manager
    if _config_manager is None:
        _config_manager = ConfigManager()
    return _config_manager

def get_settings() -> Settings:
    """설정 싱글톤"""
    global _settings
    if _settings is None:
        _settings = Settings()
    return _settings

def reload_config():
    """설정 다시 로드"""
    global _config_manager, _settings
    _config_manager = None
    _settings = None
    logger.info("설정이 다시 로드됨")

# 환경별 설정 로드
def load_environment_config():
    """환경별 설정 로드"""
    env_manager = EnvironmentManager()
    settings = get_settings()
    
    # 환경별 설정 적용
    if hasattr(settings, 'database_url'):
        settings.database_url = env_manager.get_database_url()
    
    settings.debug = env_manager.is_debug_mode()
    settings.log_level = env_manager.get_log_level()
    
    return settings 



==================================================
File: C:\Aproject\test\quant_actual\backend\utils\logger.py
==================================================
# file: backend/utils/logger.py

import logging
import logging.handlers
import sys
from pathlib import Path
from typing import Optional
from datetime import datetime
import json
import traceback

class ColoredFormatter(logging.Formatter):
    """컬러 로그 포매터"""
    
    # 색상 코드
    COLORS = {
        'DEBUG': '\033[36m',     # 청록
        'INFO': '\033[32m',      # 녹색
        'WARNING': '\033[33m',   # 노란색
        'ERROR': '\033[31m',     # 빨간색
        'CRITICAL': '\033[35m',  # 자홍색
        'RESET': '\033[0m'       # 리셋
    }
    
    def format(self, record):
        # 기본 포맷팅
        log_message = super().format(record)
        
        # 색상 적용
        color = self.COLORS.get(record.levelname, self.COLORS['RESET'])
        reset = self.COLORS['RESET']
        
        return f"{color}{log_message}{reset}"

class JSONFormatter(logging.Formatter):
    """JSON 로그 포매터"""
    
    def format(self, record):
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'level': record.levelname,
            'logger': record.name,
            'message': record.getMessage(),
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno,
            'process_id': record.process,
            'thread_id': record.thread
        }
        
        # 예외 정보 추가
        if record.exc_info:
            log_data['exception'] = {
                'type': record.exc_info[0].__name__,
                'message': str(record.exc_info[1]),
                'traceback': traceback.format_exception(*record.exc_info)
            }
        
        # 추가 컨텍스트 정보
        if hasattr(record, 'extra_data'):
            log_data['extra'] = record.extra_data
        
        return json.dumps(log_data, ensure_ascii=False)

class TradingLogFilter(logging.Filter):
    """트레이딩 관련 로그 필터"""
    
    def __init__(self, include_trading_only=False):
        super().__init__()
        self.include_trading_only = include_trading_only
        
        # 트레이딩 관련 모듈 목록
        self.trading_modules = [
            'trading.engine',
            'trading.strategies', 
            'trading.risk_manager',
            'data.kiwoom_mock',
            'api'
        ]
    
    def filter(self, record):
        is_trading_log = any(
            module in record.name 
            for module in self.trading_modules
        )
        
        if self.include_trading_only:
            return is_trading_log
        else:
            return True  # 모든 로그 허용

class DatabaseLogHandler(logging.Handler):
    """데이터베이스 로그 핸들러"""
    
    def __init__(self, db_session_factory=None):
        super().__init__()
        self.db_session_factory = db_session_factory
    
    def emit(self, record):
        try:
            if not self.db_session_factory:
                return
            
            # 로그 레코드를 데이터베이스에 저장
            # 실제 구현에서는 LogEntry 모델 사용
            log_entry = {
                'timestamp': datetime.utcnow(),
                'level': record.levelname,
                'logger_name': record.name,
                'message': record.getMessage(),
                'module': record.module,
                'function_name': record.funcName,
                'line_number': record.lineno,
                'exception_info': self.format(record) if record.exc_info else None
            }
            
            # 실제 DB 저장 로직은 여기에 구현
            # with self.db_session_factory() as session:
            #     session.add(LogEntry(**log_entry))
            #     session.commit()
            
        except Exception as e:
            # 로깅 오류는 무시 (무한 루프 방지)
            print(f"Database logging error: {e}", file=sys.stderr)

def setup_logger(
    name: Optional[str] = None,
    level: str = "INFO",
    log_file: Optional[str] = None,
    max_size: int = 10485760,  # 10MB
    backup_count: int = 5,
    use_colors: bool = True,
    json_format: bool = False,
    include_trading_only: bool = False
) -> logging.Logger:
    """로거 설정"""
    
    logger = logging.getLogger(name)
    
    # 기존 핸들러 제거 (중복 방지)
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)
    
    # 로그 레벨 설정
    logger.setLevel(getattr(logging, level.upper()))
    
    # 포매터 선택
    if json_format:
        formatter = JSONFormatter()
    elif use_colors and sys.stderr.isatty():
        formatter = ColoredFormatter(
            fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
    else:
        formatter = logging.Formatter(
            fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
    
    # 콘솔 핸들러
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    
    # 트레이딩 로그 필터 적용
    if include_trading_only:
        trading_filter = TradingLogFilter(include_trading_only=True)
        console_handler.addFilter(trading_filter)
    
    logger.addHandler(console_handler)
    
    # 파일 핸들러 (선택적)
    if log_file:
        log_path = Path(log_file)
        log_path.parent.mkdir(parents=True, exist_ok=True)
        
        # 로테이팅 파일 핸들러
        file_handler = logging.handlers.RotatingFileHandler(
            filename=log_file,
            maxBytes=max_size,
            backupCount=backup_count,
            encoding='utf-8'
        )
        
        # 파일은 항상 JSON 포맷 사용
        file_formatter = JSONFormatter() if json_format else logging.Formatter(
            fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        file_handler.setFormatter(file_formatter)
        
        logger.addHandler(file_handler)
    
    return logger

class LoggerManager:
    """로거 관리자"""
    
    def __init__(self):
        self.loggers = {}
        self.handlers = {}
        
        # 기본 로그 디렉토리 생성
        self.log_dir = Path("logs")
        self.log_dir.mkdir(exist_ok=True)
    
    def get_logger(
        self, 
        name: str, 
        level: str = "INFO",
        log_file: Optional[str] = None,
        **kwargs
    ) -> logging.Logger:
        """로거 생성 또는 반환"""
        
        if name not in self.loggers:
            if log_file:
                log_file = self.log_dir / log_file
            
            logger = setup_logger(
                name=name,
                level=level,
                log_file=str(log_file) if log_file else None,
                **kwargs
            )
            
            self.loggers[name] = logger
        
        return self.loggers[name]
    
    def get_trading_logger(self) -> logging.Logger:
        """트레이딩 전용 로거"""
        return self.get_logger(
            name="trading",
            level="INFO",
            log_file="trading.log",
            include_trading_only=True
        )
    
    def get_api_logger(self) -> logging.Logger:
        """API 전용 로거"""
        return self.get_logger(
            name="api",
            level="INFO", 
            log_file="api.log"
        )
    
    def get_error_logger(self) -> logging.Logger:
        """오류 전용 로거"""
        error_logger = self.get_logger(
            name="errors",
            level="ERROR",
            log_file="errors.log",
            json_format=True
        )
        
        # 오류 로거는 ERROR 레벨 이상만 기록
        error_logger.setLevel(logging.ERROR)
        
        return error_logger
    
    def setup_application_logging(self, config=None):
        """애플리케이션 전체 로깅 설정"""
        from utils.config import get_settings
        
        settings = get_settings() if not config else config
        
        # 루트 로거 설정
        root_logger = setup_logger(
            name=None,
            level=settings.log_level,
            log_file=settings.log_file,
            max_size=settings.log_max_size,
            backup_count=settings.log_backup_count,
            use_colors=settings.debug,
            json_format=not settings.debug
        )
        
        # 모듈별 로거 설정
        module_loggers = [
            ("trading.engine", "INFO", "trading_engine.log"),
            ("trading.strategies", "INFO", "strategies.log"),
            ("trading.risk_manager", "WARNING", "risk.log"),
            ("data.kiwoom_mock", "INFO", "kiwoom.log"),
            ("database", "WARNING", "database.log"),
            ("api", "INFO", "api.log")
        ]
        
        for module_name, level, log_file in module_loggers:
            self.get_logger(
                name=module_name,
                level=level,
                log_file=log_file
            )
        
        # 외부 라이브러리 로깅 레벨 조정
        logging.getLogger("uvicorn").setLevel(logging.WARNING)
        logging.getLogger("fastapi").setLevel(logging.WARNING)
        logging.getLogger("sqlalchemy.engine").setLevel(logging.WARNING)
        
        return root_logger
    
    def add_performance_logging(self):
        """성능 로깅 추가"""
        perf_logger = self.get_logger(
            name="performance",
            level="INFO",
            log_file="performance.log",
            json_format=True
        )
        
        return perf_logger
    
    def add_audit_logging(self):
        """감사 로깅 추가 (중요한 거래 활동 기록)"""
        audit_logger = self.get_logger(
            name="audit",
            level="INFO",
            log_file="audit.log",
            json_format=True
        )
        
        # 감사 로그는 별도 포매터 사용
        audit_formatter = logging.Formatter(
            fmt='%(asctime)s [AUDIT] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        for handler in audit_logger.handlers:
            if isinstance(handler, logging.FileHandler):
                handler.setFormatter(audit_formatter)
        
        return audit_logger

class AuditLogger:
    """감사 로깅 전용 클래스"""
    
    def __init__(self, logger_manager: LoggerManager):
        self.audit_logger = logger_manager.add_audit_logging()
    
    def log_order(self, order_data: dict):
        """주문 로깅"""
        self.audit_logger.info(
            f"ORDER - {order_data.get('action', 'UNKNOWN')} "
            f"{order_data.get('stock_code', 'N/A')} "
            f"{order_data.get('quantity', 0)} shares "
            f"@ {order_data.get('price', 0)} "
            f"({order_data.get('strategy', 'manual')})"
        )
    
    def log_trade(self, trade_data: dict):
        """거래 체결 로깅"""
        self.audit_logger.info(
            f"TRADE - {trade_data.get('action', 'UNKNOWN')} "
            f"{trade_data.get('stock_code', 'N/A')} "
            f"{trade_data.get('quantity', 0)} shares "
            f"@ {trade_data.get('price', 0)} "
            f"PnL: {trade_data.get('pnl', 0)}"
        )
    
    def log_risk_event(self, event_type: str, details: dict):
        """리스크 이벤트 로깅"""
        self.audit_logger.warning(
            f"RISK_EVENT - {event_type}: {details}"
        )
    
    def log_system_event(self, event_type: str, details: dict):
        """시스템 이벤트 로깅"""
        self.audit_logger.info(
            f"SYSTEM - {event_type}: {details}"
        )

class PerformanceLogger:
    """성능 로깅 전용 클래스"""
    
    def __init__(self, logger_manager: LoggerManager):
        self.perf_logger = logger_manager.add_performance_logging()
    
    def log_execution_time(self, function_name: str, execution_time: float, **kwargs):
        """함수 실행 시간 로깅"""
        self.perf_logger.info(
            f"PERFORMANCE - {function_name}: {execution_time:.4f}s",
            extra={'extra_data': {'execution_time': execution_time, **kwargs}}
        )
    
    def log_memory_usage(self, context: str, memory_mb: float):
        """메모리 사용량 로깅"""
        self.perf_logger.info(
            f"MEMORY - {context}: {memory_mb:.2f}MB",
            extra={'extra_data': {'memory_mb': memory_mb}}
        )
    
    def log_api_response_time(self, endpoint: str, response_time: float, status_code: int):
        """API 응답 시간 로깅"""
        self.perf_logger.info(
            f"API - {endpoint}: {response_time:.4f}s (status: {status_code})",
            extra={'extra_data': {
                'endpoint': endpoint,
                'response_time': response_time,
                'status_code': status_code
            }}
        )

def performance_monitor(func):
    """성능 모니터링 데코레이터"""
    import time
    import functools
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        
        try:
            result = func(*args, **kwargs)
            execution_time = time.time() - start_time
            
            # 성능 로그 기록
            perf_logger = logging.getLogger("performance")
            perf_logger.info(
                f"Function {func.__name__} executed in {execution_time:.4f}s"
            )
            
            return result
            
        except Exception as e:
            execution_time = time.time() - start_time
            
            # 오류와 함께 성능 정보 기록
            error_logger = logging.getLogger("errors")
            error_logger.error(
                f"Function {func.__name__} failed after {execution_time:.4f}s: {e}",
                exc_info=True
            )
            
            raise
    
    return wrapper

# 전역 로거 매니저
_logger_manager = None

def get_logger_manager() -> LoggerManager:
    """로거 매니저 싱글톤"""
    global _logger_manager
    if _logger_manager is None:
        _logger_manager = LoggerManager()
    return _logger_manager

def get_logger(name: str = None) -> logging.Logger:
    """편의 함수: 로거 반환"""
    if name:
        return logging.getLogger(name)
    else:
        return logging.getLogger()

# 애플리케이션 시작 시 호출
def initialize_logging():
    """로깅 시스템 초기화"""
    logger_manager = get_logger_manager()
    return logger_manager.setup_application_logging() 



==================================================
File: C:\Aproject\test\quant_actual\backend\utils\__init__.py
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\next.config.js
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\tailwind.config.js
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\app\layout.tsx
==================================================
# layout.tsx

import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'QuanTrade Pro - 퀀트 자동매매 시스템',
  description: '실시간 퀀트 자동매매 대시보드',
  keywords: '퀀트, 자동매매, 주식, 트레이딩, 대시보드',
  authors: [{ name: 'QuanTrade Team' }],
  viewport: 'width=device-width, initial-scale=1',
  robots: 'noindex, nofollow', // 보안상 검색엔진 차단
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="ko" className="dark">
      <head>
        <meta name="theme-color" content="#111827" />
        <link rel="icon" href="/favicon.ico" />
      </head>
      <body className={`${inter.className} bg-gray-900 text-white antialiased`}>
        <div id="root">
          {children}
        </div>
      </body>
    </html>
  )
} 



==================================================
File: C:\Aproject\test\quant_actual\frontend\app\page.tsx
==================================================
'use client'

import { useEffect, useState } from 'react'
import { formatCurrency, formatPercentage, getCurrentTime } from '@/lib/utils'

interface PortfolioData {
  total_value: number
  cash: number
  invested_amount: number
  realized_pnl: number
  unrealized_pnl: number
  daily_pnl: number
  total_return: number
  timestamp: string
}

interface Position {
  id: number
  strategy_name: string
  stock_code: string
  stock_name: string
  quantity: number
  avg_price: number
  current_price: number
  unrealized_pnl: number
  realized_pnl: number
}

interface Order {
  id: number
  strategy_id: number
  stock_code: string
  stock_name: string
  order_type: string
  quantity: number
  price: number
  status: string
  order_time: string
  fill_time?: string
  fill_price?: number
}

interface Strategy {
  id: number
  name: string
  strategy_type: string
  is_active: boolean
  investment_amount: number
  target_stocks: string[]
  parameters: Record<string, any>
}

export default function DashboardPage() {
  const [portfolio, setPortfolio] = useState<PortfolioData | null>(null)
  const [positions, setPositions] = useState<Position[]>([])
  const [orders, setOrders] = useState<Order[]>([])
  const [strategies, setStrategies] = useState<Strategy[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [lastUpdate, setLastUpdate] = useState<string>('')
  const [isConnected, setIsConnected] = useState(true)
  const [tradingStatus, setTradingStatus] = useState('stopped')

  // 실시간 데이터 업데이트
  useEffect(() => {
    const fetchData = async () => {
      try {
        // 포트폴리오 데이터
        const portfolioRes = await fetch('/api/proxy/portfolio')
        const portfolioData = await portfolioRes.json()
        setPortfolio(portfolioData)

        // 포지션 데이터
        const positionsRes = await fetch('/api/proxy/portfolio/positions')
        const positionsData = await positionsRes.json()
        setPositions(positionsData)

        // 주문 내역
        const ordersRes = await fetch('/api/proxy/orders?limit=10')
        const ordersData = await ordersRes.json()
        setOrders(ordersData)

        // 전략 목록
        const strategiesRes = await fetch('/api/proxy/strategies')
        const strategiesData = await strategiesRes.json()
        setStrategies(strategiesData)

        // 시스템 상태
        const statusRes = await fetch('/api/proxy/system/status')
        const statusData = await statusRes.json()
        setIsConnected(statusData.api_connected)
        setTradingStatus(statusData.is_running ? 'running' : 'stopped')

        setLastUpdate(getCurrentTime())
        setError(null)
      } catch (err) {
        setError('데이터 로드 실패')
        console.error('Data fetch error:', err)
      } finally {
        setIsLoading(false)
      }
    }

    // 초기 로드
    fetchData()

    // 실시간 업데이트 (1초마다)
    const interval = setInterval(fetchData, 1000)
    return () => clearInterval(interval)
  }, [])

  // 전략 토글
  const toggleStrategy = async (strategyId: number) => {
    try {
      const strategy = strategies.find(s => s.id === strategyId)
      if (!strategy) return

      const response = await fetch('/api/proxy/strategies/toggle', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          id: strategyId,
          active: !strategy.is_active
        })
      })

      if (response.ok) {
        setStrategies(prev =>
          prev.map(s =>
            s.id === strategyId ? { ...s, is_active: !s.is_active } : s
          )
        )
      }
    } catch (error) {
      console.error('전략 토글 실패:', error)
    }
  }

  // 트레이딩 제어
  const startTrading = async () => {
    try {
      const response = await fetch('/api/proxy/trading/start', { method: 'POST' })
      if (response.ok) {
        setTradingStatus('running')
        alert('자동매매가 시작됩니다.')
      }
    } catch (error) {
      console.error('자동매매 시작 실패:', error)
    }
  }

  const stopTrading = async () => {
    try {
      const response = await fetch('/api/proxy/trading/stop', { method: 'POST' })
      if (response.ok) {
        setTradingStatus('stopped')
        alert('자동매매가 중지됩니다.')
      }
    } catch (error) {
      console.error('자동매매 중지 실패:', error)
    }
  }

  const emergencyStop = async () => {
    if (confirm('모든 주문을 취소하고 긴급중단하시겠습니까?')) {
      try {
        const response = await fetch('/api/proxy/trading/emergency-stop', { method: 'POST' })
        if (response.ok) {
          setTradingStatus('emergency_stopped')
          alert('긴급중단 실행됨')
        }
      } catch (error) {
        console.error('긴급중단 실패:', error)
      }
    }
  }

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-white text-xl">시스템 로딩 중...</div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-red-400 text-xl">{error}</div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gray-900 text-white">
      {/* 헤더 */}
      <header className="bg-gray-800 px-6 py-4 flex items-center justify-between border-b border-gray-700">
        <div className="flex items-center space-x-4">
          <h1 className="text-2xl font-bold text-green-400">QuanTrade Pro</h1>
          <div className="flex items-center space-x-2">
            <span className="text-sm">키움 API</span>
            <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-400 animate-pulse' : 'bg-red-400'}`}></div>
            <span className="text-sm">{isConnected ? '연결됨' : '연결 끊김'}</span>
          </div>
        </div>

        <div className="flex items-center space-x-2">
          <span className="text-sm text-gray-400">마지막 업데이트: {lastUpdate}</span>
        </div>

        <div className="flex space-x-2">
          <button
            onClick={startTrading}
            disabled={tradingStatus === 'running'}
            className="bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white px-4 py-2 rounded text-sm font-medium transition-colors"
          >
            자동매매 시작
          </button>
          <button
            onClick={stopTrading}
            disabled={tradingStatus === 'stopped'}
            className="bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white px-4 py-2 rounded text-sm font-medium transition-colors"
          >
            중지
          </button>
          <button
            onClick={emergencyStop}
            className="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded text-sm font-medium animate-pulse transition-colors"
          >
            긴급중단
          </button>
        </div>
      </header>

      <div className="flex h-[calc(100vh-80px)]">
        {/* 사이드바 - 전략 관리 */}
        <div className="w-80 bg-gray-800 p-6 overflow-y-auto border-r border-gray-700">
          <h2 className="text-lg font-semibold mb-4 text-gray-300">활성 전략</h2>
          
          <div className="space-y-4">
            {strategies.map(strategy => (
              <div key={strategy.id} className="bg-gray-700 p-4 rounded-lg">
                <div className="flex items-center justify-between mb-3">
                  <h3 className="font-medium text-white">{strategy.name}</h3>
                  <button
                    onClick={() => toggleStrategy(strategy.id)}
                    className={`relative w-12 h-6 rounded-full transition-colors ${
                      strategy.is_active ? 'bg-green-500' : 'bg-gray-500'
                    }`}
                  >
                    <div
                      className={`absolute top-1 w-4 h-4 bg-white rounded-full transition-transform ${
                        strategy.is_active ? 'translate-x-7' : 'translate-x-1'
                      }`}
                    ></div>
                  </button>
                </div>
                
                <div className="text-sm text-gray-300 space-y-1">
                  <div>투자금액: {formatCurrency(strategy.investment_amount)}</div>
                  <div>대상종목: {strategy.target_stocks?.join(', ') || 'N/A'}</div>
                  <div className={`inline-block px-2 py-1 rounded text-xs ${
                    strategy.is_active 
                      ? 'bg-green-900 text-green-300' 
                      : 'bg-gray-600 text-gray-400'
                  }`}>
                    {strategy.is_active ? '활성' : '비활성'}
                  </div>
                </div>
              </div>
            ))}
          </div>

          {/* 리스크 관리 */}
          <div className="mt-8">
            <h3 className="text-lg font-semibold mb-4 text-gray-300">리스크 관리</h3>
            <div className="space-y-3 text-sm">
              <div className="flex justify-between">
                <span className="text-gray-400">일일 손실한도:</span>
                <span className="text-red-400">-2%</span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-400">포지션 크기:</span>
                <span className="text-blue-400">5%</span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-400">최대 보유종목:</span>
                <span className="text-blue-400">10개</span>
              </div>
            </div>
          </div>
        </div>

        {/* 메인 콘텐츠 */}
        <div className="flex-1 flex flex-col">
          {/* 포트폴리오 개요 */}
          <div className="bg-gray-800 p-6 border-b border-gray-700">
            <div className="grid grid-cols-4 gap-6">
              <div className="bg-gray-700 p-4 rounded-lg text-center">
                <div className="text-sm text-gray-400 mb-1">총 평가금액</div>
                <div className="text-2xl font-bold text-white">
                  {formatCurrency(portfolio?.total_value || 0)}
                </div>
                <div className="text-sm text-green-400">
                  +{formatCurrency(portfolio?.daily_pnl || 0)}
                </div>
              </div>

              <div className="bg-gray-700 p-4 rounded-lg text-center">
                <div className="text-sm text-gray-400 mb-1">실시간 손익</div>
                <div className={`text-2xl font-bold ${
                  (portfolio?.unrealized_pnl || 0) >= 0 ? 'text-green-400' : 'text-red-400'
                }`}>
                  {formatCurrency(portfolio?.unrealized_pnl || 0)}
                </div>
                <div className="text-sm text-gray-400">
                  실현: {formatCurrency(portfolio?.realized_pnl || 0)}
                </div>
              </div>

              <div className="bg-gray-700 p-4 rounded-lg text-center">
                <div className="text-sm text-gray-400 mb-1">수익률</div>
                <div className={`text-2xl font-bold ${
                  (portfolio?.total_return || 0) >= 0 ? 'text-green-400' : 'text-red-400'
                }`}>
                  {formatPercentage(portfolio?.total_return || 0)}
                </div>
                <div className="text-sm text-gray-400">
                  {(portfolio?.total_return || 0) >= 0 ? '+' : ''}{((portfolio?.daily_pnl || 0) / (portfolio?.total_value || 1) * 100).toFixed(1)}% (오늘)
                </div>
              </div>

              <div className="bg-gray-700 p-4 rounded-lg text-center">
                <div className="text-sm text-gray-400 mb-1">활성 포지션</div>
                <div className="text-2xl font-bold text-white">{positions.length}개</div>
                <div className="text-sm text-gray-400">
                  투자: {formatCurrency(portfolio?.invested_amount || 0)}
                </div>
              </div>
            </div>
          </div>

          {/* 실시간 수익 및 포지션 */}
          <div className="flex-1 flex">
            {/* 실시간 수익 현황 */}
            <div className="flex-1 p-6">
              <div className="bg-gray-700 rounded-lg p-4 h-full">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-lg font-semibold">실시간 수익 현황</h3>
                  <div className="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>
                </div>

                <div className="space-y-3 max-h-96 overflow-y-auto">
                  {positions.map(position => (
                    <div key={position.id} className="bg-gray-600 p-3 rounded flex items-center justify-between">
                      <div className="flex-1">
                        <div className="font-medium">{position.strategy_name} - {position.stock_name}</div>
                        <div className="text-sm text-gray-400">
                          {position.stock_code} | {position.quantity}주 @ {formatCurrency(position.avg_price)}
                        </div>
                      </div>
                      <div className="text-right">
                        <div className={`font-bold ${
                          position.unrealized_pnl >= 0 ? 'text-green-400' : 'text-red-400'
                        }`}>
                          {position.unrealized_pnl >= 0 ? '+' : ''}{formatCurrency(position.unrealized_pnl)}
                        </div>
                        <div className={`text-sm ${
                          position.unrealized_pnl >= 0 ? 'text-green-400' : 'text-red-400'
                        }`}>
                          {position.unrealized_pnl >= 0 ? '+' : ''}{formatPercentage(
                            ((position.current_price - position.avg_price) / position.avg_price) * 100
                          )}
                        </div>
                      </div>
                    </div>
                  ))}

                  {positions.length === 0 && (
                    <div className="text-center text-gray-400 py-8">
                      현재 보유 포지션이 없습니다
                    </div>
                  )}
                </div>
              </div>
            </div>

            {/* 최근 주문 내역 */}
            <div className="w-96 p-6 pl-0">
              <div className="bg-gray-700 rounded-lg p-4 h-full">
                <h3 className="text-lg font-semibold mb-4">최근 주문 내역</h3>
                
                <div className="space-y-2 max-h-96 overflow-y-auto">
                  {orders.map(order => (
                    <div key={order.id} className="bg-gray-600 p-3 rounded text-sm">
                      <div className="flex items-center justify-between mb-1">
                        <span className="font-medium">{order.stock_name}</span>
                        <span className={`px-2 py-1 rounded text-xs ${
                          order.order_type === 'buy' 
                            ? 'bg-blue-900 text-blue-300' 
                            : 'bg-red-900 text-red-300'
                        }`}>
                          {order.order_type === 'buy' ? '매수' : '매도'}
                        </span>
                      </div>
                      <div className="text-gray-400">
                        {order.quantity}주 @ {formatCurrency(order.price)}
                      </div>
                      <div className="flex items-center justify-between mt-1">
                        <span className={`text-xs px-2 py-1 rounded ${
                          order.status === 'filled' 
                            ? 'bg-green-900 text-green-300'
                            : order.status === 'pending'
                            ? 'bg-yellow-900 text-yellow-300'
                            : 'bg-gray-900 text-gray-400'
                        }`}>
                          {order.status === 'filled' ? '체결' : 
                           order.status === 'pending' ? '대기' : '취소'}
                        </span>
                        <span className="text-xs text-gray-500">
                          {new Date(order.order_time).toLocaleTimeString('ko-KR')}
                        </span>
                      </div>
                    </div>
                  ))}

                  {orders.length === 0 && (
                    <div className="text-center text-gray-400 py-8">
                      주문 내역이 없습니다
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
} 



==================================================
File: C:\Aproject\test\quant_actual\frontend\app\api\proxy\[...path]\route.ts
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\components\dashboard.tsx
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\lib\api.ts
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\lib\types.ts
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\lib\utils.ts
==================================================
// utils.ts

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

// 숫자 포맷팅 함수들
export function formatCurrency(amount: number): string {
  if (amount === 0) return '₩0'
  
  const isNegative = amount < 0
  const absAmount = Math.abs(amount)
  
  let formatted: string
  
  if (absAmount >= 100000000) {
    // 1억 이상
    formatted = `₩${(absAmount / 100000000).toFixed(1)}억`
  } else if (absAmount >= 10000) {
    // 1만 이상
    formatted = `₩${(absAmount / 10000).toFixed(1)}만`
  } else {
    // 1만 미만
    formatted = `₩${absAmount.toLocaleString()}`
  }
  
  return isNegative ? `-${formatted}` : formatted
}

export function formatNumber(num: number): string {
  return num.toLocaleString()
}

export function formatPercentage(percentage: number): string {
  const sign = percentage >= 0 ? '+' : ''
  return `${sign}${percentage.toFixed(2)}%`
}

export function formatDecimal(num: number, decimals: number = 2): string {
  return num.toFixed(decimals)
}

// 시간 포맷팅 함수들
export function formatTime(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date
  return d.toLocaleTimeString('ko-KR', { 
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  })
}

export function formatDate(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date
  return d.toLocaleDateString('ko-KR', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit'
  })
}

export function formatDateTime(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date
  return `${formatDate(d)} ${formatTime(d)}`
}

export function getCurrentTime(): string {
  return formatTime(new Date())
}

export function getTimeAgo(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date
  const now = new Date()
  const diffMs = now.getTime() - d.getTime()
  const diffSec = Math.floor(diffMs / 1000)
  const diffMin = Math.floor(diffSec / 60)
  const diffHour = Math.floor(diffMin / 60)
  const diffDay = Math.floor(diffHour / 24)
  
  if (diffSec < 60) return `${diffSec}초 전`
  if (diffMin < 60) return `${diffMin}분 전`
  if (diffHour < 24) return `${diffHour}시간 전`
  if (diffDay < 7) return `${diffDay}일 전`
  
  return formatDate(d)
}

// 데이터 검증 함수들
export function isValidPrice(price: number): boolean {
  return price > 0 && price < 1000000000 && Number.isFinite(price)
}

export function isValidQuantity(quantity: number): boolean {
  return Number.isInteger(quantity) && quantity > 0 && quantity <= 10000000
}

export function isValidPercentage(percentage: number): boolean {
  return Number.isFinite(percentage) && percentage >= -100 && percentage <= 1000
}

// 색상 관련 함수들
export function getPnLColor(value: number): string {
  if (value > 0) return 'text-green-400'
  if (value < 0) return 'text-red-400'
  return 'text-gray-400'
}

export function getPnLBgColor(value: number): string {
  if (value > 0) return 'bg-green-900'
  if (value < 0) return 'bg-red-900'
  return 'bg-gray-700'
}

export function getChangeColor(current: number, previous: number): string {
  if (current > previous) return 'text-green-400'
  if (current < previous) return 'text-red-400'
  return 'text-gray-400'
}

// 계산 관련 함수들
export function calculatePnL(currentPrice: number, avgPrice: number, quantity: number): number {
  return (currentPrice - avgPrice) * quantity
}

export function calculatePnLPercentage(currentPrice: number, avgPrice: number): number {
  return ((currentPrice - avgPrice) / avgPrice) * 100
}

export function calculateTotalValue(positions: Array<{current_price: number, quantity: number}>): number {
  return positions.reduce((total, pos) => total + (pos.current_price * pos.quantity), 0)
}

export function calculateWeightedAverage(prices: number[], weights: number[]): number {
  if (prices.length !== weights.length || prices.length === 0) return 0
  
  const totalWeight = weights.reduce((sum, w) => sum + w, 0)
  if (totalWeight === 0) return 0
  
  const weightedSum = prices.reduce((sum, price, i) => sum + (price * weights[i]), 0)
  return weightedSum / totalWeight
}

// 배열 유틸리티 함수들
export function sortByField<T>(array: T[], field: keyof T, ascending: boolean = true): T[] {
  return [...array].sort((a, b) => {
    const aVal = a[field]
    const bVal = b[field]
    
    if (aVal < bVal) return ascending ? -1 : 1
    if (aVal > bVal) return ascending ? 1 : -1
    return 0
  })
}

export function groupBy<T>(array: T[], keyFn: (item: T) => string): Record<string, T[]> {
  return array.reduce((groups, item) => {
    const key = keyFn(item)
    if (!groups[key]) groups[key] = []
    groups[key].push(item)
    return groups
  }, {} as Record<string, T[]>)
}

export function uniqueBy<T>(array: T[], keyFn: (item: T) => any): T[] {
  const seen = new Set()
  return array.filter(item => {
    const key = keyFn(item)
    if (seen.has(key)) return false
    seen.add(key)
    return true
  })
}

// 문자열 유틸리티
export function truncateString(str: string, maxLength: number): string {
  if (str.length <= maxLength) return str
  return str.slice(0, maxLength - 3) + '...'
}

export function capitalizeFirst(str: string): string {
  if (!str) return str
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()
}

export function formatStockCode(code: string): string {
  // 종목코드를 6자리로 포맷 (예: 5930 -> 005930)
  return code.padStart(6, '0')
}

// API 관련 유틸리티
export function buildQueryString(params: Record<string, any>): string {
  const searchParams = new URLSearchParams()
  
  Object.entries(params).forEach(([key, value]) => {
    if (value != null && value !== '') {
      searchParams.append(key, String(value))
    }
  })
  
  const queryString = searchParams.toString()
  return queryString ? `?${queryString}` : ''
}

export function handleApiError(error: any): string {
  if (error?.response?.data?.detail) {
    return error.response.data.detail
  }
  if (error?.message) {
    return error.message
  }
  return '알 수 없는 오류가 발생했습니다'
}

// 로컬 스토리지 유틸리티 (브라우저 환경에서만 사용)
export function setLocalStorage(key: string, value: any): void {
  if (typeof window !== 'undefined') {
    try {
      localStorage.setItem(key, JSON.stringify(value))
    } catch (error) {
      console.warn('localStorage 저장 실패:', error)
    }
  }
}

export function getLocalStorage<T>(key: string, defaultValue: T): T {
  if (typeof window !== 'undefined') {
    try {
      const item = localStorage.getItem(key)
      return item ? JSON.parse(item) : defaultValue
    } catch (error) {
      console.warn('localStorage 읽기 실패:', error)
      return defaultValue
    }
  }
  return defaultValue
}

export function removeLocalStorage(key: string): void {
  if (typeof window !== 'undefined') {
    try {
      localStorage.removeItem(key)
    } catch (error) {
      console.warn('localStorage 삭제 실패:', error)
    }
  }
}

// 디바운싱 함수
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null
  
  return (...args: Parameters<T>) => {
    if (timeout) clearTimeout(timeout)
    
    timeout = setTimeout(() => {
      func(...args)
    }, wait)
  }
}

// 쓰로틀링 함수
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean = false
  
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}

// 랜덤 유틸리티
export function randomBetween(min: number, max: number): number {
  return Math.random() * (max - min) + min
}

export function randomInt(min: number, max: number): number {
  return Math.floor(randomBetween(min, max + 1))
}

export function generateId(): string {
  return Math.random().toString(36).substring(2) + Date.now().toString(36)
}

// 상태 관리 유틸리티
export function createInitialState<T>(defaults: T): T {
  return { ...defaults }
}

export function updateState<T>(currentState: T, updates: Partial<T>): T {
  return { ...currentState, ...updates }
}

// 타입 가드
export function isNumber(value: any): value is number {
  return typeof value === 'number' && !isNaN(value) && isFinite(value)
}

export function isString(value: any): value is string {
  return typeof value === 'string'
}

export function isArray<T>(value: any): value is T[] {
  return Array.isArray(value)
}

export function isObject(value: any): value is Record<string, any> {
  return value !== null && typeof value === 'object' && !Array.isArray(value)
}

// 에러 처리 유틸리티
export function createError(message: string, code?: string): Error {
  const error = new Error(message)
  if (code) {
    ;(error as any).code = code
  }
  return error
}

export function isApiError(error: any): boolean {
  return error?.response?.status !== undefined
}

// 성능 측정 유틸리티
export function measureTime<T>(fn: () => T, label?: string): T {
  const start = performance.now()
  const result = fn()
  const end = performance.now()
  
  if (label) {
    console.log(`${label}: ${end - start}ms`)
  }
  
  return result
}

export async function measureAsyncTime<T>(fn: () => Promise<T>, label?: string): Promise<T> {
  const start = performance.now()
  const result = await fn()
  const end = performance.now()
  
  if (label) {
    console.log(`${label}: ${end - start}ms`)
  }
  
  return result
}

// 환경 감지
export function isBrowser(): boolean {
  return typeof window !== 'undefined'
}

export function isDevelopment(): boolean {
  return process.env.NODE_ENV === 'development'
}

export function isProduction(): boolean {
  return process.env.NODE_ENV === 'production'
}

// CSS 클래스 유틸리티
export function conditionalClass(condition: boolean, trueClass: string, falseClass: string = ''): string {
  return condition ? trueClass : falseClass
}

export function joinClasses(...classes: (string | undefined | null | false)[]): string {
  return classes.filter(Boolean).join(' ')
}0 


