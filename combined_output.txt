
==================================================
File: C:\Aproject\test\quant_actual\combine.py
==================================================
import os

# ì„¤ì •
input_dirs = [
    r"C:\Aproject\test\quant_actual",
    # r"C:\Aproject\quant-platform\quant-trading-platform\backend",
    # r"C:\Aproject\quant-platform\src",
    # r"C:\Aproject\quant-platform\backtester"
]  # ì…ë ¥ ë””ë ‰í† ë¦¬ ëª©ë¡
output_file = r"C:\Aproject\test\combined_output.txt"  # ì¶œë ¥ íŒŒì¼
file_extensions = [".py", ".ts", ".tsx", ".js", ".json"]  # í¬í•¨í•  íŒŒì¼ í™•ì¥ì

def combine_files():
    # ì¶œë ¥ íŒŒì¼ ì´ˆê¸°í™”
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # ê° ì…ë ¥ ë””ë ‰í† ë¦¬ ìˆœíšŒ
        for dir_path in input_dirs:  # input_dir â†’ input_dirsë¡œ ìˆ˜ì •
            # ë””ë ‰í† ë¦¬ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
            if not os.path.exists(dir_path):
                outfile.write(f"\n{'='*50}\n")
                outfile.write(f"Directory not found: {dir_path}\n")
                outfile.write(f"{'='*50}\n")
                continue

            # ë””ë ‰í† ë¦¬ ë‚´ íŒŒì¼ ìˆœíšŒ
            for root, dirs, files in os.walk(dir_path):  # input_dir â†’ dir_path
                # node_modules ë””ë ‰í† ë¦¬ ì œì™¸
                if 'node_modules' in dirs:
                    dirs.remove('node_modules')  # node_modules ì œì™¸
                for file in files:
                    if any(file.endswith(ext) for ext in file_extensions):  # ì§€ì •ëœ í™•ì¥ì í™•ì¸
                        file_path = os.path.join(root, file)
                        try:
                            # íŒŒì¼ ë‚´ìš© ì½ê¸°
                            with open(file_path, 'r', encoding='utf-8') as infile:
                                content = infile.read()
                            # ì¶œë ¥ íŒŒì¼ì— íŒŒì¼ ê²½ë¡œì™€ ë‚´ìš© ê¸°ë¡
                            outfile.write(f"\n{'='*50}\n")
                            outfile.write(f"File: {file_path}\n")
                            outfile.write(f"{'='*50}\n")
                            outfile.write(content)
                            outfile.write("\n\n")  # íŒŒì¼ ê°„ êµ¬ë¶„ì„ ìœ„í•œ ë¹ˆ ì¤„
                        except UnicodeDecodeError:
                            # ì¸ì½”ë”© ì˜¤ë¥˜ ì‹œ cp949 ì‹œë„
                            try:
                                with open(file_path, 'r', encoding='cp949') as infile:
                                    content = infile.read()
                                outfile.write(f"\n{'='*50}\n")
                                outfile.write(f"File: {file_path} (encoded in cp949)\n")
                                outfile.write(f"{'='*50}\n")
                                outfile.write(content)
                                outfile.write("\n\n")
                            except Exception as e:
                                outfile.write(f"\n{'='*50}\n")
                                outfile.write(f"Error reading {file_path}: {str(e)}\n")
                                outfile.write(f"{'='*50}\n")
                        except Exception as e:
                            outfile.write(f"\n{'='*50}\n")
                            outfile.write(f"Error reading {file_path}: {str(e)}\n")
                            outfile.write(f"{'='*50}\n")

if __name__ == "__main__":
    combine_files()
    print(f"ëª¨ë“  íŒŒì¼ì´ {output_file}ë¡œ í•©ì³ì¡ŒìŠµë‹ˆë‹¤.")


==================================================
File: C:\Aproject\test\quant_actual\config_real.py
==================================================
"""
file: config_real.py

ì‹¤ê±°ë˜ìš© ì„¤ì • íŒŒì¼
ì£¼ì˜: ì‹¤ì œ ê³„ì¢Œ ì •ë³´ì™€ ë¹„ë°€ë²ˆí˜¸ê°€ í•„ìš”í•©ë‹ˆë‹¤
"""

import os
from typing import Dict, Any

# í™˜ê²½ë³€ìˆ˜ì—ì„œ ì‹¤ì œ ê³„ì¢Œ ì •ë³´ ë¡œë“œ
KIWOOM_ACCOUNT = os.getenv("KIWOOM_ACCOUNT", "")  # ì‹¤ì œ ê³„ì¢Œë²ˆí˜¸
KIWOOM_PASSWORD = os.getenv("KIWOOM_PASSWORD", "")  # ì‹¤ì œ ë¹„ë°€ë²ˆí˜¸
KIWOOM_CERT_PASSWORD = os.getenv("KIWOOM_CERT_PASSWORD", "")  # ê³µì¸ì¸ì¦ì„œ ë¹„ë°€ë²ˆí˜¸

# ì‹¤ê±°ë˜ ëª¨ë“œ ì„¤ì •
TRADING_CONFIG = {
    "mode": "REAL",  # DEMO â†’ REAL ë³€ê²½
    "server_type": "REAL",
    "auto_login": True,
    "save_password": False,  # ë³´ì•ˆìƒ ë¹„ì¶”ì²œ
    
    # ì‹¤ê±°ë˜ ì•ˆì „ì¥ì¹˜
    "daily_loss_limit": -50000,    # ì¼ì¼ ìµœëŒ€ ì†ì‹¤ (5ë§Œì›)
    "max_position_size": 100000,   # ìµœëŒ€ í¬ì§€ì…˜ í¬ê¸° (10ë§Œì›)
    "max_positions": 3,            # ìµœëŒ€ ë³´ìœ  ì¢…ëª© (3ê°œ)
    "emergency_stop_loss": -100000,  # ê¸´ê¸‰ì¤‘ë‹¨ ì†ì‹¤ì•¡ (10ë§Œì›)
    
    # ê±°ë˜ ì‹œê°„ ì œí•œ
    "trading_start_time": "09:30",  # ê±°ë˜ ì‹œì‘
    "trading_end_time": "15:00",    # ê±°ë˜ ì¢…ë£Œ
    "lunch_break_start": "12:00",   # ì ì‹¬ì‹œê°„ ì‹œì‘
    "lunch_break_end": "13:00",     # ì ì‹¬ì‹œê°„ ì¢…ë£Œ
}

# ì‹¤ê±°ë˜ìš© ì „ëµ ì„¤ì • (ë³´ìˆ˜ì )
REAL_STRATEGY_CONFIG = {
    "bollinger_bands": {
        "enabled": True,
        "investment_amount": 50000,  # 5ë§Œì›ë§Œ íˆ¬ì
        "target_stocks": ["005930"],  # ì‚¼ì„±ì „ìë§Œ
        "parameters": {
            "period": 20,
            "std_multiplier": 2.5,  # ë” ë³´ìˆ˜ì 
            "stop_loss": 0.02,      # 2% ì†ì ˆ
            "take_profit": 0.03,    # 3% ìµì ˆ
        }
    },
    "rsi_reversal": {
        "enabled": False,  # ì²˜ìŒì—ëŠ” 1ê°œ ì „ëµë§Œ
        "investment_amount": 30000,
        "target_stocks": ["035720"],
        "parameters": {
            "period": 14,
            "oversold": 25,  # ë” ë³´ìˆ˜ì 
            "overbought": 75,
            "stop_loss": 0.03
        }
    }
}

# ë¦¬ìŠ¤í¬ ì•Œë¦¼ ì„¤ì •
RISK_ALERTS = {
    "email_enabled": True,
    "email_recipients": ["your-email@gmail.com"],
    "slack_enabled": False,
    
    "alert_conditions": {
        "daily_loss": -10000,      # ì¼ì¼ ì†ì‹¤ 1ë§Œì› ì‹œ ì•Œë¦¼
        "position_loss": -5000,    # í¬ì§€ì…˜ ì†ì‹¤ 5ì²œì› ì‹œ ì•Œë¦¼
        "system_error": True,      # ì‹œìŠ¤í…œ ì˜¤ë¥˜ ì‹œ ì•Œë¦¼
        "connection_lost": True    # ì—°ê²° ëŠê¹€ ì‹œ ì•Œë¦¼
    }
}

# ë°±ì—… ë° ë¡œê¹… ì„¤ì •
BACKUP_CONFIG = {
    "auto_backup": True,
    "backup_interval": 3600,  # 1ì‹œê°„ë§ˆë‹¤ ë°±ì—…
    "max_backups": 24,        # 24ì‹œê°„ë¶„ ë³´ê´€
    "backup_location": "backups/real_trading/",
    
    "detailed_logging": True,
    "log_all_api_calls": True,
    "log_sensitive_data": False  # ë¹„ë°€ë²ˆí˜¸ ë“± ë¡œê·¸ì— ê¸°ë¡ ì•ˆí•¨
}

def validate_real_trading_config():
    """ì‹¤ê±°ë˜ ì„¤ì • ê²€ì¦"""
    errors = []
    warnings = []
    
    # í•„ìˆ˜ ì •ë³´ ì²´í¬
    if not KIWOOM_ACCOUNT:
        errors.append("KIWOOM_ACCOUNT í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
    
    if not KIWOOM_PASSWORD:
        errors.append("KIWOOM_PASSWORD í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
    
    # ì•ˆì „ì¥ì¹˜ ì²´í¬
    total_investment = sum(
        config.get("investment_amount", 0) 
        for config in REAL_STRATEGY_CONFIG.values() 
        if config.get("enabled", False)
    )
    
    if total_investment > 100000:  # 10ë§Œì› ì´ˆê³¼
        warnings.append(f"ì´ íˆ¬ìê¸ˆì•¡ì´ {total_investment:,}ì›ìœ¼ë¡œ ê¶Œì¥ì•¡(10ë§Œì›)ì„ ì´ˆê³¼")
    
    # ì†ì ˆ ì„¤ì • ì²´í¬
    for strategy_name, config in REAL_STRATEGY_CONFIG.items():
        if config.get("enabled") and not config.get("parameters", {}).get("stop_loss"):
            warnings.append(f"{strategy_name} ì „ëµì— ì†ì ˆ ì„¤ì •ì´ ì—†ìŒ")
    
    return {
        "valid": len(errors) == 0,
        "errors": errors,
        "warnings": warnings
    }

def get_real_trading_disclaimer():
    """ì‹¤ê±°ë˜ ë©´ì±… ê³ ì§€"""
    return """
    âš ï¸  ì‹¤ê±°ë˜ ëª¨ë“œ ê²½ê³  âš ï¸
    
    1. ì´ ì†Œí”„íŠ¸ì›¨ì–´ëŠ” ì‹¤ì œ ëˆìœ¼ë¡œ ê±°ë˜í•©ë‹ˆë‹¤
    2. íˆ¬ì ì†ì‹¤ ìœ„í—˜ì´ ìˆìŠµë‹ˆë‹¤
    3. ì‹œìŠ¤í…œ ì˜¤ë¥˜ë¡œ ì¸í•œ ì†ì‹¤ ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤
    4. ë°˜ë“œì‹œ ì†Œì•¡ìœ¼ë¡œ ì‹œì‘í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤
    5. ì¶©ë¶„í•œ í…ŒìŠ¤íŠ¸ í›„ ì‚¬ìš©í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤
    
    ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (yes/no): 
    """

# ì‹¤ê±°ë˜ ì²´í¬ë¦¬ìŠ¤íŠ¸
REAL_TRADING_CHECKLIST = [
    "âœ… í‚¤ì›€ì¦ê¶Œ ê³„ì¢Œ ê°œì„¤ ì™„ë£Œ",
    "âœ… í‚¤ì›€ Open API+ ì„¤ì¹˜ ì™„ë£Œ", 
    "âœ… ëª¨ì˜íˆ¬ìë¡œ ì¶©ë¶„í•œ í…ŒìŠ¤íŠ¸ ì™„ë£Œ",
    "âœ… ì†ì ˆ/ìµì ˆ ì„¤ì • í™•ì¸",
    "âœ… ì¼ì¼ ì†ì‹¤ í•œë„ ì„¤ì • í™•ì¸",
    "âœ… ê¸´ê¸‰ì—°ë½ì²˜ ì„¤ì • ì™„ë£Œ",
    "âœ… ë°±ì—… ì‹œìŠ¤í…œ ë™ì‘ í™•ì¸",
    "âœ… ì¸í„°ë„· ì—°ê²° ì•ˆì •ì„± í™•ì¸",
    "âœ… íˆ¬ì ê°€ëŠ¥ ê¸ˆì•¡ í™•ì¸",
    "âœ… ê°€ì¡±/ì§€ì¸ì—ê²Œ ìë™ë§¤ë§¤ ì‚¬ì‹¤ ê³ ì§€"
]

def print_real_trading_checklist():
    """ì‹¤ê±°ë˜ ì²´í¬ë¦¬ìŠ¤íŠ¸ ì¶œë ¥"""
    print("\n" + "="*50)
    print("ğŸš¨ ì‹¤ê±°ë˜ ì „ í•„ìˆ˜ ì²´í¬ë¦¬ìŠ¤íŠ¸")
    print("="*50)
    
    for item in REAL_TRADING_CHECKLIST:
        print(item)
    
    print("="*50)
    print("ëª¨ë“  í•­ëª©ì„ í™•ì¸í•˜ì‹  í›„ ì‹¤ê±°ë˜ë¥¼ ì‹œì‘í•˜ì„¸ìš”!")
    print("="*50)

# ì‹¤ê±°ë˜ ì‹œì‘ í•¨ìˆ˜
def start_real_trading():
    """ì‹¤ê±°ë˜ ëª¨ë“œ ì‹œì‘"""
    
    # 1. ë©´ì±… ê³ ì§€
    disclaimer = get_real_trading_disclaimer()
    response = input(disclaimer).lower().strip()
    
    if response not in ['yes', 'y', 'ë„¤', 'ã…‡']:
        print("ì‹¤ê±°ë˜ ì‹œì‘ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
        return False
    
    # 2. ì„¤ì • ê²€ì¦
    validation = validate_real_trading_config()
    
    if not validation["valid"]:
        print("âŒ ì„¤ì • ì˜¤ë¥˜:")
        for error in validation["errors"]:
            print(f"  - {error}")
        return False
    
    if validation["warnings"]:
        print("âš ï¸  ê²½ê³ ì‚¬í•­:")
        for warning in validation["warnings"]:
            print(f"  - {warning}")
        
        proceed = input("ê²½ê³ ì‚¬í•­ì„ ë¬´ì‹œí•˜ê³  ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (yes/no): ").lower().strip()
        if proceed not in ['yes', 'y', 'ë„¤', 'ã…‡']:
            print("ì‹¤ê±°ë˜ ì‹œì‘ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
            return False
    
    # 3. ì²´í¬ë¦¬ìŠ¤íŠ¸ í™•ì¸
    print_real_trading_checklist()
    checklist_ok = input("\nëª¨ë“  ì²´í¬ë¦¬ìŠ¤íŠ¸ë¥¼ í™•ì¸í•˜ì…¨ë‚˜ìš”? (yes/no): ").lower().strip()
    
    if checklist_ok not in ['yes', 'y', 'ë„¤', 'ã…‡']:
        print("ì²´í¬ë¦¬ìŠ¤íŠ¸ë¥¼ ë¨¼ì € í™•ì¸í•´ì£¼ì„¸ìš”.")
        return False
    
    # 4. ìµœì¢… í™•ì¸
    print("\n" + "ğŸ”¥" * 20)
    print("ìµœì¢… í™•ì¸: ì‹¤ì œ ëˆìœ¼ë¡œ ìë™ë§¤ë§¤ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤!")
    print("ğŸ”¥" * 20)
    
    final_confirm = input("ì •ë§ë¡œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ? 'START REAL TRADING' ì„ ì…ë ¥í•˜ì„¸ìš”: ")
    
    if final_confirm != "START REAL TRADING":
        print("ì‹¤ê±°ë˜ ì‹œì‘ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
        return False
    
    print("\nâœ… ì‹¤ê±°ë˜ ëª¨ë“œë¡œ ì‹œìŠ¤í…œì„ ì‹œì‘í•©ë‹ˆë‹¤...")
    return True

# í™˜ê²½ë³€ìˆ˜ ì„¤ì • ì˜ˆì‹œ íŒŒì¼ ìƒì„±
def create_env_example():
    """ì‹¤ê±°ë˜ìš© .env.example íŒŒì¼ ìƒì„±"""
    env_content = """
# í‚¤ì›€ì¦ê¶Œ ê³„ì¢Œ ì •ë³´ (ì‹¤ì œ ì •ë³´ë¡œ ë³€ê²½ í•„ìš”)
KIWOOM_ACCOUNT=8012345-01
KIWOOM_PASSWORD=your_password
KIWOOM_CERT_PASSWORD=your_cert_password

# ì‹¤ê±°ë˜ ëª¨ë“œ ì„¤ì •
TRADING_MODE=REAL
SERVER_TYPE=REAL

# ë³´ì•ˆ ì„¤ì •
SECRET_KEY=your-very-secure-secret-key-here

# ì•Œë¦¼ ì„¤ì •
EMAIL_SMTP_SERVER=smtp.gmail.com
EMAIL_SMTP_PORT=587
EMAIL_USERNAME=your-email@gmail.com
EMAIL_PASSWORD=your-email-password
EMAIL_RECIPIENTS=your-email@gmail.com,backup-email@gmail.com

# ìŠ¬ë™ ì•Œë¦¼ (ì„ íƒì‚¬í•­)
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/...
SLACK_CHANNEL=#trading-alerts

# ë°ì´í„°ë² ì´ìŠ¤ (ì‹¤ê±°ë˜ìš© ë³„ë„ DB)
DATABASE_URL=sqlite:///./data/quantrade_real.db

# ë¡œê¹… ì„¤ì •
LOG_LEVEL=INFO
LOG_FILE=logs/real_trading.log
"""
    
    with open(".env.real.example", "w", encoding="utf-8") as f:
        f.write(env_content)
    
    print("âœ… .env.real.example íŒŒì¼ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.")
    print("ì´ íŒŒì¼ì„ .env.realë¡œ ë³µì‚¬í•˜ê³  ì‹¤ì œ ì •ë³´ë¡œ ìˆ˜ì •í•˜ì„¸ìš”.")

if __name__ == "__main__":
    # ì‹¤ê±°ë˜ ì„¤ì • íŒŒì¼ ì‹¤í–‰ ì‹œ
    print("ğŸ”§ ì‹¤ê±°ë˜ ì„¤ì • ë„êµ¬")
    print("-" * 30)
    
    choice = input("""
ì„ íƒí•˜ì„¸ìš”:
1. ì‹¤ê±°ë˜ ì‹œì‘
2. ì„¤ì • ê²€ì¦ë§Œ
3. ì²´í¬ë¦¬ìŠ¤íŠ¸ ì¶œë ¥
4. .env ì˜ˆì‹œ íŒŒì¼ ìƒì„±
5. ì¢…ë£Œ

ì„ íƒ (1-5): """).strip()
    
    if choice == "1":
        if start_real_trading():
            print("ì‹¤ê±°ë˜ ëª¨ë“œê°€ ìŠ¹ì¸ë˜ì—ˆìŠµë‹ˆë‹¤.")
        else:
            print("ì‹¤ê±°ë˜ ì‹œì‘ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
    
    elif choice == "2":
        validation = validate_real_trading_config()
        if validation["valid"]:
            print("âœ… ì„¤ì •ì´ ì˜¬ë°”ë¦…ë‹ˆë‹¤.")
        else:
            print("âŒ ì„¤ì • ì˜¤ë¥˜ê°€ ìˆìŠµë‹ˆë‹¤:")
            for error in validation["errors"]:
                print(f"  - {error}")
        
        if validation["warnings"]:
            print("âš ï¸  ê²½ê³ ì‚¬í•­:")
            for warning in validation["warnings"]:
                print(f"  - {warning}")
    
    elif choice == "3":
        print_real_trading_checklist()
    
    elif choice == "4":
        create_env_example()
    
    elif choice == "5":
        print("ì¢…ë£Œí•©ë‹ˆë‹¤.")
    
    else:
        print("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤.")


==================================================
File: C:\Aproject\test\quant_actual\kiwoom_real_api.py
==================================================
"""
file: kiwoom_real_api.py
ì‹¤ì œ í‚¤ì›€ Open API í´ë¼ì´ì–¸íŠ¸
ì£¼ì˜: Windows í™˜ê²½ì—ì„œë§Œ ë™ì‘í•˜ë©°, í‚¤ì›€ Open API+ ì„¤ì¹˜ í•„ìš”
"""

import sys
import logging
from typing import Dict, Any, Optional
from datetime import datetime
import asyncio

# Windows ì „ìš© import
try:
    import pythoncom
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QAxContainer import QAxWidget
    from PyQt5.QtCore import QEventLoop, QTimer
    WINDOWS_AVAILABLE = True
except ImportError:
    WINDOWS_AVAILABLE = False
    print("âš ï¸ Windows í™˜ê²½ì´ ì•„ë‹ˆê±°ë‚˜ PyQt5ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

logger = logging.getLogger(__name__)

class KiwoomRealClient:
    """ì‹¤ì œ í‚¤ì›€ Open API í´ë¼ì´ì–¸íŠ¸"""
    
    def __init__(self):
        if not WINDOWS_AVAILABLE:
            raise RuntimeError("í‚¤ì›€ APIëŠ” Windows í™˜ê²½ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤")
        
        self.is_connected = False
        self.account_number = None
        self.app = None
        self.kiwoom = None
        
        # ì‹¤ì‹œê°„ ë°ì´í„° ì €ì¥
        self.real_data = {}
        self.order_data = {}
        
        # ì´ë²¤íŠ¸ ë£¨í”„
        self.login_event_loop = None
        self.tr_event_loop = None
        
        # ìš”ì²­ ì œí•œ (ì´ˆë‹¹ 5íšŒ)
        self.last_request_time = {}
        self.request_interval = 0.2  # 200ms
        
    async def initialize(self):
        """í‚¤ì›€ API ì´ˆê¸°í™”"""
        try:
            # QApplication ìƒì„±
            if not QApplication.instance():
                self.app = QApplication(sys.argv)
            else:
                self.app = QApplication.instance()
                
            # í‚¤ì›€ OCX ìƒì„±
            self.kiwoom = QAxWidget("KHOPENAPI.KHOpenAPICtrl.1")
            
            # ì´ë²¤íŠ¸ ì—°ê²°
            self.kiwoom.OnEventConnect.connect(self._on_event_connect)
            self.kiwoom.OnReceiveTrData.connect(self._on_receive_tr_data)
            self.kiwoom.OnReceiveRealData.connect(self._on_receive_real_data)
            self.kiwoom.OnReceiveChejanData.connect(self._on_receive_chejan_data)
            
            logger.info("í‚¤ì›€ API ì´ˆê¸°í™” ì™„ë£Œ")
            return True
            
        except Exception as e:
            logger.error(f"í‚¤ì›€ API ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            return False
    
    async def connect(self):
        """í‚¤ì›€ API ë¡œê·¸ì¸"""
        try:
            if not self.kiwoom:
                await self.initialize()
            
            # ì´ë¯¸ ì—°ê²°ëœ ê²½ìš°
            if self.get_connect_state() == 1:
                self.is_connected = True
                logger.info("í‚¤ì›€ API ì´ë¯¸ ì—°ê²°ë¨")
                return True
            
            # ë¡œê·¸ì¸ ìš”ì²­
            self.login_event_loop = QEventLoop()
            ret = self.kiwoom.dynamicCall("CommConnect()")
            
            if ret == 0:
                self.login_event_loop.exec_()
                
            if self.is_connected:
                # ê³„ì¢Œ ì •ë³´ ì¡°íšŒ
                accounts = self.kiwoom.dynamicCall("GetLoginInfo(QString)", "ACCNO")
                self.account_number = accounts.split(';')[0]
                
                logger.info(f"í‚¤ì›€ API ë¡œê·¸ì¸ ì„±ê³µ - ê³„ì¢Œ: {self.account_number}")
                return True
            else:
                logger.error("í‚¤ì›€ API ë¡œê·¸ì¸ ì‹¤íŒ¨")
                return False
                
        except Exception as e:
            logger.error(f"í‚¤ì›€ API ì—°ê²° ì˜¤ë¥˜: {e}")
            return False
    
    async def disconnect(self):
        """í‚¤ì›€ API ì—°ê²° í•´ì œ"""
        try:
            if self.kiwoom:
                self.kiwoom.dynamicCall("CommTerminate()")
            self.is_connected = False
            logger.info("í‚¤ì›€ API ì—°ê²° í•´ì œë¨")
        except Exception as e:
            logger.error(f"í‚¤ì›€ API ì—°ê²° í•´ì œ ì˜¤ë¥˜: {e}")
    
    def get_connect_state(self):
        """ì—°ê²° ìƒíƒœ í™•ì¸"""
        if self.kiwoom:
            return self.kiwoom.dynamicCall("GetConnectState()")
        return 0
    
    async def get_current_price(self, stock_code: str) -> Dict[str, Any]:
        """í˜„ì¬ê°€ ì¡°íšŒ"""
        try:
            await self._wait_for_request_limit("current_price")
            
            # TR ìš”ì²­
            self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì¢…ëª©ì½”ë“œ", stock_code)
            
            self.tr_event_loop = QEventLoop()
            ret = self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)",
                                        "ì£¼ì‹ê¸°ë³¸ì •ë³´", "opt10001", 0, "0001")
            
            if ret == 0:
                self.tr_event_loop.exec_()
                
                # ë°ì´í„° ì¡°íšŒ
                current_price = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                          "opt10001", "ì£¼ì‹ê¸°ë³¸ì •ë³´", 0, "í˜„ì¬ê°€"))
                prev_close = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                       "opt10001", "ì£¼ì‹ê¸°ë³¸ì •ë³´", 0, "ê¸°ì¤€ê°€"))
                volume = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                   "opt10001", "ì£¼ì‹ê¸°ë³¸ì •ë³´", 0, "ê±°ë˜ëŸ‰"))
                
                return {
                    'current_price': abs(current_price),  # ìŒìˆ˜ ì œê±°
                    'prev_close': abs(prev_close),
                    'volume': volume,
                    'price_change': current_price - prev_close,
                    'change_rate': ((current_price - prev_close) / prev_close) * 100,
                    'timestamp': datetime.now().isoformat()
                }
            else:
                logger.error(f"í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨: {stock_code}")
                return {}
                
        except Exception as e:
            logger.error(f"í˜„ì¬ê°€ ì¡°íšŒ ì˜¤ë¥˜ {stock_code}: {e}")
            return {}
    
    async def send_order(self, stock_code: str, order_type: str, 
                        quantity: int, price: float) -> str:
        """ì£¼ë¬¸ ì „ì†¡"""
        try:
            await self._wait_for_request_limit("send_order")
            
            # ì£¼ë¬¸ êµ¬ë¶„ ì½”ë“œ ë³€í™˜
            order_type_code = "1" if order_type.upper() == "BUY" else "2"
            hoga_code = "00"  # ì§€ì •ê°€
            
            # ì£¼ë¬¸ ìš”ì²­
            ret = self.kiwoom.dynamicCall(
                "SendOrder(QString, QString, QString, int, QString, int, int, QString, QString)",
                "ìë™ë§¤ë§¤",              # ì‚¬ìš©ìêµ¬ë¶„ëª…
                "0001",                 # í™”ë©´ë²ˆí˜¸
                self.account_number,    # ê³„ì¢Œë²ˆí˜¸
                int(order_type_code),   # ì£¼ë¬¸ìœ í˜•
                stock_code,             # ì¢…ëª©ì½”ë“œ
                quantity,               # ì£¼ë¬¸ìˆ˜ëŸ‰
                int(price),             # ì£¼ë¬¸ê°€ê²©
                hoga_code,              # í˜¸ê°€êµ¬ë¶„
                ""                      # ì›ì£¼ë¬¸ë²ˆí˜¸
            )
            
            if ret == 0:
                # ì£¼ë¬¸ë²ˆí˜¸ ìƒì„± (ì‹¤ì œë¡œëŠ” í‚¤ì›€ì—ì„œ ë°˜í™˜)
                order_id = f"ORD{datetime.now().strftime('%Y%m%d%H%M%S')}"
                
                logger.info(f"ì£¼ë¬¸ ì „ì†¡ ì„±ê³µ: {stock_code} {order_type} {quantity}ì£¼ @ {price}")
                return order_id
            else:
                logger.error(f"ì£¼ë¬¸ ì „ì†¡ ì‹¤íŒ¨: {ret}")
                raise Exception(f"ì£¼ë¬¸ ì „ì†¡ ì‹¤íŒ¨: {ret}")
                
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ ì „ì†¡ ì˜¤ë¥˜: {e}")
            raise
    
    async def cancel_order(self, order_id: str) -> bool:
        """ì£¼ë¬¸ ì·¨ì†Œ"""
        try:
            # ì‹¤ì œë¡œëŠ” ì›ì£¼ë¬¸ë²ˆí˜¸ë¡œ ì·¨ì†Œ ìš”ì²­
            ret = self.kiwoom.dynamicCall(
                "SendOrder(QString, QString, QString, int, QString, int, int, QString, QString)",
                "ì·¨ì†Œ",                  # ì‚¬ìš©ìêµ¬ë¶„ëª…
                "0002",                 # í™”ë©´ë²ˆí˜¸
                self.account_number,    # ê³„ì¢Œë²ˆí˜¸
                3,                      # ì·¨ì†Œ
                "",                     # ì¢…ëª©ì½”ë“œ
                0,                      # ìˆ˜ëŸ‰
                0,                      # ê°€ê²©
                "00",                   # í˜¸ê°€êµ¬ë¶„
                order_id                # ì›ì£¼ë¬¸ë²ˆí˜¸
            )
            
            return ret == 0
            
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ ì·¨ì†Œ ì˜¤ë¥˜: {e}")
            return False
    
    async def get_account_info(self) -> Dict[str, Any]:
        """ê³„ì¢Œ ì •ë³´ ì¡°íšŒ"""
        try:
            await self._wait_for_request_limit("account_info")
            
            # ì˜ˆìˆ˜ê¸ˆ ì¡°íšŒ
            self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ê³„ì¢Œë²ˆí˜¸", self.account_number)
            self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë¹„ë°€ë²ˆí˜¸", "")
            
            self.tr_event_loop = QEventLoop()
            ret = self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)",
                                        "ì˜ˆìˆ˜ê¸ˆìƒì„¸í˜„í™©", "opw00001", 0, "0002")
            
            if ret == 0:
                self.tr_event_loop.exec_()
                
                # ë°ì´í„° íŒŒì‹±
                total_cash = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                       "opw00001", "ì˜ˆìˆ˜ê¸ˆìƒì„¸í˜„í™©", 0, "ì˜ˆìˆ˜ê¸ˆ"))
                available_cash = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                           "opw00001", "ì˜ˆìˆ˜ê¸ˆìƒì„¸í˜„í™©", 0, "ì¶œê¸ˆê°€ëŠ¥ê¸ˆì•¡"))
                
                return {
                    'account_number': self.account_number,
                    'total_cash': total_cash,
                    'available_cash': available_cash,
                    'server_type': 'REAL'
                }
            else:
                logger.error("ê³„ì¢Œ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨")
                return {}
                
        except Exception as e:
            logger.error(f"ê³„ì¢Œ ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return {}
    
    async def get_balance(self) -> list:
        """ì”ê³  ì¡°íšŒ"""
        try:
            await self._wait_for_request_limit("balance")
            
            # ê³„ì¢Œí‰ê°€ì”ê³ ë‚´ì—­ìš”ì²­
            self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ê³„ì¢Œë²ˆí˜¸", self.account_number)
            self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë¹„ë°€ë²ˆí˜¸", "")
            
            self.tr_event_loop = QEventLoop()
            ret = self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)",
                                        "ê³„ì¢Œí‰ê°€ì”ê³ ë‚´ì—­", "opw00018", 0, "0003")
            
            if ret == 0:
                self.tr_event_loop.exec_()
                
                # ì”ê³  ë°ì´í„° íŒŒì‹±
                balance = []
                count = self.kiwoom.dynamicCall("GetRepeatCnt(QString, QString)", 
                                               "opw00018", "ê³„ì¢Œí‰ê°€ì”ê³ ë‚´ì—­")
                
                for i in range(count):
                    stock_code = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                       "opw00018", "ê³„ì¢Œí‰ê°€ì”ê³ ë‚´ì—­", i, "ì¢…ëª©ë²ˆí˜¸").strip()
                    stock_name = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                       "opw00018", "ê³„ì¢Œí‰ê°€ì”ê³ ë‚´ì—­", i, "ì¢…ëª©ëª…").strip()
                    quantity = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                         "opw00018", "ê³„ì¢Œí‰ê°€ì”ê³ ë‚´ì—­", i, "ë³´ìœ ìˆ˜ëŸ‰"))
                    avg_price = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                          "opw00018", "ê³„ì¢Œí‰ê°€ì”ê³ ë‚´ì—­", i, "ë§¤ì…ê°€"))
                    current_price = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)",
                                                              "opw00018", "ê³„ì¢Œí‰ê°€ì”ê³ ë‚´ì—­", i, "í˜„ì¬ê°€"))
                    
                    if quantity > 0:
                        balance_item = {
                            'stock_code': stock_code,
                            'stock_name': stock_name,
                            'quantity': quantity,
                            'avg_price': abs(avg_price),
                            'current_price': abs(current_price),
                            'current_value': abs(current_price) * quantity,
                            'purchase_value': abs(avg_price) * quantity,
                            'profit_loss': (abs(current_price) - abs(avg_price)) * quantity,
                            'profit_loss_rate': ((abs(current_price) - abs(avg_price)) / abs(avg_price)) * 100
                        }
                        balance.append(balance_item)
                
                return balance
            else:
                logger.error("ì”ê³  ì¡°íšŒ ì‹¤íŒ¨")
                return []
                
        except Exception as e:
            logger.error(f"ì”ê³  ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return []
    
    # ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ë“¤
    def _on_event_connect(self, err_code):
        """ë¡œê·¸ì¸ ê²°ê³¼ ì²˜ë¦¬"""
        if err_code == 0:
            self.is_connected = True
            logger.info("í‚¤ì›€ API ë¡œê·¸ì¸ ì„±ê³µ")
        else:
            self.is_connected = False
            logger.error(f"í‚¤ì›€ API ë¡œê·¸ì¸ ì‹¤íŒ¨: {err_code}")
        
        if self.login_event_loop:
            self.login_event_loop.exit()
    
    def _on_receive_tr_data(self, screen_no, rq_name, tr_code, record_name, next_code):
        """TR ë°ì´í„° ìˆ˜ì‹ """
        if self.tr_event_loop:
            self.tr_event_loop.exit()
    
    def _on_receive_real_data(self, stock_code, real_type, real_data):
        """ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì‹ """
        try:
            if real_type == "ì£¼ì‹ì²´ê²°":
                current_price = int(self.kiwoom.dynamicCall("GetCommRealData(QString, int)", stock_code, 10))
                volume = int(self.kiwoom.dynamicCall("GetCommRealData(QString, int)", stock_code, 15))
                
                self.real_data[stock_code] = {
                    'current_price': abs(current_price),
                    'volume': volume,
                    'timestamp': datetime.now()
                }
                
        except Exception as e:
            logger.error(f"ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    def _on_receive_chejan_data(self, gubun, item_cnt, fid_list):
        """ì£¼ë¬¸/ì²´ê²° ë°ì´í„° ìˆ˜ì‹ """
        try:
            if gubun == "0":  # ì£¼ë¬¸ì²´ê²°
                order_no = self.kiwoom.dynamicCall("GetChejanData(int)", 9203)
                stock_code = self.kiwoom.dynamicCall("GetChejanData(int)", 9001)
                order_status = self.kiwoom.dynamicCall("GetChejanData(int)", 913)
                
                logger.info(f"ì£¼ë¬¸ì²´ê²° ìˆ˜ì‹ : {stock_code} - {order_status}")
                
        except Exception as e:
            logger.error(f"ì²´ê²° ë°ì´í„° ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    async def _wait_for_request_limit(self, request_type: str):
        """ìš”ì²­ ì œí•œ ëŒ€ê¸°"""
        now = datetime.now().timestamp()
        last_time = self.last_request_time.get(request_type, 0)
        
        if now - last_time < self.request_interval:
            wait_time = self.request_interval - (now - last_time)
            await asyncio.sleep(wait_time)
        
        self.last_request_time[request_type] = datetime.now().timestamp()
    
    def get_connection_status(self) -> Dict[str, Any]:
        """ì—°ê²° ìƒíƒœ ë°˜í™˜"""
        return {
            'is_connected': self.is_connected,
            'account_number': self.account_number,
            'server_type': 'REAL',
            'connection_time': datetime.now().isoformat() if self.is_connected else None
        }

# ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ êµ¬í˜„
_kiwoom_real_client = None

def get_kiwoom_real_client() -> KiwoomRealClient:
    """í‚¤ì›€ ì‹¤ê±°ë˜ í´ë¼ì´ì–¸íŠ¸ ì‹±ê¸€í†¤"""
    global _kiwoom_real_client
    if _kiwoom_real_client is None:
        _kiwoom_real_client = KiwoomRealClient()
    return _kiwoom_real_client


==================================================
File: C:\Aproject\test\quant_actual\package.json
==================================================
{
  "name": "quantrade-frontend",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit",
    "format": "prettier --write .",
    "format:check": "prettier --check ."
  },
  "dependencies": {
    "next": "14.0.4",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "typescript": "5.3.3",
    "@types/node": "20.10.4",
    "@types/react": "18.2.45",
    "@types/react-dom": "18.2.17",
    "tailwindcss": "3.3.6",
    "autoprefixer": "10.4.16",
    "postcss": "8.4.32",
    "clsx": "2.0.0",
    "tailwind-merge": "2.2.0",
    "class-variance-authority": "0.7.0",
    "@tailwindcss/forms": "0.5.7",
    "@tailwindcss/typography": "0.5.10"
  },
  "devDependencies": {
    "eslint": "8.56.0",
    "eslint-config-next": "14.0.4",
    "@typescript-eslint/eslint-plugin": "6.15.0",
    "@typescript-eslint/parser": "6.15.0",
    "prettier": "3.1.1",
    "prettier-plugin-tailwindcss": "0.5.9",
    "@types/eslint": "8.56.0"
  },
  "engines": {
    "node": ">=18.17.0",
    "npm": ">=9.0.0"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
} 



==================================================
File: C:\Aproject\test\quant_actual\start_system.py
==================================================
"""
file: start_system.py
QuanTrade Pro ì‹œìŠ¤í…œ ì‹œì‘ ìŠ¤í¬ë¦½íŠ¸
ë°±ì—”ë“œì™€ í”„ë¡ íŠ¸ì—”ë“œë¥¼ ë™ì‹œì— ì‹¤í–‰í•©ë‹ˆë‹¤.
"""

import os
import sys
import subprocess
import time
import signal
import threading
import webbrowser
from pathlib import Path

class SystemManager:
    def __init__(self):
        self.backend_process = None
        self.frontend_process = None
        self.running = True
        
        # í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ì„¤ì •
        self.project_dir = Path(__file__).parent
        self.backend_dir = self.project_dir / "backend"
        self.frontend_dir = self.project_dir / "frontend"
        
        # ë¡œê·¸ íŒŒì¼ ì„¤ì •
        self.log_dir = self.project_dir / "logs"
        self.log_dir.mkdir(exist_ok=True)
    
    def check_dependencies(self):
        """ì‹œìŠ¤í…œ ì˜ì¡´ì„± ì²´í¬"""
        print("ğŸ” ì‹œìŠ¤í…œ ì˜ì¡´ì„± ì²´í¬ ì¤‘...")
        
        # Python ë²„ì „ ì²´í¬
        python_version = sys.version_info
        if python_version < (3, 9):
            print(f"âŒ Python 3.9+ í•„ìš”. í˜„ì¬ ë²„ì „: {python_version.major}.{python_version.minor}")
            return False
        
        print(f"âœ… Python {python_version.major}.{python_version.minor}.{python_version.micro}")
        
        # Node.js ì²´í¬
        try:
            result = subprocess.run(['node', '--version'], capture_output=True, text=True)
            if result.returncode == 0:
                node_version = result.stdout.strip()
                print(f"âœ… Node.js {node_version}")
            else:
                print("âŒ Node.jsê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
                return False
        except FileNotFoundError:
            print("âŒ Node.jsê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
            return False
        
        # NPM ì²´í¬
        try:
            result = subprocess.run(['npm', '--version'], capture_output=True, text=True)
            if result.returncode == 0:
                npm_version = result.stdout.strip()
                print(f"âœ… NPM {npm_version}")
            else:
                print("âŒ NPMì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
                return False
        except FileNotFoundError:
            print("âŒ NPMì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
            return False
        
        # ë””ë ‰í† ë¦¬ ì²´í¬
        if not self.backend_dir.exists():
            print(f"âŒ ë°±ì—”ë“œ ë””ë ‰í† ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤: {self.backend_dir}")
            return False
        
        if not self.frontend_dir.exists():
            print(f"âŒ í”„ë¡ íŠ¸ì—”ë“œ ë””ë ‰í† ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤: {self.frontend_dir}")
            return False
        
        # í•„ìˆ˜ íŒŒì¼ ì²´í¬
        if not (self.backend_dir / "main.py").exists():
            print("âŒ backend/main.py íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤")
            return False
        
        if not (self.backend_dir / "requirements.txt").exists():
            print("âŒ backend/requirements.txt íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤")
            return False
        
        if not (self.frontend_dir / "package.json").exists():
            print("âŒ frontend/package.json íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤")
            return False
        
        print("âœ… ëª¨ë“  ì˜ì¡´ì„± ì²´í¬ ì™„ë£Œ")
        return True
    
    def install_dependencies(self):
        """ì˜ì¡´ì„± ì„¤ì¹˜"""
        print("\nğŸ“¦ ì˜ì¡´ì„± ì„¤ì¹˜ ì¤‘...")
        
        # Python ì˜ì¡´ì„± ì„¤ì¹˜
        print("ğŸ Python íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘...")
        try:
            cmd = [sys.executable, "-m", "pip", "install", "-r", "requirements.txt"]
            result = subprocess.run(
                cmd, 
                cwd=self.backend_dir, 
                capture_output=True, 
                text=True
            )
            
            if result.returncode != 0:
                print(f"âŒ Python íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì‹¤íŒ¨:\n{result.stderr}")
                return False
            
            print("âœ… Python íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì™„ë£Œ")
            
        except Exception as e:
            print(f"âŒ Python íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘ ì˜¤ë¥˜: {e}")
            return False
        
        # Node.js ì˜ì¡´ì„± ì„¤ì¹˜
        print("ğŸ“¦ Node.js íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘...")
        try:
            result = subprocess.run(
                ["npm", "install"], 
                cwd=self.frontend_dir, 
                capture_output=True, 
                text=True
            )
            
            if result.returncode != 0:
                print(f"âŒ Node.js íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì‹¤íŒ¨:\n{result.stderr}")
                return False
            
            print("âœ… Node.js íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì™„ë£Œ")
            
        except Exception as e:
            print(f"âŒ Node.js íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì¤‘ ì˜¤ë¥˜: {e}")
            return False
        
        return True
    
    def start_backend(self):
        """ë°±ì—”ë“œ ì„œë²„ ì‹œì‘"""
        print("\nğŸš€ ë°±ì—”ë“œ ì„œë²„ ì‹œì‘ ì¤‘...")
        
        try:
            # ë°±ì—”ë“œ ë¡œê·¸ íŒŒì¼
            backend_log = self.log_dir / "backend.log"
            
            with open(backend_log, "w") as log_file:
                self.backend_process = subprocess.Popen(
                    [sys.executable, "main.py"],
                    cwd=self.backend_dir,
                    stdout=log_file,
                    stderr=subprocess.STDOUT,
                    text=True
                )
            
            # ì„œë²„ ì‹œì‘ ëŒ€ê¸°
            time.sleep(3)
            
            if self.backend_process.poll() is None:
                print("âœ… ë°±ì—”ë“œ ì„œë²„ ì‹œì‘ë¨ (http://localhost:8000)")
                return True
            else:
                print("âŒ ë°±ì—”ë“œ ì„œë²„ ì‹œì‘ ì‹¤íŒ¨")
                return False
                
        except Exception as e:
            print(f"âŒ ë°±ì—”ë“œ ì‹œì‘ ì¤‘ ì˜¤ë¥˜: {e}")
            return False
    
    def start_frontend(self):
        """í”„ë¡ íŠ¸ì—”ë“œ ì„œë²„ ì‹œì‘"""
        print("\nğŸ¨ í”„ë¡ íŠ¸ì—”ë“œ ì„œë²„ ì‹œì‘ ì¤‘...")
        
        try:
            # í”„ë¡ íŠ¸ì—”ë“œ ë¡œê·¸ íŒŒì¼
            frontend_log = self.log_dir / "frontend.log"
            
            with open(frontend_log, "w") as log_file:
                self.frontend_process = subprocess.Popen(
                    ["npm", "run", "dev"],
                    cwd=self.frontend_dir,
                    stdout=log_file,
                    stderr=subprocess.STDOUT,
                    text=True
                )
            
            # ì„œë²„ ì‹œì‘ ëŒ€ê¸°
            time.sleep(5)
            
            if self.frontend_process.poll() is None:
                print("âœ… í”„ë¡ íŠ¸ì—”ë“œ ì„œë²„ ì‹œì‘ë¨ (http://localhost:3000)")
                return True
            else:
                print("âŒ í”„ë¡ íŠ¸ì—”ë“œ ì„œë²„ ì‹œì‘ ì‹¤íŒ¨")
                return False
                
        except Exception as e:
            print(f"âŒ í”„ë¡ íŠ¸ì—”ë“œ ì‹œì‘ ì¤‘ ì˜¤ë¥˜: {e}")
            return False
    
    def check_server_health(self):
        """ì„œë²„ ìƒíƒœ ì²´í¬"""
        try:
            import requests
            
            # ë°±ì—”ë“œ í—¬ìŠ¤ ì²´í¬
            try:
                response = requests.get("http://localhost:8000/health", timeout=5)
                if response.status_code == 200:
                    print("âœ… ë°±ì—”ë“œ ì„œë²„ ì •ìƒ ì‘ë™")
                else:
                    print(f"âš ï¸  ë°±ì—”ë“œ ì„œë²„ ìƒíƒœ ì´ìƒ: {response.status_code}")
            except requests.RequestException:
                print("âŒ ë°±ì—”ë“œ ì„œë²„ ì—°ê²° ì‹¤íŒ¨")
                return False
            
            # í”„ë¡ íŠ¸ì—”ë“œ í—¬ìŠ¤ ì²´í¬
            try:
                response = requests.get("http://localhost:3000", timeout=5)
                if response.status_code == 200:
                    print("âœ… í”„ë¡ íŠ¸ì—”ë“œ ì„œë²„ ì •ìƒ ì‘ë™")
                else:
                    print(f"âš ï¸  í”„ë¡ íŠ¸ì—”ë“œ ì„œë²„ ìƒíƒœ ì´ìƒ: {response.status_code}")
            except requests.RequestException:
                print("âŒ í”„ë¡ íŠ¸ì—”ë“œ ì„œë²„ ì—°ê²° ì‹¤íŒ¨")
                return False
            
            return True
            
        except ImportError:
            print("âš ï¸  requests ëª¨ë“ˆì´ ì—†ì–´ í—¬ìŠ¤ ì²´í¬ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤")
            return True
    
    def open_browser(self):
        """ë¸Œë¼ìš°ì €ì—ì„œ ì• í”Œë¦¬ì¼€ì´ì…˜ ì—´ê¸°"""
        try:
            print("\nğŸŒ ë¸Œë¼ìš°ì €ì—ì„œ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì—½ë‹ˆë‹¤...")
            webbrowser.open("http://localhost:3000")
            time.sleep(2)
        except Exception as e:
            print(f"âš ï¸  ë¸Œë¼ìš°ì € ì—´ê¸° ì‹¤íŒ¨: {e}")
            print("ìˆ˜ë™ìœ¼ë¡œ http://localhost:3000 ì— ì ‘ì†í•˜ì„¸ìš”")
    
    def monitor_processes(self):
        """í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ëª¨ë‹ˆí„°ë§"""
        while self.running:
            try:
                # ë°±ì—”ë“œ í”„ë¡œì„¸ìŠ¤ ì²´í¬
                if self.backend_process and self.backend_process.poll() is not None:
                    print("âŒ ë°±ì—”ë“œ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
                    self.running = False
                    break
                
                # í”„ë¡ íŠ¸ì—”ë“œ í”„ë¡œì„¸ìŠ¤ ì²´í¬
                if self.frontend_process and self.frontend_process.poll() is not None:
                    print("âŒ í”„ë¡ íŠ¸ì—”ë“œ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
                    self.running = False
                    break
                
                time.sleep(5)
                
            except KeyboardInterrupt:
                break
    
    def cleanup(self):
        """í”„ë¡œì„¸ìŠ¤ ì •ë¦¬"""
        print("\nğŸ›‘ ì‹œìŠ¤í…œ ì¢…ë£Œ ì¤‘...")
        
        if self.backend_process:
            try:
                self.backend_process.terminate()
                self.backend_process.wait(timeout=5)
                print("âœ… ë°±ì—”ë“œ ì„œë²„ ì¢…ë£Œë¨")
            except subprocess.TimeoutExpired:
                self.backend_process.kill()
                print("ğŸ”¥ ë°±ì—”ë“œ ì„œë²„ ê°•ì œ ì¢…ë£Œë¨")
            except Exception as e:
                print(f"âš ï¸  ë°±ì—”ë“œ ì¢…ë£Œ ì¤‘ ì˜¤ë¥˜: {e}")
        
        if self.frontend_process:
            try:
                self.frontend_process.terminate()
                self.frontend_process.wait(timeout=5)
                print("âœ… í”„ë¡ íŠ¸ì—”ë“œ ì„œë²„ ì¢…ë£Œë¨")
            except subprocess.TimeoutExpired:
                self.frontend_process.kill()
                print("ğŸ”¥ í”„ë¡ íŠ¸ì—”ë“œ ì„œë²„ ê°•ì œ ì¢…ë£Œë¨")
            except Exception as e:
                print(f"âš ï¸  í”„ë¡ íŠ¸ì—”ë“œ ì¢…ë£Œ ì¤‘ ì˜¤ë¥˜: {e}")
    
    def signal_handler(self, signum, frame):
        """ì‹œê·¸ë„ í•¸ë“¤ëŸ¬"""
        print(f"\nğŸ“¡ ì‹œê·¸ë„ {signum} ìˆ˜ì‹ ë¨")
        self.running = False
        self.cleanup()
        sys.exit(0)
    
    def start_system(self, install_deps=True, open_browser=True):
        """ì „ì²´ ì‹œìŠ¤í…œ ì‹œì‘"""
        print("ğŸš€ QuanTrade Pro ì‹œìŠ¤í…œ ì‹œì‘")
        print("=" * 50)
        
        # ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ ë“±ë¡
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
        
        try:
            # 1. ì˜ì¡´ì„± ì²´í¬
            if not self.check_dependencies():
                print("âŒ ì˜ì¡´ì„± ì²´í¬ ì‹¤íŒ¨")
                return False
            
            # 2. ì˜ì¡´ì„± ì„¤ì¹˜ (ì˜µì…˜)
            if install_deps:
                if not self.install_dependencies():
                    print("âŒ ì˜ì¡´ì„± ì„¤ì¹˜ ì‹¤íŒ¨")
                    return False
            
            # 3. ë°±ì—”ë“œ ì‹œì‘
            if not self.start_backend():
                print("âŒ ë°±ì—”ë“œ ì‹œì‘ ì‹¤íŒ¨")
                return False
            
            # 4. í”„ë¡ íŠ¸ì—”ë“œ ì‹œì‘
            if not self.start_frontend():
                print("âŒ í”„ë¡ íŠ¸ì—”ë“œ ì‹œì‘ ì‹¤íŒ¨")
                self.cleanup()
                return False
            
            # 5. ì„œë²„ ìƒíƒœ ì²´í¬
            time.sleep(3)
            if not self.check_server_health():
                print("âš ï¸  ì„œë²„ ìƒíƒœ ì²´í¬ ì‹¤íŒ¨, ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤")
            
            # 6. ë¸Œë¼ìš°ì € ì—´ê¸° (ì˜µì…˜)
            if open_browser:
                self.open_browser()
            
            # 7. ì‹œìŠ¤í…œ ì •ë³´ ì¶œë ¥
            self.print_system_info()
            
            # 8. í”„ë¡œì„¸ìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œì‘
            monitor_thread = threading.Thread(target=self.monitor_processes)
            monitor_thread.daemon = True
            monitor_thread.start()
            
            # 9. ë©”ì¸ ë£¨í”„
            print("\nâœ… ì‹œìŠ¤í…œì´ ì„±ê³µì ìœ¼ë¡œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!")
            print("Ctrl+Cë¥¼ ëˆŒëŸ¬ ì¢…ë£Œí•˜ì„¸ìš”")
            
            while self.running:
                try:
                    time.sleep(1)
                except KeyboardInterrupt:
                    break
            
            return True
            
        except Exception as e:
            print(f"âŒ ì‹œìŠ¤í…œ ì‹œì‘ ì¤‘ ì˜¤ë¥˜: {e}")
            return False
        
        finally:
            self.cleanup()
    
    def print_system_info(self):
        """ì‹œìŠ¤í…œ ì •ë³´ ì¶œë ¥"""
        print("\n" + "=" * 50)
        print("ğŸ¯ QuanTrade Pro ì‹œìŠ¤í…œ ì •ë³´")
        print("=" * 50)
        print(f"ğŸ“ í”„ë¡ íŠ¸ì—”ë“œ: http://localhost:3000")
        print(f"ğŸ“ ë°±ì—”ë“œ API: http://localhost:8000")
        print(f"ğŸ“ API ë¬¸ì„œ: http://localhost:8000/docs")
        print(f"ğŸ“ ë¡œê·¸ ë””ë ‰í† ë¦¬: {self.log_dir}")
        print(f"ğŸ“ í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬: {self.project_dir}")
        print("=" * 50)
        
        print("\nğŸ’¡ ì‚¬ìš©ë²•:")
        print("â€¢ ì›¹ ë¸Œë¼ìš°ì €ì—ì„œ http://localhost:3000 ì ‘ì†")
        print("â€¢ ì „ëµì„ í™œì„±í™”í•˜ê³  ìë™ë§¤ë§¤ ì‹œì‘ ë²„íŠ¼ í´ë¦­")
        print("â€¢ ì‹¤ì‹œê°„ ìˆ˜ìµ í˜„í™© ë° ì£¼ë¬¸ ë‚´ì—­ ëª¨ë‹ˆí„°ë§")
        print("â€¢ ê¸´ê¸‰ ìƒí™© ì‹œ ê¸´ê¸‰ì¤‘ë‹¨ ë²„íŠ¼ ì‚¬ìš©")
        
        print("\nâš ï¸  ì£¼ì˜ì‚¬í•­:")
        print("â€¢ í˜„ì¬ëŠ” ëª¨ì˜íˆ¬ì ëª¨ë“œë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤")
        print("â€¢ ì‹¤ì œ ê±°ë˜ ì „ ì¶©ë¶„í•œ í…ŒìŠ¤íŠ¸ë¥¼ ê¶Œì¥í•©ë‹ˆë‹¤")
        print("â€¢ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì„¤ì •ì„ ë°˜ë“œì‹œ í™•ì¸í•˜ì„¸ìš”")
        
        print("\nğŸ”§ ë¬¸ì œ í•´ê²°:")
        print(f"â€¢ ë°±ì—”ë“œ ë¡œê·¸: tail -f {self.log_dir}/backend.log")
        print(f"â€¢ í”„ë¡ íŠ¸ì—”ë“œ ë¡œê·¸: tail -f {self.log_dir}/frontend.log")
        print("â€¢ í¬íŠ¸ ì¶©ëŒ ì‹œ: lsof -i :3000 ë˜ëŠ” lsof -i :8000")


def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="QuanTrade Pro ì‹œìŠ¤í…œ ì‹œì‘ ìŠ¤í¬ë¦½íŠ¸",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ì‚¬ìš© ì˜ˆì‹œ:
  python start_system.py              # ì „ì²´ ì‹œìŠ¤í…œ ì‹œì‘
  python start_system.py --no-install # ì˜ì¡´ì„± ì„¤ì¹˜ ê±´ë„ˆë›°ê¸°
  python start_system.py --no-browser # ë¸Œë¼ìš°ì € ìë™ ì—´ê¸° ë¹„í™œì„±í™”
  python start_system.py --check-only # ì˜ì¡´ì„±ë§Œ ì²´í¬í•˜ê³  ì¢…ë£Œ
        """
    )
    
    parser.add_argument(
        "--no-install", 
        action="store_true",
        help="ì˜ì¡´ì„± ì„¤ì¹˜ ê±´ë„ˆë›°ê¸°"
    )
    
    parser.add_argument(
        "--no-browser", 
        action="store_true",
        help="ë¸Œë¼ìš°ì € ìë™ ì—´ê¸° ë¹„í™œì„±í™”"
    )
    
    parser.add_argument(
        "--check-only", 
        action="store_true",
        help="ì˜ì¡´ì„±ë§Œ ì²´í¬í•˜ê³  ì¢…ë£Œ"
    )
    
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="ìƒì„¸ ë¡œê·¸ ì¶œë ¥"
    )
    
    args = parser.parse_args()
    
    # ì‹œìŠ¤í…œ ë§¤ë‹ˆì € ìƒì„±
    system_manager = SystemManager()
    
    # ì˜ì¡´ì„±ë§Œ ì²´í¬í•˜ê³  ì¢…ë£Œ
    if args.check_only:
        print("ğŸ” ì˜ì¡´ì„± ì²´í¬ ëª¨ë“œ")
        if system_manager.check_dependencies():
            print("âœ… ëª¨ë“  ì˜ì¡´ì„±ì´ ì¶©ì¡±ë˜ì—ˆìŠµë‹ˆë‹¤")
            sys.exit(0)
        else:
            print("âŒ ì˜ì¡´ì„± ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤")
            sys.exit(1)
    
    # ì „ì²´ ì‹œìŠ¤í…œ ì‹œì‘
    success = system_manager.start_system(
        install_deps=not args.no_install,
        open_browser=not args.no_browser
    )
    
    if success:
        print("\nğŸ‘‹ QuanTrade Proë¥¼ ì´ìš©í•´ ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤!")
        sys.exit(0)
    else:
        print("\nâŒ ì‹œìŠ¤í…œ ì‹œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤")
        sys.exit(1)


if __name__ == "__main__":
    main()


==================================================
File: C:\Aproject\test\quant_actual\trading_mode.tsx
==================================================
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'

interface SystemStatus {
  current_mode: 'DEMO' | 'REAL'
  is_windows: boolean
  kiwoom_api_available: boolean
  account_connected: boolean
  account_info?: {
    account_number: string
    server_type: string
    available_cash: number
  }
}

export default function TradingModeSelector() {
  const [systemStatus, setSystemStatus] = useState<SystemStatus | null>(null)
  const [selectedMode, setSelectedMode] = useState<'DEMO' | 'REAL'>('DEMO')
  const [loading, setLoading] = useState(true)
  const [isChanging, setIsChanging] = useState(false)
  const [showRealTradeWarning, setShowRealTradeWarning] = useState(false)
  const [acceptedTerms, setAcceptedTerms] = useState(false)
  const [confirmationText, setConfirmationText] = useState('')
  const router = useRouter()

  useEffect(() => {
    checkSystemStatus()
  }, [])

  const checkSystemStatus = async () => {
    try {
      const response = await fetch('/api/proxy/system/trading-mode')
      const data = await response.json()
      setSystemStatus(data)
      setSelectedMode(data.current_mode)
    } catch (error) {
      console.error('ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸ ì‹¤íŒ¨:', error)
    } finally {
      setLoading(false)
    }
  }

  const handleModeChange = async (mode: 'DEMO' | 'REAL') => {
    if (mode === 'REAL') {
      setShowRealTradeWarning(true)
      return
    }
    
    await changeTradingMode(mode)
  }

  const changeTradingMode = async (mode: 'DEMO' | 'REAL') => {
    setIsChanging(true)
    
    try {
      const response = await fetch('/api/proxy/system/change-trading-mode', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ mode })
      })

      if (response.ok) {
        setSelectedMode(mode)
        await checkSystemStatus()
        
        if (mode === 'DEMO') {
          alert('ëª¨ì˜íˆ¬ì ëª¨ë“œë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.')
        } else {
          alert('ì‹¤ê±°ë˜ ëª¨ë“œë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤. ì£¼ì˜í•´ì„œ ê±°ë˜í•˜ì„¸ìš”!')
        }
      } else {
        const error = await response.json()
        alert(`ëª¨ë“œ ë³€ê²½ ì‹¤íŒ¨: ${error.detail}`)
      }
    } catch (error) {
      console.error('ëª¨ë“œ ë³€ê²½ ì‹¤íŒ¨:', error)
      alert('ëª¨ë“œ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
    } finally {
      setIsChanging(false)
      setShowRealTradeWarning(false)
      setAcceptedTerms(false)
      setConfirmationText('')
    }
  }

  const handleRealTradeConfirm = () => {
    if (!acceptedTerms) {
      alert('ìœ„í—˜ ê³ ì§€ë¥¼ ë¨¼ì € í™•ì¸í•´ì£¼ì„¸ìš”.')
      return
    }

    if (confirmationText !== 'START REAL TRADING') {
      alert('í™•ì¸ í…ìŠ¤íŠ¸ë¥¼ ì •í™•íˆ ì…ë ¥í•´ì£¼ì„¸ìš”.')
      return
    }

    changeTradingMode('REAL')
  }

  const startTrading = () => {
    router.push('/dashboard')
  }

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-white text-xl">ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸ ì¤‘...</div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gray-900 text-white">
      {/* í—¤ë” */}
      <header className="bg-gray-800 px-6 py-4 border-b border-gray-700">
        <h1 className="text-2xl font-bold text-green-400">QuanTrade Pro - ê±°ë˜ ëª¨ë“œ ì„ íƒ</h1>
      </header>

      <div className="container mx-auto px-6 py-8">
        <div className="max-w-4xl mx-auto">
          
          {/* í˜„ì¬ ì‹œìŠ¤í…œ ìƒíƒœ */}
          <div className="bg-gray-800 rounded-lg p-6 mb-8">
            <h2 className="text-xl font-semibold mb-4">ğŸ“Š í˜„ì¬ ì‹œìŠ¤í…œ ìƒíƒœ</h2>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <div className="bg-gray-700 p-4 rounded">
                <div className="text-sm text-gray-400">í˜„ì¬ ëª¨ë“œ</div>
                <div className={`text-lg font-bold ${
                  systemStatus?.current_mode === 'REAL' ? 'text-red-400' : 'text-blue-400'
                }`}>
                  {systemStatus?.current_mode === 'REAL' ? 'ì‹¤ê±°ë˜' : 'ëª¨ì˜íˆ¬ì'}
                </div>
              </div>
              
              <div className="bg-gray-700 p-4 rounded">
                <div className="text-sm text-gray-400">ìš´ì˜ì²´ì œ</div>
                <div className={`text-lg font-bold ${
                  systemStatus?.is_windows ? 'text-green-400' : 'text-yellow-400'
                }`}>
                  {systemStatus?.is_windows ? 'Windows' : 'Other'}
                </div>
              </div>
              
              <div className="bg-gray-700 p-4 rounded">
                <div className="text-sm text-gray-400">í‚¤ì›€ API</div>
                <div className={`text-lg font-bold ${
                  systemStatus?.kiwoom_api_available ? 'text-green-400' : 'text-red-400'
                }`}>
                  {systemStatus?.kiwoom_api_available ? 'ì‚¬ìš© ê°€ëŠ¥' : 'ë¶ˆê°€ëŠ¥'}
                </div>
              </div>
              
              <div className="bg-gray-700 p-4 rounded">
                <div className="text-sm text-gray-400">ê³„ì¢Œ ì—°ê²°</div>
                <div className={`text-lg font-bold ${
                  systemStatus?.account_connected ? 'text-green-400' : 'text-gray-400'
                }`}>
                  {systemStatus?.account_connected ? 'ì—°ê²°ë¨' : 'ë¯¸ì—°ê²°'}
                </div>
              </div>
            </div>

            {/* ê³„ì¢Œ ì •ë³´ */}
            {systemStatus?.account_info && (
              <div className="mt-4 p-4 bg-gray-700 rounded">
                <div className="text-sm text-gray-400 mb-2">ê³„ì¢Œ ì •ë³´</div>
                <div className="flex justify-between items-center">
                  <span>ê³„ì¢Œë²ˆí˜¸: {systemStatus.account_info.account_number}</span>
                  <span>ì„œë²„: {systemStatus.account_info.server_type}</span>
                  <span>ê°€ìš©ìê¸ˆ: â‚©{systemStatus.account_info.available_cash.toLocaleString()}</span>
                </div>
              </div>
            )}
          </div>

          {/* ê±°ë˜ ëª¨ë“œ ì„ íƒ */}
          <div className="grid md:grid-cols-2 gap-8 mb-8">
            
            {/* ëª¨ì˜íˆ¬ì ëª¨ë“œ */}
            <div className={`bg-gray-800 rounded-lg p-6 border-2 transition-all cursor-pointer ${
              selectedMode === 'DEMO' ? 'border-blue-500 bg-blue-900/20' : 'border-gray-600 hover:border-blue-400'
            }`} onClick={() => setSelectedMode('DEMO')}>
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-xl font-bold text-blue-400">ğŸ® ëª¨ì˜íˆ¬ì ëª¨ë“œ</h3>
                <div className={`w-6 h-6 rounded-full border-2 flex items-center justify-center ${
                  selectedMode === 'DEMO' ? 'border-blue-500 bg-blue-500' : 'border-gray-400'
                }`}>
                  {selectedMode === 'DEMO' && <div className="w-3 h-3 bg-white rounded-full"></div>}
                </div>
              </div>
              
              <div className="space-y-3 text-sm">
                <div className="flex items-center space-x-2">
                  <span className="text-green-400">âœ…</span>
                  <span>ì‹¤ì œ ëˆì„ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-green-400">âœ…</span>
                  <span>ëª¨ë“  í”Œë«í¼ì—ì„œ ì‹¤í–‰ ê°€ëŠ¥</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-green-400">âœ…</span>
                  <span>ì „ëµ í…ŒìŠ¤íŠ¸ ë° í•™ìŠµì— ìµœì </span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-green-400">âœ…</span>
                  <span>ìœ„í—˜ ì—†ì´ ì‹œìŠ¤í…œ ë™ì‘ í™•ì¸</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-blue-400">ğŸ’¡</span>
                  <span>ì‹¤ì‹œê°„ ì‹œì„¸ ì‹œë®¬ë ˆì´ì…˜</span>
                </div>
              </div>

              <div className="mt-4 p-3 bg-blue-900/30 rounded text-xs">
                <strong>ì¶”ì²œ ëŒ€ìƒ:</strong> ì´ˆë³´ì, ì „ëµ ê°œë°œì, ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
              </div>
            </div>

            {/* ì‹¤ê±°ë˜ ëª¨ë“œ */}
            <div className={`bg-gray-800 rounded-lg p-6 border-2 transition-all cursor-pointer ${
              selectedMode === 'REAL' ? 'border-red-500 bg-red-900/20' : 'border-gray-600 hover:border-red-400'
            } ${!systemStatus?.is_windows || !systemStatus?.kiwoom_api_available ? 'opacity-50 cursor-not-allowed' : ''}`} 
            onClick={() => systemStatus?.is_windows && systemStatus?.kiwoom_api_available && setSelectedMode('REAL')}>
              
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-xl font-bold text-red-400">ğŸ”¥ ì‹¤ê±°ë˜ ëª¨ë“œ</h3>
                <div className={`w-6 h-6 rounded-full border-2 flex items-center justify-center ${
                  selectedMode === 'REAL' ? 'border-red-500 bg-red-500' : 'border-gray-400'
                }`}>
                  {selectedMode === 'REAL' && <div className="w-3 h-3 bg-white rounded-full"></div>}
                </div>
              </div>
              
              <div className="space-y-3 text-sm">
                <div className="flex items-center space-x-2">
                  <span className="text-red-400">âš ï¸</span>
                  <span>ì‹¤ì œ ëˆìœ¼ë¡œ ê±°ë˜</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-yellow-400">ğŸ–¥ï¸</span>
                  <span>Windows í™˜ê²½ í•„ìˆ˜</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-yellow-400">ğŸ”‘</span>
                  <span>í‚¤ì›€ì¦ê¶Œ ê³„ì¢Œ í•„ìš”</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-red-400">ğŸ’°</span>
                  <span>íˆ¬ì ì†ì‹¤ ìœ„í—˜</span>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-green-400">ğŸ“ˆ</span>
                  <span>ì‹¤ì œ ìˆ˜ìµ ê°€ëŠ¥</span>
                </div>
              </div>

              <div className="mt-4 p-3 bg-red-900/30 rounded text-xs">
                <strong>ì¶”ì²œ ëŒ€ìƒ:</strong> ê²½í—˜ì, ì¶©ë¶„í•œ í…ŒìŠ¤íŠ¸ ì™„ë£Œ, ì†Œì•¡ íˆ¬ì ê°€ëŠ¥ì
              </div>

              {/* ì‹¤ê±°ë˜ ë¶ˆê°€ëŠ¥í•œ ê²½ìš° ì•ˆë‚´ */}
              {(!systemStatus?.is_windows || !systemStatus?.kiwoom_api_available) && (
                <div className="mt-4 p-3 bg-gray-700 rounded text-xs text-yellow-400">
                  <strong>ì‹¤ê±°ë˜ ë¶ˆê°€ëŠ¥:</strong> 
                  {!systemStatus?.is_windows && " Windows í™˜ê²½ í•„ìš”"}
                  {!systemStatus?.kiwoom_api_available && " í‚¤ì›€ API ì„¤ì¹˜ í•„ìš”"}
                </div>
              )}
            </div>
          </div>

          {/* ëª¨ë“œ ë³€ê²½ ë²„íŠ¼ */}
          <div className="flex justify-center space-x-4 mb-8">
            {selectedMode !== systemStatus?.current_mode && (
              <button
                onClick={() => handleModeChange(selectedMode)}
                disabled={isChanging || (!systemStatus?.is_windows && selectedMode === 'REAL')}
                className={`px-8 py-3 rounded-lg font-semibold transition-all ${
                  selectedMode === 'REAL'
                    ? 'bg-red-600 hover:bg-red-700 text-white'
                    : 'bg-blue-600 hover:bg-blue-700 text-white'
                } disabled:opacity-50 disabled:cursor-not-allowed`}
              >
                {isChanging ? 'ë³€ê²½ ì¤‘...' : `${selectedMode === 'REAL' ? 'ì‹¤ê±°ë˜' : 'ëª¨ì˜íˆ¬ì'} ëª¨ë“œë¡œ ë³€ê²½`}
              </button>
            )}
            
            <button
              onClick={startTrading}
              className="px-8 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg font-semibold transition-all"
            >
              íŠ¸ë ˆì´ë”© ì‹œì‘
            </button>
          </div>

          {/* ì£¼ì˜ì‚¬í•­ */}
          <div className="bg-yellow-900/20 border border-yellow-600 rounded-lg p-6">
            <h3 className="text-yellow-400 font-semibold mb-3">âš ï¸ ì¤‘ìš” ì•ˆë‚´ì‚¬í•­</h3>
            <ul className="space-y-2 text-sm">
              <li>â€¢ <strong>ëª¨ì˜íˆ¬ì:</strong> ê°€ìƒì˜ ëˆìœ¼ë¡œ ê±°ë˜í•˜ë¯€ë¡œ ì‹¤ì œ ì†ìµì´ ë°œìƒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤</li>
              <li>â€¢ <strong>ì‹¤ê±°ë˜:</strong> ì‹¤ì œ ëˆìœ¼ë¡œ ê±°ë˜í•˜ë¯€ë¡œ íˆ¬ì ì†ì‹¤ ìœ„í—˜ì´ ìˆìŠµë‹ˆë‹¤</li>
              <li>â€¢ ì‹¤ê±°ë˜ ì „ì—ëŠ” ë°˜ë“œì‹œ ëª¨ì˜íˆ¬ìë¡œ ì¶©ë¶„í•œ í…ŒìŠ¤íŠ¸ë¥¼ ì§„í–‰í•˜ì„¸ìš”</li>
              <li>â€¢ ì‹œìŠ¤í…œ ì˜¤ë¥˜ë‚˜ ë„¤íŠ¸ì›Œí¬ ì¥ì• ë¡œ ì¸í•œ ì†ì‹¤ ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤</li>
              <li>â€¢ ì†Œì•¡ìœ¼ë¡œ ì‹œì‘í•˜ì—¬ ì ì§„ì ìœ¼ë¡œ íˆ¬ìê¸ˆì•¡ì„ ëŠ˜ë ¤ê°€ì„¸ìš”</li>
            </ul>
          </div>
        </div>
      </div>

      {/* ì‹¤ê±°ë˜ í™•ì¸ ëª¨ë‹¬ */}
      {showRealTradeWarning && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
          <div className="bg-gray-800 rounded-lg p-8 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto">
            <div className="text-center mb-6">
              <div className="text-6xl mb-4">âš ï¸</div>
              <h2 className="text-2xl font-bold text-red-400">ì‹¤ê±°ë˜ ëª¨ë“œ ê²½ê³ </h2>
            </div>

            <div className="space-y-4 text-sm mb-6">
              <div className="bg-red-900/30 p-4 rounded">
                <h3 className="font-bold text-red-400 mb-2">ğŸš¨ ìœ„í—˜ ê³ ì§€</h3>
                <ul className="space-y-1">
                  <li>â€¢ ì´ ì†Œí”„íŠ¸ì›¨ì–´ëŠ” ì‹¤ì œ ëˆìœ¼ë¡œ ìë™ë§¤ë§¤ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤</li>
                  <li>â€¢ íˆ¬ìì›ê¸ˆ ì†ì‹¤ ìœ„í—˜ì´ ìˆìŠµë‹ˆë‹¤</li>
                  <li>â€¢ ì‹œìŠ¤í…œ ì˜¤ë¥˜, ë„¤íŠ¸ì›Œí¬ ì¥ì• ë¡œ ì¸í•œ ì†ì‹¤ ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤</li>
                  <li>â€¢ ê¸‰ê²©í•œ ì‹œì¥ ë³€ë™ ì‹œ í° ì†ì‹¤ì´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</li>
                  <li>â€¢ ê°œë°œìëŠ” íˆ¬ì ì†ì‹¤ì— ëŒ€í•´ ì–´ë– í•œ ì±…ì„ë„ ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤</li>
                </ul>
              </div>

              <div className="bg-yellow-900/30 p-4 rounded">
                <h3 className="font-bold text-yellow-400 mb-2">âœ… ì‚¬ì „ ì¤€ë¹„ì‚¬í•­</h3>
                <ul className="space-y-1">
                  <li>â€¢ í‚¤ì›€ì¦ê¶Œ ê³„ì¢Œ ê°œì„¤ ë° Open API+ ì„¤ì¹˜ ì™„ë£Œ</li>
                  <li>â€¢ ëª¨ì˜íˆ¬ìë¡œ ìµœì†Œ 1ê°œì›” ì´ìƒ í…ŒìŠ¤íŠ¸ ì™„ë£Œ</li>
                  <li>â€¢ ì†ì ˆ/ìµì ˆ ì„¤ì • ë° ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì„¤ì • í™•ì¸</li>
                  <li>â€¢ íˆ¬ì ê°€ëŠ¥í•œ ì†Œì•¡ìœ¼ë¡œ ì‹œì‘ (ê¶Œì¥: 10ë§Œì› ì´í•˜)</li>
                  <li>â€¢ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ê°€ëŠ¥í•œ í™˜ê²½ êµ¬ì¶•</li>
                </ul>
              </div>
            </div>

            <div className="space-y-4">
              <label className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={acceptedTerms}
                  onChange={(e) => setAcceptedTerms(e.target.checked)}
                  className="w-4 h-4"
                />
                <span className="text-sm">ìœ„í—˜ ê³ ì§€ë¥¼ ëª¨ë‘ ì½ê³  ì´í•´í–ˆìœ¼ë©°, ëª¨ë“  íˆ¬ì ì†ì‹¤ì— ëŒ€í•œ ì±…ì„ì„ ì§‘ë‹ˆë‹¤</span>
              </label>

              <div>
                <label className="block text-sm mb-2">
                  í™•ì¸ì„ ìœ„í•´ <span className="text-red-400 font-bold">"START REAL TRADING"</span>ì„ ì…ë ¥í•˜ì„¸ìš”:
                </label>
                <input
                  type="text"
                  value={confirmationText}
                  onChange={(e) => setConfirmationText(e.target.value)}
                  className="w-full p-3 bg-gray-700 rounded text-white"
                  placeholder="START REAL TRADING"
                />
              </div>
            </div>

            <div className="flex justify-end space-x-4 mt-6">
              <button
                onClick={() => setShowRealTradeWarning(false)}
                className="px-6 py-2 bg-gray-600 hover:bg-gray-700 rounded text-white"
              >
                ì·¨ì†Œ
              </button>
              <button
                onClick={handleRealTradeConfirm}
                disabled={!acceptedTerms || confirmationText !== 'START REAL TRADING'}
                className="px-6 py-2 bg-red-600 hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed rounded text-white font-semibold"
              >
                ì‹¤ê±°ë˜ ì‹œì‘
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}


==================================================
File: C:\Aproject\test\quant_actual\trading_mode_api.py
==================================================
"""
file: trading_mode_api.py
ê±°ë˜ ëª¨ë“œ ì „í™˜ API
Mock â†” Real ëª¨ë“œ ì „í™˜ì„ ìœ„í•œ ì—”ë“œí¬ì¸íŠ¸
"""

import os
import platform
import logging
from typing import Dict, Any
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel

from utils.config import get_settings
from database import get_db_session

logger = logging.getLogger(__name__)

# ì „ì—­ ë³€ìˆ˜ë¡œ í˜„ì¬ ëª¨ë“œ ì €ì¥
CURRENT_TRADING_MODE = "DEMO"  # DEMO or REAL
KIWOOM_CLIENT_INSTANCE = None

class TradingModeRequest(BaseModel):
    mode: str  # "DEMO" or "REAL"

class SystemStatusResponse(BaseModel):
    current_mode: str
    is_windows: bool
    kiwoom_api_available: bool
    account_connected: bool
    account_info: Dict[str, Any] = None

router = APIRouter()

def check_windows_environment() -> bool:
    """Windows í™˜ê²½ ì²´í¬"""
    return platform.system() == "Windows"

def check_kiwoom_api_available() -> bool:
    """í‚¤ì›€ API ì‚¬ìš© ê°€ëŠ¥ì„± ì²´í¬"""
    if not check_windows_environment():
        return False
    
    try:
        # PyQt5ì™€ pythoncom ëª¨ë“ˆ ì²´í¬
        import PyQt5
        import pythoncom
        
        # í‚¤ì›€ API íŒŒì¼ ì¡´ì¬ ì²´í¬ (ì¼ë°˜ì ì¸ ì„¤ì¹˜ ê²½ë¡œ)
        kiwoom_paths = [
            "C:\\OpenAPI\\",
            "C:\\Program Files\\OpenAPI\\",
            "C:\\Program Files (x86)\\OpenAPI\\"
        ]
        
        for path in kiwoom_paths:
            if os.path.exists(path):
                return True
        
        # ë ˆì§€ìŠ¤íŠ¸ë¦¬ì—ì„œ í‚¤ì›€ API í™•ì¸ (ì„ íƒì )
        try:
            import winreg
            key = winreg.OpenKey(winreg.HKEY_CLASSES_ROOT, "KHOPENAPI.KHOpenAPICtrl.1")
            winreg.CloseKey(key)
            return True
        except:
            pass
        
        return False
        
    except ImportError:
        return False

async def get_account_info():
    """ê³„ì¢Œ ì •ë³´ ì¡°íšŒ"""
    global KIWOOM_CLIENT_INSTANCE
    
    if CURRENT_TRADING_MODE == "REAL" and KIWOOM_CLIENT_INSTANCE:
        try:
            account_info = await KIWOOM_CLIENT_INSTANCE.get_account_info()
            return account_info
        except Exception as e:
            logger.error(f"ì‹¤ê±°ë˜ ê³„ì¢Œ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return None
    else:
        # Mock ëª¨ë“œ ê³„ì¢Œ ì •ë³´
        return {
            "account_number": "8012345-01",
            "server_type": "DEMO",
            "available_cash": 50000000,
            "total_cash": 50000000
        }

@router.get("/system/trading-mode", response_model=SystemStatusResponse)
async def get_trading_mode_status():
    """í˜„ì¬ ê±°ë˜ ëª¨ë“œ ìƒíƒœ ì¡°íšŒ"""
    try:
        is_windows = check_windows_environment()
        kiwoom_available = check_kiwoom_api_available()
        
        # ê³„ì¢Œ ì—°ê²° ìƒíƒœ ì²´í¬
        account_connected = False
        account_info = None
        
        if CURRENT_TRADING_MODE == "REAL" and KIWOOM_CLIENT_INSTANCE:
            account_connected = KIWOOM_CLIENT_INSTANCE.is_connected
            if account_connected:
                account_info = await get_account_info()
        elif CURRENT_TRADING_MODE == "DEMO":
            account_connected = True  # Mock ëª¨ë“œì—ì„œëŠ” í•­ìƒ ì—°ê²°ë¨
            account_info = await get_account_info()
        
        return SystemStatusResponse(
            current_mode=CURRENT_TRADING_MODE,
            is_windows=is_windows,
            kiwoom_api_available=kiwoom_available,
            account_connected=account_connected,
            account_info=account_info
        )
        
    except Exception as e:
        logger.error(f"ê±°ë˜ ëª¨ë“œ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to get trading mode status")

@router.post("/system/change-trading-mode")
async def change_trading_mode(request: TradingModeRequest):
    """ê±°ë˜ ëª¨ë“œ ë³€ê²½"""
    global CURRENT_TRADING_MODE, KIWOOM_CLIENT_INSTANCE
    
    try:
        new_mode = request.mode.upper()
        
        if new_mode not in ["DEMO", "REAL"]:
            raise HTTPException(status_code=400, detail="Invalid trading mode")
        
        if new_mode == CURRENT_TRADING_MODE:
            return {"success": True, "message": f"ì´ë¯¸ {new_mode} ëª¨ë“œì…ë‹ˆë‹¤."}
        
        # ì‹¤ê±°ë˜ ëª¨ë“œ ì „í™˜ ì‹œ ì¶”ê°€ ê²€ì¦
        if new_mode == "REAL":
            if not check_windows_environment():
                raise HTTPException(
                    status_code=400, 
                    detail="ì‹¤ê±°ë˜ ëª¨ë“œëŠ” Windows í™˜ê²½ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤."
                )
            
            if not check_kiwoom_api_available():
                raise HTTPException(
                    status_code=400, 
                    detail="í‚¤ì›€ Open APIê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
                )
            
            # í™˜ê²½ë³€ìˆ˜ ì²´í¬
            if not os.getenv("KIWOOM_ACCOUNT"):
                raise HTTPException(
                    status_code=400, 
                    detail="KIWOOM_ACCOUNT í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
                )
            
            if not os.getenv("KIWOOM_PASSWORD"):
                raise HTTPException(
                    status_code=400, 
                    detail="KIWOOM_PASSWORD í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
                )
        
        # ê¸°ì¡´ ì—°ê²° í•´ì œ
        if KIWOOM_CLIENT_INSTANCE:
            try:
                await KIWOOM_CLIENT_INSTANCE.disconnect()
            except:
                pass
            KIWOOM_CLIENT_INSTANCE = None
        
        # ìƒˆë¡œìš´ ëª¨ë“œë¡œ ì „í™˜
        if new_mode == "REAL":
            # ì‹¤ê±°ë˜ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
            from data.kiwoom_real import KiwoomRealClient
            KIWOOM_CLIENT_INSTANCE = KiwoomRealClient()
            
            # ì—°ê²° ì‹œë„
            if not await KIWOOM_CLIENT_INSTANCE.initialize():
                raise HTTPException(status_code=500, detail="í‚¤ì›€ API ì´ˆê¸°í™” ì‹¤íŒ¨")
            
            if not await KIWOOM_CLIENT_INSTANCE.connect():
                raise HTTPException(status_code=500, detail="í‚¤ì›€ API ì—°ê²° ì‹¤íŒ¨")
            
            logger.warning("ì‹¤ê±°ë˜ ëª¨ë“œë¡œ ì „í™˜ë¨")
            
        else:  # DEMO ëª¨ë“œ
            # Mock í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
            from data.kiwoom_mock import KiwoomClient
            KIWOOM_CLIENT_INSTANCE = KiwoomClient()
            await KIWOOM_CLIENT_INSTANCE.connect()
            
            logger.info("ëª¨ì˜íˆ¬ì ëª¨ë“œë¡œ ì „í™˜ë¨")
        
        # ëª¨ë“œ ë³€ê²½
        CURRENT_TRADING_MODE = new_mode
        
        # íŠ¸ë ˆì´ë”© ì—”ì§„ì— ìƒˆë¡œìš´ í´ë¼ì´ì–¸íŠ¸ ì ìš©
        from main import get_trading_engine
        trading_engine = get_trading_engine()
        trading_engine.kiwoom_client = KIWOOM_CLIENT_INSTANCE
        
        # ë°ì´í„°ë² ì´ìŠ¤ì— ëª¨ë“œ ë³€ê²½ ê¸°ë¡
        with get_db_session() as db:
            # ì‹¤ì œë¡œëŠ” SystemLog í…Œì´ë¸”ì— ê¸°ë¡
            pass
        
        return {
            "success": True,
            "message": f"{new_mode} ëª¨ë“œë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.",
            "mode": new_mode,
            "account_connected": KIWOOM_CLIENT_INSTANCE.is_connected if KIWOOM_CLIENT_INSTANCE else False
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ê±°ë˜ ëª¨ë“œ ë³€ê²½ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to change trading mode: {str(e)}")

@router.get("/system/environment-check")
async def check_environment():
    """í™˜ê²½ ì²´í¬ ë° ì„¤ì¹˜ ê°€ì´ë“œ"""
    try:
        checks = {
            "operating_system": {
                "name": platform.system(),
                "version": platform.version(),
                "is_windows": check_windows_environment(),
                "status": "âœ…" if check_windows_environment() else "âŒ"
            },
            "python_version": {
                "version": platform.python_version(),
                "is_compatible": platform.python_version() >= "3.9",
                "status": "âœ…" if platform.python_version() >= "3.9" else "âŒ"
            },
            "required_packages": {},
            "kiwoom_api": {
                "available": check_kiwoom_api_available(),
                "status": "âœ…" if check_kiwoom_api_available() else "âŒ"
            },
            "environment_variables": {
                "kiwoom_account": bool(os.getenv("KIWOOM_ACCOUNT")),
                "kiwoom_password": bool(os.getenv("KIWOOM_PASSWORD")),
                "status": "âœ…" if (os.getenv("KIWOOM_ACCOUNT") and os.getenv("KIWOOM_PASSWORD")) else "âŒ"
            }
        }
        
        # Python íŒ¨í‚¤ì§€ ì²´í¬
        required_packages = ["PyQt5", "pythoncom", "fastapi", "sqlalchemy", "pandas", "numpy"]
        
        for package in required_packages:
            try:
                __import__(package.lower())
                checks["required_packages"][package] = {"installed": True, "status": "âœ…"}
            except ImportError:
                checks["required_packages"][package] = {"installed": False, "status": "âŒ"}
        
        # ì „ì²´ ìƒíƒœ íŒì •
        overall_status = "READY" if all([
            checks["operating_system"]["is_windows"],
            checks["python_version"]["is_compatible"],
            all(pkg["installed"] for pkg in checks["required_packages"].values()),
            checks["kiwoom_api"]["available"]
        ]) else "NOT_READY"
        
        return {
            "overall_status": overall_status,
            "checks": checks,
            "recommendations": get_installation_recommendations(checks)
        }
        
    except Exception as e:
        logger.error(f"í™˜ê²½ ì²´í¬ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to check environment")

def get_installation_recommendations(checks: Dict) -> List[str]:
    """ì„¤ì¹˜ ê¶Œì¥ì‚¬í•­ ìƒì„±"""
    recommendations = []
    
    if not checks["operating_system"]["is_windows"]:
        recommendations.append("ì‹¤ê±°ë˜ë¥¼ ìœ„í•´ì„œëŠ” Windows í™˜ê²½ì´ í•„ìš”í•©ë‹ˆë‹¤.")
    
    if not checks["python_version"]["is_compatible"]:
        recommendations.append("Python 3.9 ì´ìƒìœ¼ë¡œ ì—…ê·¸ë ˆì´ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤.")
    
    missing_packages = [
        pkg for pkg, info in checks["required_packages"].items() 
        if not info["installed"]
    ]
    
    if missing_packages:
        recommendations.append(f"ë‹¤ìŒ íŒ¨í‚¤ì§€ ì„¤ì¹˜ í•„ìš”: {', '.join(missing_packages)}")
        recommendations.append("pip install " + " ".join(missing_packages))
    
    if not checks["kiwoom_api"]["available"]:
        recommendations.extend([
            "í‚¤ì›€ Open API+ ì„¤ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤:",
            "1. í‚¤ì›€ì¦ê¶Œ í™ˆí˜ì´ì§€ â†’ ê³ ê°ì§€ì› â†’ API",
            "2. Open API+ ë‹¤ìš´ë¡œë“œ ë° ì„¤ì¹˜",
            "3. ì‹œìŠ¤í…œ ì¬ë¶€íŒ… í›„ ì¬ì‹œë„"
        ])
    
    if not checks["environment_variables"]["kiwoom_account"]:
        recommendations.extend([
            "í™˜ê²½ë³€ìˆ˜ ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤:",
            "KIWOOM_ACCOUNT=ì‹¤ì œê³„ì¢Œë²ˆí˜¸",
            "KIWOOM_PASSWORD=ì‹¤ì œë¹„ë°€ë²ˆí˜¸"
        ])
    
    if not recommendations:
        recommendations.append("ëª¨ë“  ìš”êµ¬ì‚¬í•­ì´ ì¶©ì¡±ë˜ì—ˆìŠµë‹ˆë‹¤. ì‹¤ê±°ë˜ ì¤€ë¹„ ì™„ë£Œ!")
    
    return recommendations

@router.post("/system/test-connection")
async def test_connection(request: TradingModeRequest):
    """ì—°ê²° í…ŒìŠ¤íŠ¸"""
    try:
        mode = request.mode.upper()
        
        if mode == "DEMO":
            # Mock ì—°ê²° í…ŒìŠ¤íŠ¸
            from data.kiwoom_mock import KiwoomClient
            test_client = KiwoomClient()
            
            if await test_client.connect():
                await test_client.disconnect()
                return {
                    "success": True,
                    "message": "ëª¨ì˜íˆ¬ì ì—°ê²° í…ŒìŠ¤íŠ¸ ì„±ê³µ",
                    "details": {
                        "mode": "DEMO",
                        "connection_time": "< 1ì´ˆ",
                        "account": "ëª¨ì˜ê³„ì¢Œ"
                    }
                }
            else:
                raise HTTPException(status_code=500, detail="ëª¨ì˜íˆ¬ì ì—°ê²° ì‹¤íŒ¨")
        
        elif mode == "REAL":
            # ì‹¤ê±°ë˜ ì—°ê²° í…ŒìŠ¤íŠ¸
            if not check_windows_environment():
                raise HTTPException(status_code=400, detail="Windows í™˜ê²½ì´ ì•„ë‹™ë‹ˆë‹¤")
            
            if not check_kiwoom_api_available():
                raise HTTPException(status_code=400, detail="í‚¤ì›€ APIê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
            
            from data.kiwoom_real import KiwoomRealClient
            test_client = KiwoomRealClient()
            
            if await test_client.initialize():
                if await test_client.connect():
                    account_info = await test_client.get_account_info()
                    await test_client.disconnect()
                    
                    return {
                        "success": True,
                        "message": "ì‹¤ê±°ë˜ ì—°ê²° í…ŒìŠ¤íŠ¸ ì„±ê³µ",
                        "details": {
                            "mode": "REAL",
                            "account": account_info.get("account_number", "í™•ì¸ë¶ˆê°€"),
                            "server_type": account_info.get("server_type", "REAL"),
                            "available_cash": account_info.get("available_cash", 0)
                        }
                    }
                else:
                    raise HTTPException(status_code=500, detail="í‚¤ì›€ API ë¡œê·¸ì¸ ì‹¤íŒ¨")
            else:
                raise HTTPException(status_code=500, detail="í‚¤ì›€ API ì´ˆê¸°í™” ì‹¤íŒ¨")
        
        else:
            raise HTTPException(status_code=400, detail="ì˜ëª»ëœ ëª¨ë“œì…ë‹ˆë‹¤")
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ì—°ê²° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail=f"Connection test failed: {str(e)}")

@router.get("/system/trading-mode-guide")
async def get_trading_mode_guide():
    """ê±°ë˜ ëª¨ë“œ ê°€ì´ë“œ"""
    return {
        "modes": {
            "DEMO": {
                "name": "ëª¨ì˜íˆ¬ì ëª¨ë“œ",
                "description": "ê°€ìƒì˜ ëˆìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ê±°ë˜ ì—°ìŠµ",
                "pros": [
                    "ì‹¤ì œ ëˆ ì†ì‹¤ ìœ„í—˜ ì—†ìŒ",
                    "ëª¨ë“  í”Œë«í¼ì—ì„œ ì‹¤í–‰ ê°€ëŠ¥",
                    "ë¬´ì œí•œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥",
                    "ì „ëµ ê°œë°œ ë° ê²€ì¦ì— ìµœì "
                ],
                "cons": [
                    "ì‹¤ì œ ìˆ˜ìµ ë¶ˆê°€ëŠ¥",
                    "ì‹œë®¬ë ˆì´ì…˜ ë°ì´í„° ì‚¬ìš©",
                    "ì‹¤ì œ ì‹œì¥ê³¼ ë¯¸ì„¸í•œ ì°¨ì´ ê°€ëŠ¥"
                ],
                "recommended_for": [
                    "í€€íŠ¸ íŠ¸ë ˆì´ë”© ì´ˆë³´ì",
                    "ìƒˆë¡œìš´ ì „ëµ í…ŒìŠ¤íŠ¸",
                    "ì‹œìŠ¤í…œ ì•ˆì •ì„± í™•ì¸",
                    "êµìœ¡ ëª©ì "
                ]
            },
            "REAL": {
                "name": "ì‹¤ê±°ë˜ ëª¨ë“œ",
                "description": "ì‹¤ì œ ëˆìœ¼ë¡œ ì§„ì§œ ê±°ë˜ ì‹¤í–‰",
                "pros": [
                    "ì‹¤ì œ ìˆ˜ìµ ê°€ëŠ¥",
                    "ì§„ì§œ ì‹œì¥ ë°ì´í„° ì‚¬ìš©",
                    "ì™„ì „í•œ ê±°ë˜ ê²½í—˜"
                ],
                "cons": [
                    "íˆ¬ì ì†ì‹¤ ìœ„í—˜",
                    "Windows í™˜ê²½ í•„ìˆ˜",
                    "í‚¤ì›€ì¦ê¶Œ ê³„ì¢Œ í•„ìš”",
                    "ì‹œìŠ¤í…œ ì˜¤ë¥˜ ì‹œ ì‹¤ì œ ì†ì‹¤ ê°€ëŠ¥"
                ],
                "recommended_for": [
                    "ì¶©ë¶„í•œ ê²½í—˜ì",
                    "ëª¨ì˜íˆ¬ì ê²€ì¦ ì™„ë£Œì",
                    "ì†Œì•¡ íˆ¬ì ê°€ëŠ¥ì",
                    "ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ê°€ëŠ¥ì"
                ],
                "requirements": [
                    "Windows 10 ì´ìƒ",
                    "í‚¤ì›€ì¦ê¶Œ ê³„ì¢Œ",
                    "í‚¤ì›€ Open API+ ì„¤ì¹˜",
                    "Python 3.9+",
                    "ì•ˆì •ì ì¸ ì¸í„°ë„· ì—°ê²°"
                ]
            }
        },
        "transition_guide": {
            "step1": "ëª¨ì˜íˆ¬ìë¡œ ìµœì†Œ 1ê°œì›” í…ŒìŠ¤íŠ¸",
            "step2": "ëª¨ë“  ì „ëµì˜ ìˆ˜ìµì„± ê²€ì¦",
            "step3": "ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì„¤ì • ìµœì í™”",
            "step4": "Windows í™˜ê²½ ë° í‚¤ì›€ API ì„¤ì¹˜",
            "step5": "ì‹¤ê±°ë˜ í™˜ê²½ë³€ìˆ˜ ì„¤ì •",
            "step6": "ì†Œì•¡(5-10ë§Œì›)ìœ¼ë¡œ ì‹¤ê±°ë˜ ì‹œì‘",
            "step7": "ì•ˆì •ì„± í™•ì¸ í›„ ì ì§„ì  ì¦ì•¡"
        },
        "safety_tips": [
            "í•­ìƒ ì†ì ˆì„ ì„ ì„¤ì •í•˜ì„¸ìš”",
            "ì¼ì¼ ì†ì‹¤ í•œë„ë¥¼ ì„¤ì •í•˜ì„¸ìš”",
            "íˆ¬ì ê°€ëŠ¥í•œ ëˆìœ¼ë¡œë§Œ ê±°ë˜í•˜ì„¸ìš”",
            "ì‹œìŠ¤í…œì„ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§í•˜ì„¸ìš”",
            "ì •ê¸°ì ìœ¼ë¡œ ë°±ì—…ì„ ìƒì„±í•˜ì„¸ìš”",
            "ë„¤íŠ¸ì›Œí¬ ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”",
            "ê¸´ê¸‰ìƒí™© ì‹œ ìˆ˜ë™ ê°œì… ë°©ë²•ì„ ìˆ™ì§€í•˜ì„¸ìš”"
        ]
    }

def get_current_trading_mode():
    """í˜„ì¬ ê±°ë˜ ëª¨ë“œ ë°˜í™˜"""
    return CURRENT_TRADING_MODE

def get_current_kiwoom_client():
    """í˜„ì¬ í‚¤ì›€ í´ë¼ì´ì–¸íŠ¸ ë°˜í™˜"""
    return KIWOOM_CLIENT_INSTANCE

# ì˜ì¡´ì„± ì£¼ì…ìš© í•¨ìˆ˜ë“¤
def get_trading_mode():
    """ê±°ë˜ ëª¨ë“œ ì˜ì¡´ì„±"""
    return CURRENT_TRADING_MODE

def get_kiwoom_client():
    """í‚¤ì›€ í´ë¼ì´ì–¸íŠ¸ ì˜ì¡´ì„±"""
    if KIWOOM_CLIENT_INSTANCE is None:
        raise HTTPException(status_code=503, detail="í‚¤ì›€ í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
    return KIWOOM_CLIENT_INSTANCE


==================================================
File: C:\Aproject\test\quant_actual\backend\api.py
==================================================
# file: backend/api.py

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime, timedelta
import json
import logging

from database import get_db, DatabaseManager
from models import *
from trading_engine_manager import get_trading_engine

logger = logging.getLogger(__name__)
router = APIRouter()

# í¬íŠ¸í´ë¦¬ì˜¤ API
@router.get("/portfolio", response_model=PortfolioResponse)
async def get_portfolio_status(db: Session = Depends(get_db)):
    """í¬íŠ¸í´ë¦¬ì˜¤ í˜„í™© ì¡°íšŒ"""
    try:
        # ìµœì‹  í¬íŠ¸í´ë¦¬ì˜¤ ì •ë³´ ì¡°íšŒ
        portfolio = db.query(Portfolio).order_by(Portfolio.timestamp.desc()).first()
        
        if not portfolio:
            # í¬íŠ¸í´ë¦¬ì˜¤ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ìƒì„±
            portfolio = Portfolio(
                total_value=50000000.0,
                cash=24000000.0,
                invested_amount=26000000.0,
                realized_pnl=0.0,
                unrealized_pnl=0.0,
                daily_pnl=0.0,
                total_return=0.0
            )
            db.add(portfolio)
            db.commit()
            db.refresh(portfolio)
        
        return portfolio
    except Exception as e:
        logger.error(f"í¬íŠ¸í´ë¦¬ì˜¤ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch portfolio")

@router.get("/portfolio/positions", response_model=List[PositionResponse])
async def get_current_positions(db: Session = Depends(get_db)):
    """í˜„ì¬ í¬ì§€ì…˜ ì¡°íšŒ"""
    try:
        positions = db.query(Position)\
            .join(Strategy)\
            .join(Stock)\
            .filter(Position.quantity > 0)\
            .all()
        
        return [
            PositionResponse(
                id=pos.id,
                strategy_name=pos.strategy.name,
                stock_code=pos.stock.code,
                stock_name=pos.stock.name,
                quantity=pos.quantity,
                avg_price=pos.avg_price,
                current_price=pos.current_price or pos.avg_price,
                unrealized_pnl=pos.unrealized_pnl,
                realized_pnl=pos.realized_pnl
            )
            for pos in positions
        ]
    except Exception as e:
        logger.error(f"í¬ì§€ì…˜ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch positions")

# ì „ëµ ê´€ë¦¬ API
@router.get("/strategies", response_model=List[StrategyResponse])
async def get_strategies(db: Session = Depends(get_db)):
    """ì „ëµ ëª©ë¡ ì¡°íšŒ"""
    try:
        strategies = db.query(Strategy).all()
        return strategies
    except Exception as e:
        logger.error(f"ì „ëµ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch strategies")

@router.post("/strategies", response_model=StrategyResponse)
async def create_strategy(strategy: StrategyCreate, db: Session = Depends(get_db)):
    """ìƒˆ ì „ëµ ìƒì„±"""
    try:
        db_strategy = Strategy(
            name=strategy.name,
            strategy_type=strategy.strategy_type,
            is_active=strategy.is_active,
            investment_amount=strategy.investment_amount,
            target_stocks=json.dumps(strategy.target_stocks),
            parameters=json.dumps(strategy.parameters)
        )
        db.add(db_strategy)
        db.commit()
        db.refresh(db_strategy)
        
        logger.info(f"ìƒˆ ì „ëµ ìƒì„±: {strategy.name}")
        return db_strategy
    except Exception as e:
        logger.error(f"ì „ëµ ìƒì„± ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to create strategy")

@router.patch("/strategies/{strategy_id}", response_model=StrategyResponse)
async def update_strategy(
    strategy_id: int, 
    strategy_update: StrategyUpdate, 
    db: Session = Depends(get_db)
):
    """ì „ëµ ì •ë³´ ì—…ë°ì´íŠ¸"""
    try:
        db_strategy = db.query(Strategy).filter(Strategy.id == strategy_id).first()
        if not db_strategy:
            raise HTTPException(status_code=404, detail="Strategy not found")
        
        # ì—…ë°ì´íŠ¸í•  í•„ë“œë“¤ë§Œ ë³€ê²½
        update_data = strategy_update.dict(exclude_unset=True)
        
        if 'target_stocks' in update_data:
            update_data['target_stocks'] = json.dumps(update_data['target_stocks'])
        if 'parameters' in update_data:
            update_data['parameters'] = json.dumps(update_data['parameters'])
        
        for field, value in update_data.items():
            setattr(db_strategy, field, value)
        
        db_strategy.updated_at = datetime.utcnow()
        db.commit()
        db.refresh(db_strategy)
        
        logger.info(f"ì „ëµ ì—…ë°ì´íŠ¸: {db_strategy.name}")
        return db_strategy
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ì „ëµ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to update strategy")

@router.post("/strategies/toggle")
async def toggle_strategy(
    request: dict, 
    db: Session = Depends(get_db),
    background_tasks: BackgroundTasks = BackgroundTasks()
):
    """ì „ëµ í™œì„±í™”/ë¹„í™œì„±í™”"""
    try:
        strategy_id = request.get("id")
        new_active_state = request.get("active", False)
        
        db_strategy = db.query(Strategy).filter(Strategy.id == strategy_id).first()
        if not db_strategy:
            raise HTTPException(status_code=404, detail="Strategy not found")
        
        db_strategy.is_active = new_active_state
        db_strategy.updated_at = datetime.utcnow()
        db.commit()
        
        # íŠ¸ë ˆì´ë”© ì—”ì§„ì— ì „ëµ ë³€ê²½ ì•Œë¦¼ (ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…)
        trading_engine = get_trading_engine()
        if new_active_state:
            background_tasks.add_task(trading_engine.activate_strategy, strategy_id)
        else:
            background_tasks.add_task(trading_engine.deactivate_strategy, strategy_id)
        
        status = "í™œì„±í™”" if new_active_state else "ë¹„í™œì„±í™”"
        logger.info(f"ì „ëµ {status}: {db_strategy.name}")
        
        return {
            "success": True,
            "message": f"ì „ëµì´ {status}ë˜ì—ˆìŠµë‹ˆë‹¤.",
            "strategy_id": strategy_id,
            "is_active": new_active_state
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ì „ëµ í† ê¸€ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to toggle strategy")

# ì£¼ë¬¸ ê´€ë¦¬ API
@router.get("/orders", response_model=List[OrderResponse])
async def get_recent_orders(
    limit: int = 50, 
    status: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­ ì¡°íšŒ"""
    try:
        query = db.query(Order)\
            .join(Stock)\
            .join(Strategy)\
            .order_by(Order.order_time.desc())
        
        if status:
            query = query.filter(Order.status == status)
        
        orders = query.limit(limit).all()
        
        return [
            OrderResponse(
                id=order.id,
                strategy_id=order.strategy_id,
                stock_code=order.stock.code,
                stock_name=order.stock.name,
                order_type=order.order_type,
                quantity=order.quantity,
                price=order.price,
                status=order.status,
                order_time=order.order_time,
                fill_time=order.fill_time,
                fill_price=order.fill_price,
                fill_quantity=order.fill_quantity
            )
            for order in orders
        ]
    except Exception as e:
        logger.error(f"ì£¼ë¬¸ ë‚´ì—­ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch orders")

@router.post("/orders")
async def create_manual_order(
    order: OrderCreate,
    db: Session = Depends(get_db)
):
    """ìˆ˜ë™ ì£¼ë¬¸ ìƒì„±"""
    try:
        # ì£¼ì‹ ì •ë³´ ì¡°íšŒ
        stock = db.query(Stock).filter(Stock.code == order.stock_code).first()
        if not stock:
            raise HTTPException(status_code=404, detail="Stock not found")
        
        # ì „ëµ ì¡°íšŒ
        strategy = db.query(Strategy).filter(Strategy.id == order.strategy_id).first()
        if not strategy:
            raise HTTPException(status_code=404, detail="Strategy not found")
        
        # ì£¼ë¬¸ ìƒì„±
        db_order = Order(
            strategy_id=order.strategy_id,
            stock_id=stock.id,
            order_type=order.order_type,
            quantity=order.quantity,
            price=order.price,
            status="pending"
        )
        db.add(db_order)
        db.commit()
        db.refresh(db_order)
        
        # íŠ¸ë ˆì´ë”© ì—”ì§„ì— ì£¼ë¬¸ ì‹¤í–‰ ìš”ì²­
        trading_engine = get_trading_engine()
        await trading_engine.execute_manual_order(db_order.id)
        
        logger.info(f"ìˆ˜ë™ ì£¼ë¬¸ ìƒì„±: {stock.name} {order.order_type} {order.quantity}ì£¼")
        return {"success": True, "order_id": db_order.id, "message": "ì£¼ë¬¸ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤."}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ìˆ˜ë™ ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to create order")

# íŠ¸ë ˆì´ë”© ì œì–´ API
@router.post("/trading/start")
async def start_trading():
    """ìë™ë§¤ë§¤ ì‹œì‘"""
    try:
        trading_engine = get_trading_engine()
        await trading_engine.start_trading()
        
        logger.info("ìë™ë§¤ë§¤ ì‹œì‘ë¨")
        return {"success": True, "message": "ìë™ë§¤ë§¤ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤."}
        
    except Exception as e:
        logger.error(f"ìë™ë§¤ë§¤ ì‹œì‘ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to start trading")

@router.post("/trading/stop")
async def stop_trading():
    """ìë™ë§¤ë§¤ ì¤‘ì§€"""
    try:
        trading_engine = get_trading_engine()
        await trading_engine.stop_trading()
        
        logger.info("ìë™ë§¤ë§¤ ì¤‘ì§€ë¨")
        return {"success": True, "message": "ìë™ë§¤ë§¤ê°€ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤."}
        
    except Exception as e:
        logger.error(f"ìë™ë§¤ë§¤ ì¤‘ì§€ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to stop trading")

@router.post("/trading/emergency-stop")
async def emergency_stop():
    """ê¸´ê¸‰ ì¤‘ë‹¨"""
    try:
        trading_engine = get_trading_engine()
        await trading_engine.emergency_stop()
        
        logger.critical("ê¸´ê¸‰ì¤‘ë‹¨ ì‹¤í–‰ë¨")
        return {"success": True, "message": "ê¸´ê¸‰ì¤‘ë‹¨ì´ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤."}
        
    except Exception as e:
        logger.error(f"ê¸´ê¸‰ì¤‘ë‹¨ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to emergency stop")

# ì¢…ëª© ì •ë³´ API
@router.get("/stocks", response_model=List[StockResponse])
async def get_stocks(db: Session = Depends(get_db)):
    """ì¢…ëª© ëª©ë¡ ì¡°íšŒ"""
    try:
        stocks = db.query(Stock).all()
        return stocks
    except Exception as e:
        logger.error(f"ì¢…ëª© ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch stocks")

@router.get("/stocks/{stock_code}")
async def get_stock_info(stock_code: str, db: Session = Depends(get_db)):
    """íŠ¹ì • ì¢…ëª© ì •ë³´ ì¡°íšŒ"""
    try:
        stock = db.query(Stock).filter(Stock.code == stock_code).first()
        if not stock:
            raise HTTPException(status_code=404, detail="Stock not found")
        
        return stock
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ì¢…ëª© ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch stock info")

@router.get("/stocks/{stock_code}/price-history")
async def get_price_history(
    stock_code: str, 
    days: int = 30, 
    db: Session = Depends(get_db)
):
    """ì¢…ëª© ê°€ê²© íˆìŠ¤í† ë¦¬ ì¡°íšŒ"""
    try:
        stock = db.query(Stock).filter(Stock.code == stock_code).first()
        if not stock:
            raise HTTPException(status_code=404, detail="Stock not found")
        
        start_date = datetime.utcnow() - timedelta(days=days)
        price_history = db.query(PriceHistory)\
            .filter(PriceHistory.stock_id == stock.id)\
            .filter(PriceHistory.timestamp >= start_date)\
            .order_by(PriceHistory.timestamp.desc())\
            .all()
        
        return [
            {
                "price": ph.price,
                "volume": ph.volume,
                "timestamp": ph.timestamp
            }
            for ph in price_history
        ]
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ê°€ê²© íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch price history")

# ë°±í…ŒìŠ¤íŠ¸ API
@router.post("/backtest/run", response_model=BacktestResponse)
async def run_backtest(
    backtest_request: BacktestRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""
    try:
        # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰
        from trading.backtest import BacktestEngine
        
        backtest_engine = BacktestEngine()
        results = await backtest_engine.run_backtest(
            strategy_type=backtest_request.strategy_type,
            parameters=backtest_request.parameters,
            target_stocks=backtest_request.target_stocks,
            start_date=backtest_request.start_date,
            end_date=backtest_request.end_date,
            initial_capital=backtest_request.initial_capital
        )
        
        # ê²°ê³¼ë¥¼ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
        backtest_result = BacktestResult(
            strategy_name=backtest_request.strategy_type,
            start_date=backtest_request.start_date,
            end_date=backtest_request.end_date,
            total_return=results['total_return'],
            annual_return=results['annual_return'],
            max_drawdown=results['max_drawdown'],
            sharpe_ratio=results['sharpe_ratio'],
            win_rate=results['win_rate'],
            total_trades=results['total_trades'],
            results_data=json.dumps(results)
        )
        db.add(backtest_result)
        db.commit()
        
        logger.info(f"ë°±í…ŒìŠ¤íŠ¸ ì™„ë£Œ: {backtest_request.strategy_type}")
        return BacktestResponse(**results)
        
    except Exception as e:
        logger.error(f"ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to run backtest")

@router.get("/backtest/history")
async def get_backtest_history(
    limit: int = 10,
    db: Session = Depends(get_db)
):
    """ë°±í…ŒìŠ¤íŠ¸ íˆìŠ¤í† ë¦¬ ì¡°íšŒ"""
    try:
        results = db.query(BacktestResult)\
            .order_by(BacktestResult.created_at.desc())\
            .limit(limit)\
            .all()
        
        return [
            {
                "id": result.id,
                "strategy_name": result.strategy_name,
                "start_date": result.start_date,
                "end_date": result.end_date,
                "total_return": result.total_return,
                "annual_return": result.annual_return,
                "max_drawdown": result.max_drawdown,
                "sharpe_ratio": result.sharpe_ratio,
                "win_rate": result.win_rate,
                "total_trades": result.total_trades,
                "created_at": result.created_at
            }
            for result in results
        ]
    except Exception as e:
        logger.error(f"ë°±í…ŒìŠ¤íŠ¸ íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch backtest history")

# ì‹¤ì‹œê°„ ë°ì´í„° API
@router.get("/realtime/market-data")
async def get_realtime_market_data():
    """ì‹¤ì‹œê°„ ì‹œì¥ ë°ì´í„° ì¡°íšŒ"""
    try:
        trading_engine = get_trading_engine()
        market_data = await trading_engine.get_market_data()
        
        return market_data
    except Exception as e:
        logger.error(f"ì‹¤ì‹œê°„ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch market data")

@router.get("/realtime/signals")
async def get_recent_signals(limit: int = 20):
    """ìµœê·¼ íŠ¸ë ˆì´ë”© ì‹ í˜¸ ì¡°íšŒ"""
    try:
        trading_engine = get_trading_engine()
        signals = await trading_engine.get_recent_signals(limit)
        
        return signals
    except Exception as e:
        logger.error(f"ì‹ í˜¸ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch signals")

# ë¦¬ìŠ¤í¬ ê´€ë¦¬ API
@router.get("/risk/metrics", response_model=RiskMetrics)
async def get_risk_metrics():
    """ë¦¬ìŠ¤í¬ ì§€í‘œ ì¡°íšŒ"""
    try:
        trading_engine = get_trading_engine()
        risk_metrics = await trading_engine.get_risk_metrics()
        
        return risk_metrics
    except Exception as e:
        logger.error(f"ë¦¬ìŠ¤í¬ ì§€í‘œ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch risk metrics")

@router.post("/risk/update-limits")
async def update_risk_limits(risk_limits: dict):
    """ë¦¬ìŠ¤í¬ í•œë„ ì—…ë°ì´íŠ¸"""
    try:
        trading_engine = get_trading_engine()
        await trading_engine.update_risk_limits(risk_limits)
        
        logger.info("ë¦¬ìŠ¤í¬ í•œë„ ì—…ë°ì´íŠ¸ë¨")
        return {"success": True, "message": "ë¦¬ìŠ¤í¬ í•œë„ê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤."}
        
    except Exception as e:
        logger.error(f"ë¦¬ìŠ¤í¬ í•œë„ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to update risk limits")

# ì‹œìŠ¤í…œ ì •ë³´ API
@router.get("/system/status", response_model=SystemStatus)
async def get_system_status():
    """ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ"""
    try:
        trading_engine = get_trading_engine()
        
        return SystemStatus(
            is_running=trading_engine.is_running,
            api_connected=trading_engine.kiwoom_client.is_connected,
            active_strategies=len(trading_engine.get_active_strategies()),
            current_positions=len(trading_engine.get_current_positions()),
            total_orders_today=trading_engine.get_daily_order_count(),
            last_update=trading_engine.last_update
        )
    except Exception as e:
        logger.error(f"ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch system status")

@router.post("/system/backup")
async def create_backup():
    """ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ìƒì„±"""
    try:
        from database import backup_database
        backup_path = backup_database()
        
        logger.info(f"ë°±ì—… ìƒì„± ì™„ë£Œ: {backup_path}")
        return {
            "success": True,
            "message": "ë°±ì—…ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.",
            "backup_path": str(backup_path)
        }
    except Exception as e:
        logger.error(f"ë°±ì—… ìƒì„± ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to create backup") 



==================================================
File: C:\Aproject\test\quant_actual\backend\database.py
==================================================
# file: backend/database.py

from sqlalchemy import create_engine, event
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.pool import StaticPool
import sqlite3
from contextlib import contextmanager
import logging
from pathlib import Path

from models import Base
from utils.config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

# ë°ì´í„°ë² ì´ìŠ¤ íŒŒì¼ ê²½ë¡œ
DATABASE_DIR = Path("data")
DATABASE_DIR.mkdir(exist_ok=True)
DATABASE_URL = f"sqlite:///{DATABASE_DIR}/quantrade.db"

# SQLAlchemy ì—”ì§„ ìƒì„±
engine = create_engine(
    DATABASE_URL,
    connect_args={
        "check_same_thread": False,
        "timeout": 30
    },
    poolclass=StaticPool,
    echo=settings.debug  # ê°œë°œ ëª¨ë“œì—ì„œ SQL ì¿¼ë¦¬ ë¡œê·¸ ì¶œë ¥
)

# ì„¸ì…˜ íŒ©í† ë¦¬
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# SQLite ìµœì í™” ì„¤ì •
@event.listens_for(engine, "connect")
def set_sqlite_pragma(dbapi_connection, connection_record):
    """SQLite ì—°ê²° ì‹œ ì„±ëŠ¥ ìµœì í™” ì„¤ì •"""
    if isinstance(dbapi_connection, sqlite3.Connection):
        cursor = dbapi_connection.cursor()
        
        # ì„±ëŠ¥ ìµœì í™” ì„¤ì •
        cursor.execute("PRAGMA journal_mode=WAL")  # Write-Ahead Logging
        cursor.execute("PRAGMA synchronous=NORMAL")  # ë¹ ë¥¸ ì“°ê¸°
        cursor.execute("PRAGMA cache_size=10000")  # ìºì‹œ í¬ê¸° ì¦ê°€
        cursor.execute("PRAGMA temp_store=MEMORY")  # ì„ì‹œ ë°ì´í„°ë¥¼ ë©”ëª¨ë¦¬ì—
        cursor.execute("PRAGMA mmap_size=268435456")  # ë©”ëª¨ë¦¬ ë§µ í¬ê¸° (256MB)
        
        # ì™¸ë˜í‚¤ ì œì•½ì¡°ê±´ í™œì„±í™”
        cursor.execute("PRAGMA foreign_keys=ON")
        
        cursor.close()

def init_db():
    """ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” - í…Œì´ë¸” ìƒì„± ë° ì´ˆê¸° ë°ì´í„° ì‚½ì…"""
    try:
        # ëª¨ë“  í…Œì´ë¸” ìƒì„±
        Base.metadata.create_all(bind=engine)
        logger.info("ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸” ìƒì„± ì™„ë£Œ")
        
        # ì´ˆê¸° ë°ì´í„° ì‚½ì…
        create_initial_data()
        logger.info("ì´ˆê¸° ë°ì´í„° ìƒì„± ì™„ë£Œ")
        
    except Exception as e:
        logger.error(f"ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
        raise

def create_initial_data():
    """ì´ˆê¸° ë°ì´í„° ìƒì„±"""
    from models import Strategy, Stock, Portfolio
    import json
    
    with get_db_session() as db:
        # ì£¼ìš” ì¢…ëª© ë°ì´í„° ìƒì„±
        if not db.query(Stock).first():
            initial_stocks = [
                {"code": "005930", "name": "ì‚¼ì„±ì „ì", "market": "KOSPI"},
                {"code": "000660", "name": "SKí•˜ì´ë‹‰ìŠ¤", "market": "KOSPI"},
                {"code": "035420", "name": "NAVER", "market": "KOSPI"},
                {"code": "035720", "name": "ì¹´ì¹´ì˜¤", "market": "KOSPI"},
                {"code": "051910", "name": "LGí™”í•™", "market": "KOSPI"},
                {"code": "006400", "name": "ì‚¼ì„±SDI", "market": "KOSPI"},
                {"code": "207940", "name": "ì‚¼ì„±ë°”ì´ì˜¤ë¡œì§ìŠ¤", "market": "KOSPI"},
                {"code": "373220", "name": "LGì—ë„ˆì§€ì†”ë£¨ì…˜", "market": "KOSPI"},
            ]
            
            for stock_data in initial_stocks:
                stock = Stock(**stock_data)
                db.add(stock)
        
        # ê¸°ë³¸ ì „ëµ ìƒì„±
        if not db.query(Strategy).first():
            strategies = [
                {
                    "name": "ë³¼ë¦°ì €ë°´ë“œ í‰ê· íšŒê·€",
                    "strategy_type": "bollinger_bands",
                    "is_active": True,
                    "investment_amount": 10000000.0,  # 1ì²œë§Œì›
                    "target_stocks": json.dumps(["005930", "000660", "035420"]),
                    "parameters": json.dumps({
                        "period": 20,
                        "std_multiplier": 2.0,
                        "stop_loss": 0.05,
                        "take_profit": 0.03
                    })
                },
                {
                    "name": "RSI ì—­ì¶”ì„¸",
                    "strategy_type": "rsi_reversal",
                    "is_active": True,
                    "investment_amount": 8000000.0,  # 8ë°±ë§Œì›
                    "target_stocks": json.dumps(["035720", "051910"]),
                    "parameters": json.dumps({
                        "period": 14,
                        "oversold": 30,
                        "overbought": 70,
                        "stop_loss": 0.04
                    })
                },
                {
                    "name": "ëª¨ë©˜í…€ ì¶”ì„¸ì¶”ì¢…",
                    "strategy_type": "momentum",
                    "is_active": False,
                    "investment_amount": 5000000.0,  # 5ë°±ë§Œì›
                    "target_stocks": json.dumps(["006400", "207940"]),
                    "parameters": json.dumps({
                        "short_period": 12,
                        "long_period": 26,
                        "signal_period": 9
                    })
                },
                {
                    "name": "ì´ë™í‰ê·  ê³¨ë“ í¬ë¡œìŠ¤",
                    "strategy_type": "moving_average",
                    "is_active": False,
                    "investment_amount": 3000000.0,  # 3ë°±ë§Œì›
                    "target_stocks": json.dumps(["373220"]),
                    "parameters": json.dumps({
                        "short_ma": 5,
                        "long_ma": 20,
                        "volume_threshold": 1000000
                    })
                }
            ]
            
            for strategy_data in strategies:
                strategy = Strategy(**strategy_data)
                db.add(strategy)
        
        # ì´ˆê¸° í¬íŠ¸í´ë¦¬ì˜¤ ìƒì„±
        if not db.query(Portfolio).first():
            initial_portfolio = Portfolio(
                total_value=50000000.0,  # 5ì²œë§Œì›
                cash=24000000.0,  # í˜„ê¸ˆ 2ì²œ4ë°±ë§Œì›
                invested_amount=26000000.0,  # íˆ¬ìê¸ˆ 2ì²œ6ë°±ë§Œì›
                realized_pnl=0.0,
                unrealized_pnl=0.0,
                daily_pnl=0.0,
                total_return=0.0
            )
            db.add(initial_portfolio)
        
        db.commit()

@contextmanager
def get_db_session():
    """ë°ì´í„°ë² ì´ìŠ¤ ì„¸ì…˜ ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì €"""
    db = SessionLocal()
    try:
        yield db
    except Exception as e:
        logger.error(f"ë°ì´í„°ë² ì´ìŠ¤ ì˜¤ë¥˜: {e}")
        db.rollback()
        raise
    finally:
        db.close()

def get_db():
    """FastAPI ì˜ì¡´ì„± ì£¼ì…ìš© ë°ì´í„°ë² ì´ìŠ¤ ì„¸ì…˜"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ë°ì´í„°ë² ì´ìŠ¤ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
class DatabaseManager:
    """ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    @staticmethod
    def get_portfolio_summary():
        """í¬íŠ¸í´ë¦¬ì˜¤ ìš”ì•½ ì •ë³´ ì¡°íšŒ"""
        from models import Portfolio, Position, Stock
        
        with get_db_session() as db:
            # ìµœì‹  í¬íŠ¸í´ë¦¬ì˜¤ ì •ë³´
            portfolio = db.query(Portfolio).order_by(Portfolio.timestamp.desc()).first()
            
            # í˜„ì¬ í¬ì§€ì…˜ ì •ë³´
            positions = db.query(Position)\
                .join(Stock)\
                .filter(Position.quantity > 0)\
                .all()
            
            return {
                "portfolio": portfolio,
                "positions": positions,
                "position_count": len(positions)
            }
    
    @staticmethod
    def get_active_strategies():
        """í™œì„±í™”ëœ ì „ëµ ëª©ë¡ ì¡°íšŒ"""
        from models import Strategy
        
        with get_db_session() as db:
            return db.query(Strategy).filter(Strategy.is_active == True).all()
    
    @staticmethod
    def get_recent_orders(limit: int = 50):
        """ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­ ì¡°íšŒ"""
        from models import Order, Stock, Strategy
        
        with get_db_session() as db:
            return db.query(Order)\
                .join(Stock)\
                .join(Strategy)\
                .order_by(Order.order_time.desc())\
                .limit(limit)\
                .all()
    
    @staticmethod
    def update_portfolio(portfolio_data: dict):
        """í¬íŠ¸í´ë¦¬ì˜¤ ì •ë³´ ì—…ë°ì´íŠ¸"""
        from models import Portfolio
        
        with get_db_session() as db:
            portfolio = Portfolio(**portfolio_data)
            db.add(portfolio)
            db.commit()
            return portfolio
    
    @staticmethod
    def update_stock_price(stock_code: str, price: float, volume: int = 0):
        """ì¢…ëª© ê°€ê²© ì—…ë°ì´íŠ¸"""
        from models import Stock, PriceHistory
        from datetime import datetime
        
        with get_db_session() as db:
            # ì¢…ëª© í˜„ì¬ê°€ ì—…ë°ì´íŠ¸
            stock = db.query(Stock).filter(Stock.code == stock_code).first()
            if stock:
                stock.current_price = price
                stock.volume = volume
                stock.updated_at = datetime.utcnow()
                
                # ê°€ê²© íˆìŠ¤í† ë¦¬ ì €ì¥
                price_history = PriceHistory(
                    stock_id=stock.id,
                    price=price,
                    volume=volume,
                    timestamp=datetime.utcnow()
                )
                db.add(price_history)
                db.commit()
    
    @staticmethod
    def cleanup_old_data(days: int = 30):
        """ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬"""
        from models import PriceHistory, Portfolio
        from datetime import datetime, timedelta
        
        cutoff_date = datetime.utcnow() - timedelta(days=days)
        
        with get_db_session() as db:
            # ì˜¤ë˜ëœ ê°€ê²© íˆìŠ¤í† ë¦¬ ì‚­ì œ (ìµœê·¼ 30ì¼ë§Œ ë³´ê´€)
            db.query(PriceHistory)\
                .filter(PriceHistory.timestamp < cutoff_date)\
                .delete()
            
            # ì˜¤ë˜ëœ í¬íŠ¸í´ë¦¬ì˜¤ ìŠ¤ëƒ…ìƒ· ì‚­ì œ (ìµœê·¼ 30ì¼ë§Œ ë³´ê´€)
            db.query(Portfolio)\
                .filter(Portfolio.timestamp < cutoff_date)\
                .delete()
            
            db.commit()
            logger.info(f"{days}ì¼ ì´ì „ ë°ì´í„° ì •ë¦¬ ì™„ë£Œ")

def backup_database(backup_path: str = None):
    """ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—…"""
    from shutil import copy2
    from datetime import datetime
    
    if not backup_path:
        backup_dir = Path("backups")
        backup_dir.mkdir(exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = backup_dir / f"quantrade_backup_{timestamp}.db"
    
    try:
        copy2(DATABASE_DIR / "quantrade.db", backup_path)
        logger.info(f"ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ì™„ë£Œ: {backup_path}")
        return backup_path
    except Exception as e:
        logger.error(f"ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ì‹¤íŒ¨: {e}")
        raise

# ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ ì²´í¬
def check_database_health():
    """ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ ì²´í¬"""
    try:
        with get_db_session() as db:
            # ê°„ë‹¨í•œ ì¿¼ë¦¬ë¡œ ì—°ê²° í…ŒìŠ¤íŠ¸
            db.execute("SELECT 1")
            return True
    except Exception as e:
        logger.error(f"ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨: {e}")
        return False



==================================================
File: C:\Aproject\test\quant_actual\backend\main.py
==================================================
# file: backend/main.py

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import asyncio
import uvicorn
from datetime import datetime
import logging
import os

from database import init_db
from api import router
from trading_mode_api import router as mode_router, get_current_trading_mode, get_current_kiwoom_client
from trading.engine import TradingEngine
from utils.logger import setup_logger
from utils.config import get_settings

# ë¡œê¹… ì„¤ì •
logger = setup_logger()
settings = get_settings()

# ì „ì—­ ë³€ìˆ˜
trading_engine = None
background_task = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    """ì•± ì‹œì‘/ì¢…ë£Œ ì‹œ ì‹¤í–‰ë  ë¡œì§"""
    global trading_engine, background_task
    
    logger.info("í€€íŠ¸ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ ì‹œì‘ ì¤‘...")
    
    # ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”
    init_db()
    
    # ì´ˆê¸° ê±°ë˜ ëª¨ë“œ ì„¤ì • (í™˜ê²½ë³€ìˆ˜ ë˜ëŠ” ê¸°ë³¸ê°’)
    initial_mode = os.getenv("INITIAL_TRADING_MODE", "DEMO")
    logger.info(f"ì´ˆê¸° ê±°ë˜ ëª¨ë“œ: {initial_mode}")
    
    # í‚¤ì›€ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” (ëª¨ë“œì— ë”°ë¼)
    kiwoom_client = None
    if initial_mode == "REAL":
        try:
            # Windows í™˜ê²½ ì²´í¬
            import platform
            if platform.system() != "Windows":
                logger.warning("ì‹¤ê±°ë˜ ëª¨ë“œëŠ” Windowsì—ì„œë§Œ ì§€ì›ë©ë‹ˆë‹¤. Demo ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤.")
                initial_mode = "DEMO"
            else:
                from data.kiwoom_real import KiwoomRealClient
                kiwoom_client = KiwoomRealClient()
                if not await kiwoom_client.initialize():
                    logger.error("ì‹¤ê±°ë˜ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨. Demo ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤.")
                    initial_mode = "DEMO"
                    kiwoom_client = None
        except Exception as e:
            logger.error(f"ì‹¤ê±°ë˜ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì˜¤ë¥˜: {e}. Demo ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤.")
            initial_mode = "DEMO"
            kiwoom_client = None
    
    # Demo ëª¨ë“œ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
    if initial_mode == "DEMO" or kiwoom_client is None:
        from data.kiwoom_mock import KiwoomClient
        kiwoom_client = KiwoomClient()
        await kiwoom_client.connect()
    
    # ê±°ë˜ ëª¨ë“œ APIì— í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
    from trading_mode_api import CURRENT_TRADING_MODE, KIWOOM_CLIENT_INSTANCE
    global CURRENT_TRADING_MODE, KIWOOM_CLIENT_INSTANCE
    CURRENT_TRADING_MODE = initial_mode
    KIWOOM_CLIENT_INSTANCE = kiwoom_client
    
    # íŠ¸ë ˆì´ë”© ì—”ì§„ ì´ˆê¸°í™” (í˜„ì¬ í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©)
    trading_engine = TradingEngine()
    trading_engine.kiwoom_client = kiwoom_client
    await trading_engine.initialize()
    
    # ë°±ê·¸ë¼ìš´ë“œ íŠ¸ë ˆì´ë”© ë£¨í”„ ì‹œì‘
    background_task = asyncio.create_task(trading_engine.run())
    
    logger.info(f"ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ - ëª¨ë“œ: {initial_mode}")
    
    yield
    
    # ì‹œìŠ¤í…œ ì¢…ë£Œ ì‹œ ì •ë¦¬
    logger.info("ì‹œìŠ¤í…œ ì¢…ë£Œ ì¤‘...")
    if background_task:
        background_task.cancel()
    if trading_engine:
        await trading_engine.shutdown()
    if kiwoom_client:
        await kiwoom_client.disconnect()
    logger.info("ì‹œìŠ¤í…œ ì¢…ë£Œ ì™„ë£Œ")

# FastAPI ì•± ìƒì„±
app = FastAPI(
    title="QuanTrade Pro API",
    description="í€€íŠ¸ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ API - Mock/Real ëª¨ë“œ ì§€ì›",
    version="1.1.0",
    lifespan=lifespan
)

# CORS ì„¤ì •
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Next.js ê°œë°œ ì„œë²„
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# API ë¼ìš°í„° ë“±ë¡
app.include_router(router, prefix="/api")
app.include_router(mode_router, prefix="/api")  # ê±°ë˜ ëª¨ë“œ API ì¶”ê°€

@app.get("/")
async def root():
    """ê¸°ë³¸ ì—”ë“œí¬ì¸íŠ¸"""
    current_mode = get_current_trading_mode()
    return {
        "message": "QuanTrade Pro API",
        "version": "1.1.0",
        "status": "running",
        "trading_mode": current_mode,
        "timestamp": datetime.now().isoformat()
    }

@app.get("/health")
async def health_check():
    """í—¬ìŠ¤ ì²´í¬ ì—”ë“œí¬ì¸íŠ¸"""
    global trading_engine
    
    try:
        engine_status = "running" if trading_engine and trading_engine.is_running else "stopped"
        current_mode = get_current_trading_mode()
        kiwoom_client = get_current_kiwoom_client()
        api_connected = kiwoom_client.is_connected if kiwoom_client else False
        
        return {
            "status": "healthy",
            "trading_engine": engine_status,
            "trading_mode": current_mode,
            "api_connection": api_connected,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        logger.error(f"í—¬ìŠ¤ ì²´í¬ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="System health check failed")

@app.get("/trading/status")
async def get_trading_status():
    """íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ"""
    global trading_engine
    
    if not trading_engine:
        raise HTTPException(status_code=503, detail="Trading engine not initialized")
    
    current_mode = get_current_trading_mode()
    kiwoom_client = get_current_kiwoom_client()
    
    return {
        "is_running": trading_engine.is_running,
        "trading_mode": current_mode,
        "api_connected": kiwoom_client.is_connected if kiwoom_client else False,
        "active_strategies": len(trading_engine.get_active_strategies()),
        "current_positions": len(trading_engine.get_current_positions()),
        "total_orders_today": trading_engine.get_daily_order_count(),
        "last_update": trading_engine.last_update.isoformat() if trading_engine.last_update else None
    }

@app.post("/trading/change-mode")
async def change_trading_mode_endpoint(request: dict):
    """ê±°ë˜ ëª¨ë“œ ë³€ê²½ (ë ˆê±°ì‹œ ì§€ì›)"""
    # trading_mode_api.pyì˜ ì—”ë“œí¬ì¸íŠ¸ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
    from trading_mode_api import change_trading_mode, TradingModeRequest
    
    mode_request = TradingModeRequest(mode=request.get("mode", "DEMO"))
    return await change_trading_mode(mode_request)

def get_trading_engine():
    """íŠ¸ë ˆì´ë”© ì—”ì§„ ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜"""
    global trading_engine
    if not trading_engine:
        raise HTTPException(status_code=503, detail="Trading engine not available")
    return trading_engine

# ê°œë°œìš© í¸ì˜ ì—”ë“œí¬ì¸íŠ¸
@app.get("/dev/info")
async def development_info():
    """ê°œë°œ ì •ë³´ (ê°œë°œ í™˜ê²½ì—ì„œë§Œ)"""
    if not settings.debug:
        raise HTTPException(status_code=404, detail="Not found")
    
    import platform
    import sys
    
    current_mode = get_current_trading_mode()
    kiwoom_client = get_current_kiwoom_client()
    
    return {
        "system": {
            "os": platform.system(),
            "python_version": sys.version,
            "trading_mode": current_mode
        },
        "client": {
            "type": type(kiwoom_client).__name__ if kiwoom_client else None,
            "connected": kiwoom_client.is_connected if kiwoom_client else False
        },
        "engine": {
            "running": trading_engine.is_running if trading_engine else False,
            "strategies": len(trading_engine.get_active_strategies()) if trading_engine else 0
        }
    }

if __name__ == "__main__":
    # í™˜ê²½ë³€ìˆ˜ì—ì„œ ì„¤ì • ë¡œë“œ
    host = os.getenv("HOST", "0.0.0.0")
    port = int(os.getenv("PORT", "8000"))
    reload = os.getenv("RELOAD", "True").lower() == "true"
    
    logger.info(f"ì„œë²„ ì‹œì‘: http://{host}:{port}")
    logger.info(f"API ë¬¸ì„œ: http://{host}:{port}/docs")
    
    uvicorn.run(
        "main:app",
        host=host,
        port=port,
        reload=reload,
        log_level="info"
    )




    


==================================================
File: C:\Aproject\test\quant_actual\backend\models.py
==================================================
# file: backend/models.py

from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean, Text, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, validator
from enum import Enum

Base = declarative_base()

# Enum ì •ì˜
class OrderStatus(str, Enum):
    PENDING = "pending"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"

class OrderType(str, Enum):
    BUY = "buy"
    SELL = "sell"

class StrategyType(str, Enum):
    BOLLINGER_BANDS = "bollinger_bands"
    RSI_REVERSAL = "rsi_reversal"
    MOMENTUM = "momentum"
    MOVING_AVERAGE = "moving_average"

# SQLAlchemy ëª¨ë¸ (ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸”)
class Strategy(Base):
    __tablename__ = "strategies"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, index=True)
    strategy_type = Column(String)
    is_active = Column(Boolean, default=False)
    investment_amount = Column(Float)
    target_stocks = Column(Text)  # JSON ë¬¸ìì—´ë¡œ ì €ì¥
    parameters = Column(Text)  # JSON ë¬¸ìì—´ë¡œ ì €ì¥
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # ê´€ê³„ ì„¤ì •
    orders = relationship("Order", back_populates="strategy")
    positions = relationship("Position", back_populates="strategy")

class Stock(Base):
    __tablename__ = "stocks"
    
    id = Column(Integer, primary_key=True, index=True)
    code = Column(String, unique=True, index=True)  # ì¢…ëª©ì½”ë“œ (ì˜ˆ: 005930)
    name = Column(String)  # ì¢…ëª©ëª… (ì˜ˆ: ì‚¼ì„±ì „ì)
    market = Column(String)  # ì‹œì¥êµ¬ë¶„ (KOSPI, KOSDAQ)
    current_price = Column(Float)
    prev_close = Column(Float)
    volume = Column(Integer)
    market_cap = Column(Float)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # ê´€ê³„ ì„¤ì •
    orders = relationship("Order", back_populates="stock")
    positions = relationship("Position", back_populates="stock")
    price_history = relationship("PriceHistory", back_populates="stock")

class Order(Base):
    __tablename__ = "orders"
    
    id = Column(Integer, primary_key=True, index=True)
    strategy_id = Column(Integer, ForeignKey("strategies.id"))
    stock_id = Column(Integer, ForeignKey("stocks.id"))
    order_type = Column(String)  # buy, sell
    quantity = Column(Integer)
    price = Column(Float)
    status = Column(String, default="pending")
    order_time = Column(DateTime, default=datetime.utcnow)
    fill_time = Column(DateTime)
    fill_price = Column(Float)
    fill_quantity = Column(Integer)
    commission = Column(Float, default=0.0)
    kiwoom_order_id = Column(String)  # í‚¤ì›€ API ì£¼ë¬¸ë²ˆí˜¸
    
    # ê´€ê³„ ì„¤ì •
    strategy = relationship("Strategy", back_populates="orders")
    stock = relationship("Stock", back_populates="orders")

class Position(Base):
    __tablename__ = "positions"
    
    id = Column(Integer, primary_key=True, index=True)
    strategy_id = Column(Integer, ForeignKey("strategies.id"))
    stock_id = Column(Integer, ForeignKey("stocks.id"))
    quantity = Column(Integer)
    avg_price = Column(Float)
    current_price = Column(Float)
    unrealized_pnl = Column(Float, default=0.0)
    realized_pnl = Column(Float, default=0.0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # ê´€ê³„ ì„¤ì •
    strategy = relationship("Strategy", back_populates="positions")
    stock = relationship("Stock", back_populates="positions")

class Portfolio(Base):
    __tablename__ = "portfolio"
    
    id = Column(Integer, primary_key=True, index=True)
    total_value = Column(Float)
    cash = Column(Float)
    invested_amount = Column(Float)
    realized_pnl = Column(Float, default=0.0)
    unrealized_pnl = Column(Float, default=0.0)
    daily_pnl = Column(Float, default=0.0)
    total_return = Column(Float, default=0.0)
    timestamp = Column(DateTime, default=datetime.utcnow)

class PriceHistory(Base):
    __tablename__ = "price_history"
    
    id = Column(Integer, primary_key=True, index=True)
    stock_id = Column(Integer, ForeignKey("stocks.id"))
    price = Column(Float)
    volume = Column(Integer)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    
    # ê´€ê³„ ì„¤ì •
    stock = relationship("Stock", back_populates="price_history")

class BacktestResult(Base):
    __tablename__ = "backtest_results"
    
    id = Column(Integer, primary_key=True, index=True)
    strategy_name = Column(String)
    start_date = Column(DateTime)
    end_date = Column(DateTime)
    total_return = Column(Float)
    annual_return = Column(Float)
    max_drawdown = Column(Float)
    sharpe_ratio = Column(Float)
    win_rate = Column(Float)
    total_trades = Column(Integer)
    results_data = Column(Text)  # JSONìœ¼ë¡œ ìƒì„¸ ê²°ê³¼ ì €ì¥
    created_at = Column(DateTime, default=datetime.utcnow)

# Pydantic ëª¨ë¸ (API ìš”ì²­/ì‘ë‹µ)
class StrategyBase(BaseModel):
    name: str
    strategy_type: StrategyType
    is_active: bool = False
    investment_amount: float
    target_stocks: list[str] = []
    parameters: dict = {}

class StrategyCreate(StrategyBase):
    pass

class StrategyUpdate(BaseModel):
    name: Optional[str] = None
    is_active: Optional[bool] = None
    investment_amount: Optional[float] = None
    target_stocks: Optional[list[str]] = None
    parameters: Optional[dict] = None

class StrategyResponse(StrategyBase):
    id: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class StockBase(BaseModel):
    code: str
    name: str
    market: str = "KOSPI"

class StockResponse(StockBase):
    id: int
    current_price: Optional[float] = None
    prev_close: Optional[float] = None
    volume: Optional[int] = None
    updated_at: datetime
    
    class Config:
        from_attributes = True

class OrderBase(BaseModel):
    strategy_id: int
    stock_code: str
    order_type: OrderType
    quantity: int
    price: float

class OrderCreate(OrderBase):
    pass

class OrderResponse(BaseModel):
    id: int
    strategy_id: int
    stock_code: str
    stock_name: str
    order_type: str
    quantity: int
    price: float
    status: str
    order_time: datetime
    fill_time: Optional[datetime] = None
    fill_price: Optional[float] = None
    fill_quantity: Optional[int] = None
    
    class Config:
        from_attributes = True

class PositionResponse(BaseModel):
    id: int
    strategy_name: str
    stock_code: str
    stock_name: str
    quantity: int
    avg_price: float
    current_price: float
    unrealized_pnl: float
    realized_pnl: float
    
    class Config:
        from_attributes = True

class PortfolioResponse(BaseModel):
    total_value: float
    cash: float
    invested_amount: float
    realized_pnl: float
    unrealized_pnl: float
    daily_pnl: float
    total_return: float
    timestamp: datetime
    
    class Config:
        from_attributes = True

class TradingSignal(BaseModel):
    stock_code: str
    strategy_name: str
    signal_type: OrderType
    quantity: int
    price: float
    confidence: float
    timestamp: datetime = datetime.now()

class BacktestRequest(BaseModel):
    strategy_type: StrategyType
    parameters: dict
    target_stocks: list[str]
    start_date: datetime
    end_date: datetime
    initial_capital: float = 10000000  # 1ì²œë§Œì›

class BacktestResponse(BaseModel):
    total_return: float
    annual_return: float
    max_drawdown: float
    sharpe_ratio: float
    win_rate: float
    total_trades: int
    strategy_performance: dict
    
    @validator('total_return', 'annual_return', 'max_drawdown', 'sharpe_ratio', 'win_rate')
    def round_percentages(cls, v):
        return round(v, 2)

class RiskMetrics(BaseModel):
    daily_loss_limit: float = -0.02  # -2%
    position_size_limit: float = 0.05  # 5%
    max_positions: int = 10
    current_daily_loss: float = 0.0
    is_safe_to_trade: bool = True

class MarketDataResponse(BaseModel):
    stock_code: str
    price: float
    volume: int
    timestamp: datetime
    
class SystemStatus(BaseModel):
    is_running: bool
    api_connected: bool
    active_strategies: int
    current_positions: int
    total_orders_today: int
    last_update: Optional[datetime] = None



==================================================
File: C:\Aproject\test\quant_actual\backend\run.py
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\backend\trading_engine_manager.py
==================================================
# file: backend/trading_engine_manager.py

from trading.engine import TradingEngine

# ì „ì—­ íŠ¸ë ˆì´ë”© ì—”ì§„ ì¸ìŠ¤í„´ìŠ¤
_trading_engine = None

def get_trading_engine():
    """ì „ì—­ íŠ¸ë ˆì´ë”© ì—”ì§„ ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜"""
    global _trading_engine
    if _trading_engine is None:
        raise RuntimeError("íŠ¸ë ˆì´ë”© ì—”ì§„ì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
    return _trading_engine

def set_trading_engine(engine: TradingEngine):
    """ì „ì—­ íŠ¸ë ˆì´ë”© ì—”ì§„ ì¸ìŠ¤í„´ìŠ¤ ì„¤ì •"""
    global _trading_engine
    _trading_engine = engine



==================================================
File: C:\Aproject\test\quant_actual\backend\trading_mode_api.py
==================================================
"""
file: trading_mode_api.py
ê±°ë˜ ëª¨ë“œ ì „í™˜ API
Mock â†” Real ëª¨ë“œ ì „í™˜ì„ ìœ„í•œ ì—”ë“œí¬ì¸íŠ¸
"""

import os
import platform
import logging
from typing import Dict, Any
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel

from utils.config import get_settings
from database import get_db_session

logger = logging.getLogger(__name__)

# ì „ì—­ ë³€ìˆ˜ë¡œ í˜„ì¬ ëª¨ë“œ ì €ì¥
CURRENT_TRADING_MODE = "DEMO"  # DEMO or REAL
KIWOOM_CLIENT_INSTANCE = None

class TradingModeRequest(BaseModel):
    mode: str  # "DEMO" or "REAL"

class SystemStatusResponse(BaseModel):
    current_mode: str
    is_windows: bool
    kiwoom_api_available: bool
    account_connected: bool
    account_info: Dict[str, Any] = None

router = APIRouter()

def check_windows_environment() -> bool:
    """Windows í™˜ê²½ ì²´í¬"""
    return platform.system() == "Windows"

def check_kiwoom_api_available() -> bool:
    """í‚¤ì›€ API ì‚¬ìš© ê°€ëŠ¥ì„± ì²´í¬"""
    if not check_windows_environment():
        return False
    
    try:
        # PyQt5ì™€ pythoncom ëª¨ë“ˆ ì²´í¬
        import PyQt5
        import pythoncom
        
        # í‚¤ì›€ API íŒŒì¼ ì¡´ì¬ ì²´í¬ (ì¼ë°˜ì ì¸ ì„¤ì¹˜ ê²½ë¡œ)
        kiwoom_paths = [
            "C:\\OpenAPI\\",
            "C:\\Program Files\\OpenAPI\\",
            "C:\\Program Files (x86)\\OpenAPI\\"
        ]
        
        for path in kiwoom_paths:
            if os.path.exists(path):
                return True
        
        # ë ˆì§€ìŠ¤íŠ¸ë¦¬ì—ì„œ í‚¤ì›€ API í™•ì¸ (ì„ íƒì )
        try:
            import winreg
            key = winreg.OpenKey(winreg.HKEY_CLASSES_ROOT, "KHOPENAPI.KHOpenAPICtrl.1")
            winreg.CloseKey(key)
            return True
        except:
            pass
        
        return False
        
    except ImportError:
        return False

async def get_account_info():
    """ê³„ì¢Œ ì •ë³´ ì¡°íšŒ"""
    global KIWOOM_CLIENT_INSTANCE
    
    if CURRENT_TRADING_MODE == "REAL" and KIWOOM_CLIENT_INSTANCE:
        try:
            account_info = await KIWOOM_CLIENT_INSTANCE.get_account_info()
            return account_info
        except Exception as e:
            logger.error(f"ì‹¤ê±°ë˜ ê³„ì¢Œ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return None
    else:
        # Mock ëª¨ë“œ ê³„ì¢Œ ì •ë³´
        return {
            "account_number": "8012345-01",
            "server_type": "DEMO",
            "available_cash": 50000000,
            "total_cash": 50000000
        }

@router.get("/system/trading-mode", response_model=SystemStatusResponse)
async def get_trading_mode_status():
    """í˜„ì¬ ê±°ë˜ ëª¨ë“œ ìƒíƒœ ì¡°íšŒ"""
    try:
        is_windows = check_windows_environment()
        kiwoom_available = check_kiwoom_api_available()
        
        # ê³„ì¢Œ ì—°ê²° ìƒíƒœ ì²´í¬
        account_connected = False
        account_info = None
        
        if CURRENT_TRADING_MODE == "REAL" and KIWOOM_CLIENT_INSTANCE:
            account_connected = KIWOOM_CLIENT_INSTANCE.is_connected
            if account_connected:
                account_info = await get_account_info()
        elif CURRENT_TRADING_MODE == "DEMO":
            account_connected = True  # Mock ëª¨ë“œì—ì„œëŠ” í•­ìƒ ì—°ê²°ë¨
            account_info = await get_account_info()
        
        return SystemStatusResponse(
            current_mode=CURRENT_TRADING_MODE,
            is_windows=is_windows,
            kiwoom_api_available=kiwoom_available,
            account_connected=account_connected,
            account_info=account_info
        )
        
    except Exception as e:
        logger.error(f"ê±°ë˜ ëª¨ë“œ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to get trading mode status")

@router.post("/system/change-trading-mode")
async def change_trading_mode(request: TradingModeRequest):
    """ê±°ë˜ ëª¨ë“œ ë³€ê²½"""
    global CURRENT_TRADING_MODE, KIWOOM_CLIENT_INSTANCE
    
    try:
        new_mode = request.mode.upper()
        
        if new_mode not in ["DEMO", "REAL"]:
            raise HTTPException(status_code=400, detail="Invalid trading mode")
        
        if new_mode == CURRENT_TRADING_MODE:
            return {"success": True, "message": f"ì´ë¯¸ {new_mode} ëª¨ë“œì…ë‹ˆë‹¤."}
        
        # ì‹¤ê±°ë˜ ëª¨ë“œ ì „í™˜ ì‹œ ì¶”ê°€ ê²€ì¦
        if new_mode == "REAL":
            if not check_windows_environment():
                raise HTTPException(
                    status_code=400, 
                    detail="ì‹¤ê±°ë˜ ëª¨ë“œëŠ” Windows í™˜ê²½ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤."
                )
            
            if not check_kiwoom_api_available():
                raise HTTPException(
                    status_code=400, 
                    detail="í‚¤ì›€ Open APIê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
                )
            
            # í™˜ê²½ë³€ìˆ˜ ì²´í¬
            if not os.getenv("KIWOOM_ACCOUNT"):
                raise HTTPException(
                    status_code=400, 
                    detail="KIWOOM_ACCOUNT í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
                )
            
            if not os.getenv("KIWOOM_PASSWORD"):
                raise HTTPException(
                    status_code=400, 
                    detail="KIWOOM_PASSWORD í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
                )
        
        # ê¸°ì¡´ ì—°ê²° í•´ì œ
        if KIWOOM_CLIENT_INSTANCE:
            try:
                await KIWOOM_CLIENT_INSTANCE.disconnect()
            except:
                pass
            KIWOOM_CLIENT_INSTANCE = None
        
        # ìƒˆë¡œìš´ ëª¨ë“œë¡œ ì „í™˜
        if new_mode == "REAL":
            # ì‹¤ê±°ë˜ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
            from data.kiwoom_real import KiwoomRealClient
            KIWOOM_CLIENT_INSTANCE = KiwoomRealClient()
            
            # ì—°ê²° ì‹œë„
            if not await KIWOOM_CLIENT_INSTANCE.initialize():
                raise HTTPException(status_code=500, detail="í‚¤ì›€ API ì´ˆê¸°í™” ì‹¤íŒ¨")
            
            if not await KIWOOM_CLIENT_INSTANCE.connect():
                raise HTTPException(status_code=500, detail="í‚¤ì›€ API ì—°ê²° ì‹¤íŒ¨")
            
            logger.warning("ì‹¤ê±°ë˜ ëª¨ë“œë¡œ ì „í™˜ë¨")
            
        else:  # DEMO ëª¨ë“œ
            # Mock í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
            from data.kiwoom_mock import KiwoomClient
            KIWOOM_CLIENT_INSTANCE = KiwoomClient()
            await KIWOOM_CLIENT_INSTANCE.connect()
            
            logger.info("ëª¨ì˜íˆ¬ì ëª¨ë“œë¡œ ì „í™˜ë¨")
        
        # ëª¨ë“œ ë³€ê²½
        CURRENT_TRADING_MODE = new_mode
        
        # íŠ¸ë ˆì´ë”© ì—”ì§„ì— ìƒˆë¡œìš´ í´ë¼ì´ì–¸íŠ¸ ì ìš©
        from main import get_trading_engine
        trading_engine = get_trading_engine()
        trading_engine.kiwoom_client = KIWOOM_CLIENT_INSTANCE
        
        # ë°ì´í„°ë² ì´ìŠ¤ì— ëª¨ë“œ ë³€ê²½ ê¸°ë¡
        with get_db_session() as db:
            # ì‹¤ì œë¡œëŠ” SystemLog í…Œì´ë¸”ì— ê¸°ë¡
            pass
        
        return {
            "success": True,
            "message": f"{new_mode} ëª¨ë“œë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.",
            "mode": new_mode,
            "account_connected": KIWOOM_CLIENT_INSTANCE.is_connected if KIWOOM_CLIENT_INSTANCE else False
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ê±°ë˜ ëª¨ë“œ ë³€ê²½ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to change trading mode: {str(e)}")

@router.get("/system/environment-check")
async def check_environment():
    """í™˜ê²½ ì²´í¬ ë° ì„¤ì¹˜ ê°€ì´ë“œ"""
    try:
        checks = {
            "operating_system": {
                "name": platform.system(),
                "version": platform.version(),
                "is_windows": check_windows_environment(),
                "status": "âœ…" if check_windows_environment() else "âŒ"
            },
            "python_version": {
                "version": platform.python_version(),
                "is_compatible": platform.python_version() >= "3.9",
                "status": "âœ…" if platform.python_version() >= "3.9" else "âŒ"
            },
            "required_packages": {},
            "kiwoom_api": {
                "available": check_kiwoom_api_available(),
                "status": "âœ…" if check_kiwoom_api_available() else "âŒ"
            },
            "environment_variables": {
                "kiwoom_account": bool(os.getenv("KIWOOM_ACCOUNT")),
                "kiwoom_password": bool(os.getenv("KIWOOM_PASSWORD")),
                "status": "âœ…" if (os.getenv("KIWOOM_ACCOUNT") and os.getenv("KIWOOM_PASSWORD")) else "âŒ"
            }
        }
        
        # Python íŒ¨í‚¤ì§€ ì²´í¬
        required_packages = ["PyQt5", "pythoncom", "fastapi", "sqlalchemy", "pandas", "numpy"]
        
        for package in required_packages:
            try:
                __import__(package.lower())
                checks["required_packages"][package] = {"installed": True, "status": "âœ…"}
            except ImportError:
                checks["required_packages"][package] = {"installed": False, "status": "âŒ"}
        
        # ì „ì²´ ìƒíƒœ íŒì •
        overall_status = "READY" if all([
            checks["operating_system"]["is_windows"],
            checks["python_version"]["is_compatible"],
            all(pkg["installed"] for pkg in checks["required_packages"].values()),
            checks["kiwoom_api"]["available"]
        ]) else "NOT_READY"
        
        return {
            "overall_status": overall_status,
            "checks": checks,
            "recommendations": get_installation_recommendations(checks)
        }
        
    except Exception as e:
        logger.error(f"í™˜ê²½ ì²´í¬ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail="Failed to check environment")

def get_installation_recommendations(checks: Dict) -> list[str]:
    """ì„¤ì¹˜ ê¶Œì¥ì‚¬í•­ ìƒì„±"""
    recommendations = []
    
    if not checks["operating_system"]["is_windows"]:
        recommendations.append("ì‹¤ê±°ë˜ë¥¼ ìœ„í•´ì„œëŠ” Windows í™˜ê²½ì´ í•„ìš”í•©ë‹ˆë‹¤.")
    
    if not checks["python_version"]["is_compatible"]:
        recommendations.append("Python 3.9 ì´ìƒìœ¼ë¡œ ì—…ê·¸ë ˆì´ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤.")
    
    missing_packages = [
        pkg for pkg, info in checks["required_packages"].items() 
        if not info["installed"]
    ]
    
    if missing_packages:
        recommendations.append(f"ë‹¤ìŒ íŒ¨í‚¤ì§€ ì„¤ì¹˜ í•„ìš”: {', '.join(missing_packages)}")
        recommendations.append("pip install " + " ".join(missing_packages))
    
    if not checks["kiwoom_api"]["available"]:
        recommendations.extend([
            "í‚¤ì›€ Open API+ ì„¤ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤:",
            "1. í‚¤ì›€ì¦ê¶Œ í™ˆí˜ì´ì§€ â†’ ê³ ê°ì§€ì› â†’ API",
            "2. Open API+ ë‹¤ìš´ë¡œë“œ ë° ì„¤ì¹˜",
            "3. ì‹œìŠ¤í…œ ì¬ë¶€íŒ… í›„ ì¬ì‹œë„"
        ])
    
    if not checks["environment_variables"]["kiwoom_account"]:
        recommendations.extend([
            "í™˜ê²½ë³€ìˆ˜ ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤:",
            "KIWOOM_ACCOUNT=ì‹¤ì œê³„ì¢Œë²ˆí˜¸",
            "KIWOOM_PASSWORD=ì‹¤ì œë¹„ë°€ë²ˆí˜¸"
        ])
    
    if not recommendations:
        recommendations.append("ëª¨ë“  ìš”êµ¬ì‚¬í•­ì´ ì¶©ì¡±ë˜ì—ˆìŠµë‹ˆë‹¤. ì‹¤ê±°ë˜ ì¤€ë¹„ ì™„ë£Œ!")
    
    return recommendations

@router.post("/system/test-connection")
async def test_connection(request: TradingModeRequest):
    """ì—°ê²° í…ŒìŠ¤íŠ¸"""
    try:
        mode = request.mode.upper()
        
        if mode == "DEMO":
            # Mock ì—°ê²° í…ŒìŠ¤íŠ¸
            from data.kiwoom_mock import KiwoomClient
            test_client = KiwoomClient()
            
            if await test_client.connect():
                await test_client.disconnect()
                return {
                    "success": True,
                    "message": "ëª¨ì˜íˆ¬ì ì—°ê²° í…ŒìŠ¤íŠ¸ ì„±ê³µ",
                    "details": {
                        "mode": "DEMO",
                        "connection_time": "< 1ì´ˆ",
                        "account": "ëª¨ì˜ê³„ì¢Œ"
                    }
                }
            else:
                raise HTTPException(status_code=500, detail="ëª¨ì˜íˆ¬ì ì—°ê²° ì‹¤íŒ¨")
        
        elif mode == "REAL":
            # ì‹¤ê±°ë˜ ì—°ê²° í…ŒìŠ¤íŠ¸
            if not check_windows_environment():
                raise HTTPException(status_code=400, detail="Windows í™˜ê²½ì´ ì•„ë‹™ë‹ˆë‹¤")
            
            if not check_kiwoom_api_available():
                raise HTTPException(status_code=400, detail="í‚¤ì›€ APIê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
            
            from data.kiwoom_real import KiwoomRealClient
            test_client = KiwoomRealClient()
            
            if await test_client.initialize():
                if await test_client.connect():
                    account_info = await test_client.get_account_info()
                    await test_client.disconnect()
                    
                    return {
                        "success": True,
                        "message": "ì‹¤ê±°ë˜ ì—°ê²° í…ŒìŠ¤íŠ¸ ì„±ê³µ",
                        "details": {
                            "mode": "REAL",
                            "account": account_info.get("account_number", "í™•ì¸ë¶ˆê°€"),
                            "server_type": account_info.get("server_type", "REAL"),
                            "available_cash": account_info.get("available_cash", 0)
                        }
                    }
                else:
                    raise HTTPException(status_code=500, detail="í‚¤ì›€ API ë¡œê·¸ì¸ ì‹¤íŒ¨")
            else:
                raise HTTPException(status_code=500, detail="í‚¤ì›€ API ì´ˆê¸°í™” ì‹¤íŒ¨")
        
        else:
            raise HTTPException(status_code=400, detail="ì˜ëª»ëœ ëª¨ë“œì…ë‹ˆë‹¤")
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ì—°ê²° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail=f"Connection test failed: {str(e)}")

@router.get("/system/trading-mode-guide")
async def get_trading_mode_guide():
    """ê±°ë˜ ëª¨ë“œ ê°€ì´ë“œ"""
    return {
        "modes": {
            "DEMO": {
                "name": "ëª¨ì˜íˆ¬ì ëª¨ë“œ",
                "description": "ê°€ìƒì˜ ëˆìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ê±°ë˜ ì—°ìŠµ",
                "pros": [
                    "ì‹¤ì œ ëˆ ì†ì‹¤ ìœ„í—˜ ì—†ìŒ",
                    "ëª¨ë“  í”Œë«í¼ì—ì„œ ì‹¤í–‰ ê°€ëŠ¥",
                    "ë¬´ì œí•œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥",
                    "ì „ëµ ê°œë°œ ë° ê²€ì¦ì— ìµœì "
                ],
                "cons": [
                    "ì‹¤ì œ ìˆ˜ìµ ë¶ˆê°€ëŠ¥",
                    "ì‹œë®¬ë ˆì´ì…˜ ë°ì´í„° ì‚¬ìš©",
                    "ì‹¤ì œ ì‹œì¥ê³¼ ë¯¸ì„¸í•œ ì°¨ì´ ê°€ëŠ¥"
                ],
                "recommended_for": [
                    "í€€íŠ¸ íŠ¸ë ˆì´ë”© ì´ˆë³´ì",
                    "ìƒˆë¡œìš´ ì „ëµ í…ŒìŠ¤íŠ¸",
                    "ì‹œìŠ¤í…œ ì•ˆì •ì„± í™•ì¸",
                    "êµìœ¡ ëª©ì "
                ]
            },
            "REAL": {
                "name": "ì‹¤ê±°ë˜ ëª¨ë“œ",
                "description": "ì‹¤ì œ ëˆìœ¼ë¡œ ì§„ì§œ ê±°ë˜ ì‹¤í–‰",
                "pros": [
                    "ì‹¤ì œ ìˆ˜ìµ ê°€ëŠ¥",
                    "ì§„ì§œ ì‹œì¥ ë°ì´í„° ì‚¬ìš©",
                    "ì™„ì „í•œ ê±°ë˜ ê²½í—˜"
                ],
                "cons": [
                    "íˆ¬ì ì†ì‹¤ ìœ„í—˜",
                    "Windows í™˜ê²½ í•„ìˆ˜",
                    "í‚¤ì›€ì¦ê¶Œ ê³„ì¢Œ í•„ìš”",
                    "ì‹œìŠ¤í…œ ì˜¤ë¥˜ ì‹œ ì‹¤ì œ ì†ì‹¤ ê°€ëŠ¥"
                ],
                "recommended_for": [
                    "ì¶©ë¶„í•œ ê²½í—˜ì",
                    "ëª¨ì˜íˆ¬ì ê²€ì¦ ì™„ë£Œì",
                    "ì†Œì•¡ íˆ¬ì ê°€ëŠ¥ì",
                    "ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ê°€ëŠ¥ì"
                ],
                "requirements": [
                    "Windows 10 ì´ìƒ",
                    "í‚¤ì›€ì¦ê¶Œ ê³„ì¢Œ",
                    "í‚¤ì›€ Open API+ ì„¤ì¹˜",
                    "Python 3.9+",
                    "ì•ˆì •ì ì¸ ì¸í„°ë„· ì—°ê²°"
                ]
            }
        },
        "transition_guide": {
            "step1": "ëª¨ì˜íˆ¬ìë¡œ ìµœì†Œ 1ê°œì›” í…ŒìŠ¤íŠ¸",
            "step2": "ëª¨ë“  ì „ëµì˜ ìˆ˜ìµì„± ê²€ì¦",
            "step3": "ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì„¤ì • ìµœì í™”",
            "step4": "Windows í™˜ê²½ ë° í‚¤ì›€ API ì„¤ì¹˜",
            "step5": "ì‹¤ê±°ë˜ í™˜ê²½ë³€ìˆ˜ ì„¤ì •",
            "step6": "ì†Œì•¡(5-10ë§Œì›)ìœ¼ë¡œ ì‹¤ê±°ë˜ ì‹œì‘",
            "step7": "ì•ˆì •ì„± í™•ì¸ í›„ ì ì§„ì  ì¦ì•¡"
        },
        "safety_tips": [
            "í•­ìƒ ì†ì ˆì„ ì„ ì„¤ì •í•˜ì„¸ìš”",
            "ì¼ì¼ ì†ì‹¤ í•œë„ë¥¼ ì„¤ì •í•˜ì„¸ìš”",
            "íˆ¬ì ê°€ëŠ¥í•œ ëˆìœ¼ë¡œë§Œ ê±°ë˜í•˜ì„¸ìš”",
            "ì‹œìŠ¤í…œì„ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§í•˜ì„¸ìš”",
            "ì •ê¸°ì ìœ¼ë¡œ ë°±ì—…ì„ ìƒì„±í•˜ì„¸ìš”",
            "ë„¤íŠ¸ì›Œí¬ ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”",
            "ê¸´ê¸‰ìƒí™© ì‹œ ìˆ˜ë™ ê°œì… ë°©ë²•ì„ ìˆ™ì§€í•˜ì„¸ìš”"
        ]
    }

def get_current_trading_mode():
    """í˜„ì¬ ê±°ë˜ ëª¨ë“œ ë°˜í™˜"""
    return CURRENT_TRADING_MODE

def get_current_kiwoom_client():
    """í˜„ì¬ í‚¤ì›€ í´ë¼ì´ì–¸íŠ¸ ë°˜í™˜"""
    return KIWOOM_CLIENT_INSTANCE

# ì˜ì¡´ì„± ì£¼ì…ìš© í•¨ìˆ˜ë“¤
def get_trading_mode():
    """ê±°ë˜ ëª¨ë“œ ì˜ì¡´ì„±"""
    return CURRENT_TRADING_MODE

def get_kiwoom_client():
    """í‚¤ì›€ í´ë¼ì´ì–¸íŠ¸ ì˜ì¡´ì„±"""
    if KIWOOM_CLIENT_INSTANCE is None:
        raise HTTPException(status_code=503, detail="í‚¤ì›€ í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
    return KIWOOM_CLIENT_INSTANCE


==================================================
File: C:\Aproject\test\quant_actual\backend\data\kiwoom_mock.py
==================================================
#file: backend/data/kiwoom_mock.py

import asyncio
import logging
import random
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
import json
import uuid

logger = logging.getLogger(__name__)

class KiwoomClient:
    """í‚¤ì›€ Open API ëª¨ì˜ í´ë¼ì´ì–¸íŠ¸"""
    
    def __init__(self):
        self.is_connected = False
        self.account_number = "8012345-01"
        self.server_type = "DEMO"  # DEMO or REAL
        
        # ëª¨ì˜ ë°ì´í„°
        self.mock_prices = {}
        self.mock_orders = {}
        self.order_counter = 1000
        
        # ì´ˆê¸° ê°€ê²© ì„¤ì •
        self.initialize_mock_data()
        
        # ê°€ê²© ë³€ë™ ì‹œë®¬ë ˆì´ì…˜ íƒœìŠ¤í¬
        self.price_update_task = None
    
    def initialize_mock_data(self):
        """ëª¨ì˜ ë°ì´í„° ì´ˆê¸°í™”"""
        # ì£¼ìš” ì¢…ëª©ì˜ ì´ˆê¸° ê°€ê²© ì„¤ì •
        self.mock_prices = {
            '005930': {  # ì‚¼ì„±ì „ì
                'current_price': 71200,
                'prev_close': 70800,
                'volume': 12450000,
                'high': 71800,
                'low': 70500,
                'market_cap': 425000000000000,
                'last_update': datetime.now()
            },
            '000660': {  # SKí•˜ì´ë‹‰ìŠ¤
                'current_price': 124500,
                'prev_close': 123000,
                'volume': 8200000,
                'high': 125800,
                'low': 123200,
                'market_cap': 90000000000000,
                'last_update': datetime.now()
            },
            '035420': {  # NAVER
                'current_price': 198000,
                'prev_close': 195000,
                'volume': 1800000,
                'high': 199500,
                'low': 196000,
                'market_cap': 32000000000000,
                'last_update': datetime.now()
            },
            '035720': {  # ì¹´ì¹´ì˜¤
                'current_price': 89500,
                'prev_close': 87200,
                'volume': 3200000,
                'high': 90200,
                'low': 88100,
                'market_cap': 38000000000000,
                'last_update': datetime.now()
            },
            '051910': {  # LGí™”í•™
                'current_price': 486000,
                'prev_close': 482000,
                'volume': 450000,
                'high': 489000,
                'low': 483000,
                'market_cap': 34000000000000,
                'last_update': datetime.now()
            },
            '006400': {  # ì‚¼ì„±SDI
                'current_price': 425000,
                'prev_close': 420000,
                'volume': 380000,
                'high': 428000,
                'low': 422000,
                'market_cap': 28000000000000,
                'last_update': datetime.now()
            },
            '207940': {  # ì‚¼ì„±ë°”ì´ì˜¤ë¡œì§ìŠ¤
                'current_price': 785000,
                'prev_close': 780000,
                'volume': 120000,
                'high': 790000,
                'low': 775000,
                'market_cap': 53000000000000,
                'last_update': datetime.now()
            },
            '373220': {  # LGì—ë„ˆì§€ì†”ë£¨ì…˜
                'current_price': 412000,
                'prev_close': 408000,
                'volume': 680000,
                'high': 415000,
                'low': 409000,
                'market_cap': 96000000000000,
                'last_update': datetime.now()
            }
        }
    
    async def connect(self):
        """í‚¤ì›€ API ì—°ê²°"""
        try:
            logger.info("í‚¤ì›€ API ì—°ê²° ì‹œë„ ì¤‘...")
            
            # ì—°ê²° ì‹œë®¬ë ˆì´ì…˜ (2ì´ˆ ëŒ€ê¸°)
            await asyncio.sleep(2)
            
            self.is_connected = True
            
            # ì‹¤ì‹œê°„ ê°€ê²© ì—…ë°ì´íŠ¸ ì‹œì‘
            self.price_update_task = asyncio.create_task(self.simulate_price_updates())
            
            logger.info("í‚¤ì›€ API ì—°ê²° ì™„ë£Œ (ëª¨ì˜íˆ¬ì ëª¨ë“œ)")
            return True
            
        except Exception as e:
            logger.error(f"í‚¤ì›€ API ì—°ê²° ì‹¤íŒ¨: {e}")
            self.is_connected = False
            return False
    
    async def disconnect(self):
        """í‚¤ì›€ API ì—°ê²° í•´ì œ"""
        try:
            self.is_connected = False
            
            if self.price_update_task:
                self.price_update_task.cancel()
            
            logger.info("í‚¤ì›€ API ì—°ê²° í•´ì œë¨")
            
        except Exception as e:
            logger.error(f"í‚¤ì›€ API ì—°ê²° í•´ì œ ì‹¤íŒ¨: {e}")
    
    async def simulate_price_updates(self):
        """ì‹¤ì‹œê°„ ê°€ê²© ë³€ë™ ì‹œë®¬ë ˆì´ì…˜"""
        try:
            while self.is_connected:
                await asyncio.sleep(1)  # 1ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
                
                for stock_code in self.mock_prices:
                    await self.update_mock_price(stock_code)
                    
        except asyncio.CancelledError:
            logger.info("ê°€ê²© ì—…ë°ì´íŠ¸ ì‹œë®¬ë ˆì´ì…˜ ì¢…ë£Œ")
        except Exception as e:
            logger.error(f"ê°€ê²© ì—…ë°ì´íŠ¸ ì‹œë®¬ë ˆì´ì…˜ ì˜¤ë¥˜: {e}")
    
    async def update_mock_price(self, stock_code: str):
        """ê°œë³„ ì¢…ëª© ê°€ê²© ì—…ë°ì´íŠ¸"""
        try:
            if stock_code not in self.mock_prices:
                return
            
            price_data = self.mock_prices[stock_code]
            current_price = price_data['current_price']
            
            # ê°€ê²© ë³€ë™ ì‹œë®¬ë ˆì´ì…˜ (Â±2% ë²”ìœ„)
            change_rate = random.uniform(-0.02, 0.02)
            new_price = current_price * (1 + change_rate)
            
            # ì¼ì • ë²”ìœ„ ë‚´ì—ì„œë§Œ ë³€ë™í•˜ë„ë¡ ì œí•œ
            prev_close = price_data['prev_close']
            max_price = prev_close * 1.30  # ìƒí•œê°€ 30%
            min_price = prev_close * 0.70  # í•˜í•œê°€ -30%
            
            new_price = max(min_price, min(max_price, new_price))
            
            # ê°€ê²© ë°ì´í„° ì—…ë°ì´íŠ¸
            price_data['current_price'] = int(new_price)
            price_data['volume'] += random.randint(1000, 10000)
            price_data['high'] = max(price_data['high'], int(new_price))
            price_data['low'] = min(price_data['low'], int(new_price))
            price_data['last_update'] = datetime.now()
            
        except Exception as e:
            logger.error(f"ê°€ê²© ì—…ë°ì´íŠ¸ ì˜¤ë¥˜ {stock_code}: {e}")
    
    async def get_current_price(self, stock_code: str) -> Dict[str, Any]:
        """í˜„ì¬ ì‹œì„¸ ì¡°íšŒ"""
        try:
            if not self.is_connected:
                raise Exception("API ì—°ê²°ë˜ì§€ ì•ŠìŒ")
            
            if stock_code not in self.mock_prices:
                # ìƒˆë¡œìš´ ì¢…ëª©ì¸ ê²½ìš° ê¸°ë³¸ ë°ì´í„° ìƒì„±
                self.mock_prices[stock_code] = {
                    'current_price': random.randint(50000, 500000),
                    'prev_close': random.randint(50000, 500000),
                    'volume': random.randint(100000, 5000000),
                    'high': 0,
                    'low': 999999999,
                    'market_cap': random.randint(1000000000000, 100000000000000),
                    'last_update': datetime.now()
                }
            
            price_data = self.mock_prices[stock_code].copy()
            
            # ì¶”ê°€ ì •ë³´ ê³„ì‚°
            price_change = price_data['current_price'] - price_data['prev_close']
            change_rate = (price_change / price_data['prev_close']) * 100
            
            price_data.update({
                'price_change': price_change,
                'change_rate': change_rate,
                'bid_price': price_data['current_price'] - 100,
                'ask_price': price_data['current_price'] + 100,
                'timestamp': datetime.now().isoformat()
            })
            
            return price_data
            
        except Exception as e:
            logger.error(f"ì‹œì„¸ ì¡°íšŒ ì˜¤ë¥˜ {stock_code}: {e}")
            return {
                'current_price': 100000,
                'prev_close': 100000,
                'volume': 0,
                'error': str(e)
            }
    
    async def send_order(self, stock_code: str, order_type: str, quantity: int, price: float) -> str:
        """ì£¼ë¬¸ ì „ì†¡"""
        try:
            if not self.is_connected:
                raise Exception("API ì—°ê²°ë˜ì§€ ì•ŠìŒ")
            
            # ì£¼ë¬¸ ë²ˆí˜¸ ìƒì„±
            order_id = f"ORD{self.order_counter:06d}"
            self.order_counter += 1
            
            # ì£¼ë¬¸ ë°ì´í„° ìƒì„±
            order_data = {
                'order_id': order_id,
                'stock_code': stock_code,
                'order_type': order_type.upper(),
                'quantity': quantity,
                'price': price,
                'status': 'pending',
                'order_time': datetime.now(),
                'fill_time': None,
                'fill_price': None,
                'fill_quantity': None,
                'remaining_quantity': quantity,
                'account_number': self.account_number
            }
            
            # ì£¼ë¬¸ ì €ì¥
            self.mock_orders[order_id] = order_data
            
            # ì£¼ë¬¸ ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘
            asyncio.create_task(self.simulate_order_fill(order_id))
            
            logger.info(f"ì£¼ë¬¸ ì „ì†¡ ì™„ë£Œ: {stock_code} {order_type} {quantity}ì£¼ @ {price}")
            return order_id
            
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ ì „ì†¡ ì‹¤íŒ¨: {e}")
            raise
    
    async def simulate_order_fill(self, order_id: str):
        """ì£¼ë¬¸ ì²´ê²° ì‹œë®¬ë ˆì´ì…˜"""
        try:
            await asyncio.sleep(random.uniform(1, 5))  # 1-5ì´ˆ í›„ ì²´ê²°
            
            if order_id not in self.mock_orders:
                return
            
            order = self.mock_orders[order_id]
            
            # ì²´ê²° í™•ë¥  (90%)
            if random.random() < 0.9:
                # ì²´ê²° ì²˜ë¦¬
                stock_code = order['stock_code']
                current_market_price = self.mock_prices.get(stock_code, {}).get('current_price', order['price'])
                
                # ì²´ê²°ê°€ ê²°ì • (ì£¼ë¬¸ê°€ ê·¼ì²˜ì—ì„œ ì²´ê²°)
                if order['order_type'] == 'BUY':
                    fill_price = min(order['price'], current_market_price + random.randint(-500, 500))
                else:  # SELL
                    fill_price = max(order['price'], current_market_price + random.randint(-500, 500))
                
                fill_quantity = order['quantity']  # ì „ëŸ‰ ì²´ê²°
                
                # ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
                order.update({
                    'status': 'filled',
                    'fill_time': datetime.now(),
                    'fill_price': fill_price,
                    'fill_quantity': fill_quantity,
                    'remaining_quantity': 0,
                    'commission': self.calculate_commission(fill_price * fill_quantity)
                })
                
                logger.info(f"ì£¼ë¬¸ ì²´ê²°: {order_id} - {fill_quantity}ì£¼ @ {fill_price}")
                
            else:
                # ì£¼ë¬¸ ì·¨ì†Œ ë˜ëŠ” ê±°ë¶€
                order['status'] = random.choice(['cancelled', 'rejected'])
                logger.info(f"ì£¼ë¬¸ {order['status']}: {order_id}")
                
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ ì²´ê²° ì‹œë®¬ë ˆì´ì…˜ ì˜¤ë¥˜ {order_id}: {e}")
    
    def calculate_commission(self, trade_amount: float) -> float:
        """ìˆ˜ìˆ˜ë£Œ ê³„ì‚°"""
        # ê°„ë‹¨í•œ ìˆ˜ìˆ˜ë£Œ ê³„ì‚° (ê±°ë˜ê¸ˆì•¡ì˜ 0.015%)
        commission_rate = 0.00015
        return trade_amount * commission_rate
    
    async def get_order_status(self, order_id: str) -> Dict[str, Any]:
        """ì£¼ë¬¸ ìƒíƒœ ì¡°íšŒ"""
        try:
            if order_id not in self.mock_orders:
                return {'status': 'not_found', 'error': 'ì£¼ë¬¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ'}
            
            order = self.mock_orders[order_id].copy()
            return order
            
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ ìƒíƒœ ì¡°íšŒ ì˜¤ë¥˜ {order_id}: {e}")
            return {'status': 'error', 'error': str(e)}
    
    async def cancel_order(self, order_id: str) -> bool:
        """ì£¼ë¬¸ ì·¨ì†Œ"""
        try:
            if order_id not in self.mock_orders:
                return False
            
            order = self.mock_orders[order_id]
            
            if order['status'] == 'pending':
                order['status'] = 'cancelled'
                order['cancel_time'] = datetime.now()
                logger.info(f"ì£¼ë¬¸ ì·¨ì†Œë¨: {order_id}")
                return True
            else:
                logger.warning(f"ì·¨ì†Œí•  ìˆ˜ ì—†ëŠ” ì£¼ë¬¸ ìƒíƒœ: {order_id} ({order['status']})")
                return False
                
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ ì·¨ì†Œ ì˜¤ë¥˜ {order_id}: {e}")
            return False
    
    async def get_account_info(self) -> Dict[str, Any]:
        """ê³„ì¢Œ ì •ë³´ ì¡°íšŒ"""
        try:
            if not self.is_connected:
                raise Exception("API ì—°ê²°ë˜ì§€ ì•ŠìŒ")
            
            # ëª¨ì˜ ê³„ì¢Œ ì •ë³´
            account_info = {
                'account_number': self.account_number,
                'account_name': 'ëª¨ì˜íˆ¬ìê³„ì¢Œ',
                'total_cash': 50000000,  # 5ì²œë§Œì›
                'available_cash': 24000000,  # 2ì²œ4ë°±ë§Œì›
                'total_evaluation': 50000000,
                'total_profit_loss': 0,
                'profit_loss_rate': 0.0,
                'server_type': self.server_type
            }
            
            return account_info
            
        except Exception as e:
            logger.error(f"ê³„ì¢Œ ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return {}
    
    async def get_balance(self) -> List[Dict[str, Any]]:
        """ì”ê³  ì¡°íšŒ"""
        try:
            if not self.is_connected:
                raise Exception("API ì—°ê²°ë˜ì§€ ì•ŠìŒ")
            
            # ëª¨ì˜ ì”ê³  ë°ì´í„°
            balance = []
            
            # í˜„ì¬ ë³´ìœ  ì¢…ëª© ì‹œë®¬ë ˆì´ì…˜
            holdings = {
                '005930': {'quantity': 50, 'avg_price': 70000},
                '035720': {'quantity': 30, 'avg_price': 88000}
            }
            
            for stock_code, holding in holdings.items():
                current_price_data = await self.get_current_price(stock_code)
                current_price = current_price_data['current_price']
                
                quantity = holding['quantity']
                avg_price = holding['avg_price']
                current_value = current_price * quantity
                purchase_value = avg_price * quantity
                profit_loss = current_value - purchase_value
                profit_loss_rate = (profit_loss / purchase_value) * 100
                
                balance_item = {
                    'stock_code': stock_code,
                    'stock_name': self.get_stock_name(stock_code),
                    'quantity': quantity,
                    'avg_price': avg_price,
                    'current_price': current_price,
                    'current_value': current_value,
                    'purchase_value': purchase_value,
                    'profit_loss': profit_loss,
                    'profit_loss_rate': profit_loss_rate,
                    'loan_amount': 0  # ì‹ ìš©ê±°ë˜ ì—†ìŒ
                }
                
                balance.append(balance_item)
            
            return balance
            
        except Exception as e:
            logger.error(f"ì”ê³  ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return []
    
    def get_stock_name(self, stock_code: str) -> str:
        """ì¢…ëª©ëª… ì¡°íšŒ"""
        stock_names = {
            '005930': 'ì‚¼ì„±ì „ì',
            '000660': 'SKí•˜ì´ë‹‰ìŠ¤',
            '035420': 'NAVER',
            '035720': 'ì¹´ì¹´ì˜¤',
            '051910': 'LGí™”í•™',
            '006400': 'ì‚¼ì„±SDI',
            '207940': 'ì‚¼ì„±ë°”ì´ì˜¤ë¡œì§ìŠ¤',
            '373220': 'LGì—ë„ˆì§€ì†”ë£¨ì…˜'
        }
        return stock_names.get(stock_code, f'ì¢…ëª©{stock_code}')
    
    async def get_order_history(self, days: int = 30) -> List[Dict[str, Any]]:
        """ì£¼ë¬¸ ë‚´ì—­ ì¡°íšŒ"""
        try:
            if not self.is_connected:
                raise Exception("API ì—°ê²°ë˜ì§€ ì•ŠìŒ")
            
            # ë‚ ì§œ ë²”ìœ„ ì„¤ì •
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)
            
            # ì¡°ê±´ì— ë§ëŠ” ì£¼ë¬¸ë“¤ í•„í„°ë§
            history = []
            for order_id, order in self.mock_orders.items():
                order_time = order['order_time']
                if start_date <= order_time <= end_date:
                    history_item = order.copy()
                    history_item['stock_name'] = self.get_stock_name(order['stock_code'])
                    history.append(history_item)
            
            # ì£¼ë¬¸ ì‹œê°„ ì—­ìˆœ ì •ë ¬
            history.sort(key=lambda x: x['order_time'], reverse=True)
            
            return history
            
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ ë‚´ì—­ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return []
    
    async def get_market_status(self) -> Dict[str, Any]:
        """ì‹œì¥ ìƒíƒœ ì¡°íšŒ"""
        try:
            current_time = datetime.now()
            current_hour = current_time.hour
            current_minute = current_time.minute
            
            # ì‹œì¥ ê°œì¥ ì‹œê°„ ì²´í¬ (9:00 - 15:30)
            is_market_open = False
            market_status = "ì¥ë§ˆê°"
            
            if current_time.weekday() < 5:  # í‰ì¼
                if (current_hour == 9 and current_minute >= 0) or \
                   (9 < current_hour < 15) or \
                   (current_hour == 15 and current_minute <= 30):
                    is_market_open = True
                    market_status = "ì •ê·œì¥"
                elif current_hour == 8 and current_minute >= 30:
                    market_status = "ì¥ì „ë™ì‹œí˜¸ê°€"
                elif current_hour == 15 and 30 < current_minute <= 40:
                    market_status = "ì¥í›„ë™ì‹œí˜¸ê°€"
            
            return {
                'is_open': is_market_open,
                'status': market_status,
                'server_time': current_time.isoformat(),
                'kospi_index': random.randint(2400, 2800),
                'kosdaq_index': random.randint(800, 1000),
                'exchange_rate': random.uniform(1300, 1400)  # ë‹¬ëŸ¬ í™˜ìœ¨
            }
            
        except Exception as e:
            logger.error(f"ì‹œì¥ ìƒíƒœ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return {'is_open': False, 'status': 'error'}
    
    async def get_stock_info(self, stock_code: str) -> Dict[str, Any]:
        """ì¢…ëª© ìƒì„¸ ì •ë³´ ì¡°íšŒ"""
        try:
            if not self.is_connected:
                raise Exception("API ì—°ê²°ë˜ì§€ ì•ŠìŒ")
            
            # ê¸°ë³¸ ì‹œì„¸ ì •ë³´ ì¡°íšŒ
            price_data = await self.get_current_price(stock_code)
            
            # ì¶”ê°€ ì¢…ëª© ì •ë³´
            stock_info = {
                'stock_code': stock_code,
                'stock_name': self.get_stock_name(stock_code),
                'market': 'KOSPI' if stock_code.startswith(('00', '05')) else 'KOSDAQ',
                'sector': self.get_stock_sector(stock_code),
                'market_cap': price_data.get('market_cap', 0),
                'shares_outstanding': random.randint(100000000, 1000000000),
                'per': random.uniform(8.0, 25.0),
                'pbr': random.uniform(0.8, 3.0),
                'roe': random.uniform(5.0, 20.0),
                'dividend_yield': random.uniform(1.0, 5.0),
                'foreign_ownership': random.uniform(10.0, 70.0),
                '52_week_high': int(price_data['current_price'] * random.uniform(1.2, 1.8)),
                '52_week_low': int(price_data['current_price'] * random.uniform(0.6, 0.9))
            }
            
            stock_info.update(price_data)
            
            return stock_info
            
        except Exception as e:
            logger.error(f"ì¢…ëª© ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜ {stock_code}: {e}")
            return {}
    
    def get_stock_sector(self, stock_code: str) -> str:
        """ì¢…ëª© ì„¹í„° ì¡°íšŒ"""
        sector_map = {
            '005930': 'ë°˜ë„ì²´',
            '000660': 'ë°˜ë„ì²´',
            '035420': 'ì¸í„°ë„·',
            '035720': 'ì¸í„°ë„·',
            '051910': 'í™”í•™',
            '006400': 'ë°°í„°ë¦¬',
            '207940': 'ë°”ì´ì˜¤',
            '373220': 'ë°°í„°ë¦¬'
        }
        return sector_map.get(stock_code, 'ê¸°íƒ€')
    
    async def get_candle_data(self, stock_code: str, period: str = 'D', count: int = 100) -> List[Dict[str, Any]]:
        """ìº”ë“¤ ë°ì´í„° ì¡°íšŒ"""
        try:
            if not self.is_connected:
                raise Exception("API ì—°ê²°ë˜ì§€ ì•ŠìŒ")
            
            # í˜„ì¬ ê°€ê²© ê¸°ì¤€ìœ¼ë¡œ ê³¼ê±° ìº”ë“¤ ë°ì´í„° ì‹œë®¬ë ˆì´ì…˜
            current_price_data = await self.get_current_price(stock_code)
            base_price = current_price_data['current_price']
            
            candles = []
            current_date = datetime.now()
            
            for i in range(count):
                # ë‚ ì§œ ê³„ì‚°
                if period == 'D':
                    date = current_date - timedelta(days=i)
                elif period == 'W':
                    date = current_date - timedelta(weeks=i)
                elif period == 'M':
                    date = current_date - timedelta(days=i*30)
                else:  # minute
                    date = current_date - timedelta(minutes=i)
                
                # ê°€ê²© ì‹œë®¬ë ˆì´ì…˜
                price_variation = random.uniform(0.9, 1.1)
                open_price = int(base_price * price_variation)
                
                high_variation = random.uniform(1.0, 1.05)
                high_price = int(open_price * high_variation)
                
                low_variation = random.uniform(0.95, 1.0)
                low_price = int(open_price * low_variation)
                
                close_variation = random.uniform(0.98, 1.02)
                close_price = int(open_price * close_variation)
                
                volume = random.randint(100000, 5000000)
                
                candle = {
                    'date': date.strftime('%Y%m%d'),
                    'time': date.strftime('%H%M%S') if period in ['1', '5', '15', '30', '60'] else None,
                    'open': open_price,
                    'high': high_price,
                    'low': low_price,
                    'close': close_price,
                    'volume': volume,
                    'amount': close_price * volume
                }
                
                candles.append(candle)
                
                # ë‹¤ìŒ ê³„ì‚°ì„ ìœ„í•´ base_price ì¡°ì •
                base_price = close_price
            
            # ì‹œê°„ìˆœ ì •ë ¬
            candles.reverse()
            
            return candles
            
        except Exception as e:
            logger.error(f"ìº”ë“¤ ë°ì´í„° ì¡°íšŒ ì˜¤ë¥˜ {stock_code}: {e}")
            return []
    
    async def get_market_capitalization(self, market: str = 'KOSPI') -> List[Dict[str, Any]]:
        """ì‹œê°€ì´ì•¡ ìƒìœ„ ì¢…ëª© ì¡°íšŒ"""
        try:
            if not self.is_connected:
                raise Exception("API ì—°ê²°ë˜ì§€ ì•ŠìŒ")
            
            # ì‹œê°€ì´ì•¡ ìƒìœ„ ì¢…ëª© ì‹œë®¬ë ˆì´ì…˜
            top_stocks = []
            
            if market == 'KOSPI':
                stock_list = ['005930', '000660', '035420', '051910', '006400', '207940', '373220']
            else:  # KOSDAQ
                stock_list = ['035720']
            
            for i, stock_code in enumerate(stock_list):
                price_data = await self.get_current_price(stock_code)
                
                stock_info = {
                    'rank': i + 1,
                    'stock_code': stock_code,
                    'stock_name': self.get_stock_name(stock_code),
                    'current_price': price_data['current_price'],
                    'change_rate': price_data.get('change_rate', 0),
                    'market_cap': price_data.get('market_cap', 0),
                    'volume': price_data['volume']
                }
                
                top_stocks.append(stock_info)
            
            # ì‹œê°€ì´ì•¡ ê¸°ì¤€ ì •ë ¬
            top_stocks.sort(key=lambda x: x['market_cap'], reverse=True)
            
            return top_stocks
            
        except Exception as e:
            logger.error(f"ì‹œê°€ì´ì•¡ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return []
    
    async def search_stock(self, keyword: str) -> List[Dict[str, Any]]:
        """ì¢…ëª© ê²€ìƒ‰"""
        try:
            if not self.is_connected:
                raise Exception("API ì—°ê²°ë˜ì§€ ì•ŠìŒ")
            
            results = []
            
            # ëª¨ë“  ì¢…ëª©ì—ì„œ ê²€ìƒ‰
            for stock_code in self.mock_prices.keys():
                stock_name = self.get_stock_name(stock_code)
                
                # ì¢…ëª©ì½”ë“œë‚˜ ì¢…ëª©ëª…ì— í‚¤ì›Œë“œê°€ í¬í•¨ëœ ê²½ìš°
                if keyword.lower() in stock_code.lower() or keyword in stock_name:
                    price_data = await self.get_current_price(stock_code)
                    
                    result = {
                        'stock_code': stock_code,
                        'stock_name': stock_name,
                        'current_price': price_data['current_price'],
                        'change_rate': price_data.get('change_rate', 0),
                        'market': 'KOSPI' if stock_code.startswith(('00', '05')) else 'KOSDAQ'
                    }
                    
                    results.append(result)
            
            return results
            
        except Exception as e:
            logger.error(f"ì¢…ëª© ê²€ìƒ‰ ì˜¤ë¥˜: {e}")
            return []
    
    async def get_news(self, stock_code: str = None, count: int = 10) -> List[Dict[str, Any]]:
        """ë‰´ìŠ¤ ì¡°íšŒ"""
        try:
            if not self.is_connected:
                raise Exception("API ì—°ê²°ë˜ì§€ ì•ŠìŒ")
            
            # ëª¨ì˜ ë‰´ìŠ¤ ë°ì´í„° ìƒì„±
            news_titles = [
                "ë°˜ë„ì²´ ì—…í™© ê°œì„  ê¸°ëŒ€ê° í™•ì‚°",
                "4ë¶„ê¸° ì‹¤ì  ì „ë§ ì–‘í˜¸",
                "ì‹ ì œí’ˆ ì¶œì‹œë¡œ ë§¤ì¶œ ì¦ëŒ€ ì˜ˆìƒ",
                "í•´ì™¸ ì‹œì¥ ì§„ì¶œ ê³„íš ë°œí‘œ",
                "ESG ê²½ì˜ ê°•í™” ë°©ì•ˆ ê³µê°œ",
                "ë””ì§€í„¸ ì „í™˜ íˆ¬ì í™•ëŒ€",
                "ì¹œí™˜ê²½ ê¸°ìˆ  ê°œë°œ ë°•ì°¨",
                "ê¸€ë¡œë²Œ íŒŒíŠ¸ë„ˆì‹­ ì²´ê²°"
            ]
            
            news_list = []
            
            for i in range(count):
                news_time = datetime.now() - timedelta(hours=random.randint(1, 48))
                
                news_item = {
                    'title': random.choice(news_titles),
                    'content': "ê´€ë ¨ ë‰´ìŠ¤ ë‚´ìš©ì…ë‹ˆë‹¤.",
                    'source': random.choice(['ì—°í•©ë‰´ìŠ¤', 'ì´ë°ì¼ë¦¬', 'ë§¤ì¼ê²½ì œ', 'í•œêµ­ê²½ì œ']),
                    'datetime': news_time.isoformat(),
                    'stock_code': stock_code if stock_code else random.choice(list(self.mock_prices.keys())),
                    'url': f"http://example.com/news/{i+1}"
                }
                
                news_list.append(news_item)
            
            # ì‹œê°„ìˆœ ì •ë ¬
            news_list.sort(key=lambda x: x['datetime'], reverse=True)
            
            return news_list
            
        except Exception as e:
            logger.error(f"ë‰´ìŠ¤ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return []
    
    def get_connection_status(self) -> Dict[str, Any]:
        """ì—°ê²° ìƒíƒœ í™•ì¸"""
        return {
            'is_connected': self.is_connected,
            'account_number': self.account_number if self.is_connected else None,
            'server_type': self.server_type,
            'api_version': '1.0.0',
            'connection_time': datetime.now().isoformat() if self.is_connected else None
        } 



==================================================
File: C:\Aproject\test\quant_actual\backend\data\market_data.py
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\backend\data\__init__.py
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\backend\trading\engine.py
==================================================
# file: backend/trading/engine.py

import asyncio
import logging
from datetime import datetime, time, timedelta
from typing import Dict, List, Optional
import json

from models import *
from database import get_db_session, DatabaseManager
from trading.strategies import StrategyManager
from trading.risk_manager import RiskManager
from data.kiwoom_mock import KiwoomClient
from utils.config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

class TradingEngine:
    """ë©”ì¸ íŠ¸ë ˆì´ë”© ì—”ì§„"""
    
    def __init__(self):
        self.is_running = False
        self.is_trading_enabled = False
        self.kiwoom_client = None
        self.strategy_manager = None
        self.risk_manager = None
        self.current_positions = {}
        self.active_strategies = {}
        self.market_data = {}
        self.daily_pnl = 0.0
        self.last_update = None
        
        # ì‹œì¥ ì‹œê°„ ì„¤ì •
        self.market_open_time = time(9, 0)    # ì˜¤ì „ 9ì‹œ
        self.market_close_time = time(15, 30)  # ì˜¤í›„ 3ì‹œ 30ë¶„
        
    async def initialize(self):
        """íŠ¸ë ˆì´ë”© ì—”ì§„ ì´ˆê¸°í™”"""
        try:
            logger.info("íŠ¸ë ˆì´ë”© ì—”ì§„ ì´ˆê¸°í™” ì‹œì‘...")
            
            # í‚¤ì›€ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
            self.kiwoom_client = KiwoomClient()
            await self.kiwoom_client.connect()
            
            # ì „ëµ ë§¤ë‹ˆì € ì´ˆê¸°í™”
            self.strategy_manager = StrategyManager()
            await self.strategy_manager.initialize()
            
            # ë¦¬ìŠ¤í¬ ë§¤ë‹ˆì € ì´ˆê¸°í™”
            self.risk_manager = RiskManager()
            
            # í™œì„± ì „ëµ ë¡œë“œ
            await self.load_active_strategies()
            
            # í˜„ì¬ í¬ì§€ì…˜ ë¡œë“œ
            await self.load_current_positions()
            
            logger.info("íŠ¸ë ˆì´ë”© ì—”ì§„ ì´ˆê¸°í™” ì™„ë£Œ")
            
        except Exception as e:
            logger.error(f"íŠ¸ë ˆì´ë”© ì—”ì§„ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            raise
    
    async def run(self):
        """ë©”ì¸ íŠ¸ë ˆì´ë”© ë£¨í”„"""
        self.is_running = True
        logger.info("íŠ¸ë ˆì´ë”© ë£¨í”„ ì‹œì‘")
        
        try:
            while self.is_running:
                current_time = datetime.now().time()
                
                # ì‹œì¥ ì‹œê°„ì¸ì§€ í™•ì¸
                if self.is_market_hours(current_time):
                    if not self.is_trading_enabled:
                        self.is_trading_enabled = True
                        logger.info("ì‹œì¥ ì‹œê°„ - íŠ¸ë ˆì´ë”© í™œì„±í™”")
                    
                    await self.trading_cycle()
                else:
                    if self.is_trading_enabled:
                        self.is_trading_enabled = False
                        logger.info("ì‹œì¥ ì¢…ë£Œ - íŠ¸ë ˆì´ë”© ë¹„í™œì„±í™”")
                    
                    # ì‹œì¥ ì™¸ ì‹œê°„ì—ëŠ” ë°ì´í„° ì •ë¦¬ ì‘ì—…
                    await self.after_market_tasks()
                
                # 1ì´ˆ ëŒ€ê¸°
                await asyncio.sleep(1)
                
        except asyncio.CancelledError:
            logger.info("íŠ¸ë ˆì´ë”© ë£¨í”„ ì·¨ì†Œë¨")
        except Exception as e:
            logger.error(f"íŠ¸ë ˆì´ë”© ë£¨í”„ ì˜¤ë¥˜: {e}")
        finally:
            self.is_running = False
            logger.info("íŠ¸ë ˆì´ë”© ë£¨í”„ ì¢…ë£Œ")
    
    async def trading_cycle(self):
        """ë‹¨ì¼ íŠ¸ë ˆì´ë”© ì‚¬ì´í´ (1ì´ˆë§ˆë‹¤ ì‹¤í–‰)"""
        try:
            # 1. ì‹¤ì‹œê°„ ì‹œì¥ ë°ì´í„° ìˆ˜ì‹ 
            await self.update_market_data()
            
            # 2. í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸
            await self.update_positions()
            
            # 3. ê° ì „ëµë³„ ì‹ í˜¸ ìƒì„± ë° ì²˜ë¦¬
            for strategy_id, strategy in self.active_strategies.items():
                try:
                    # ì „ëµë³„ ì‹ í˜¸ ê³„ì‚°
                    signals = await self.strategy_manager.generate_signals(
                        strategy_id, self.market_data
                    )
                    
                    # ì‹ í˜¸ê°€ ìˆìœ¼ë©´ ì²˜ë¦¬
                    if signals:
                        await self.process_signals(signals, strategy_id)
                        
                except Exception as e:
                    logger.error(f"ì „ëµ {strategy_id} ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")
            
            # 4. í¬íŠ¸í´ë¦¬ì˜¤ ìƒíƒœ ì—…ë°ì´íŠ¸
            await self.update_portfolio()
            
            # 5. ë¦¬ìŠ¤í¬ ì²´í¬
            await self.check_risk_limits()
            
            self.last_update = datetime.now()
            
        except Exception as e:
            logger.error(f"íŠ¸ë ˆì´ë”© ì‚¬ì´í´ ì˜¤ë¥˜: {e}")
    
    async def update_market_data(self):
        """ì‹¤ì‹œê°„ ì‹œì¥ ë°ì´í„° ì—…ë°ì´íŠ¸"""
        try:
            # ëª¨ë“  ê´€ì‹¬ ì¢…ëª©ì˜ í˜„ì¬ê°€ ì¡°íšŒ
            stock_codes = set()
            
            # í™œì„± ì „ëµì˜ ëŒ€ìƒ ì¢…ëª©ë“¤ ìˆ˜ì§‘
            for strategy in self.active_strategies.values():
                target_stocks = json.loads(strategy.target_stocks)
                stock_codes.update(target_stocks)
            
            # í˜„ì¬ ë³´ìœ  ì¢…ëª©ë“¤ ì¶”ê°€
            for position in self.current_positions.values():
                stock_codes.add(position['stock_code'])
            
            # í‚¤ì›€ APIë¥¼ í†µí•œ ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì‹ 
            for stock_code in stock_codes:
                price_data = await self.kiwoom_client.get_current_price(stock_code)
                self.market_data[stock_code] = price_data
                
                # ë°ì´í„°ë² ì´ìŠ¤ì— ê°€ê²© ì—…ë°ì´íŠ¸
                DatabaseManager.update_stock_price(
                    stock_code, 
                    price_data['current_price'], 
                    price_data['volume']
                )
            
        except Exception as e:
            logger.error(f"ì‹œì¥ ë°ì´í„° ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    async def process_signals(self, signals: List[TradingSignal], strategy_id: int):
        """íŠ¸ë ˆì´ë”© ì‹ í˜¸ ì²˜ë¦¬"""
        for signal in signals:
            try:
                # ë¦¬ìŠ¤í¬ ê²€ì¦
                if not await self.risk_manager.validate_signal(signal, self.current_positions):
                    logger.warning(f"ë¦¬ìŠ¤í¬ ê²€ì¦ ì‹¤íŒ¨ - ì‹ í˜¸ ë¬´ì‹œ: {signal.stock_code} {signal.signal_type}")
                    continue
                
                # ì£¼ë¬¸ ìƒì„± ë° ì‹¤í–‰
                order_id = await self.create_and_execute_order(signal, strategy_id)
                
                if order_id:
                    logger.info(f"ì£¼ë¬¸ ì‹¤í–‰: {signal.stock_code} {signal.signal_type} {signal.quantity}ì£¼")
                
            except Exception as e:
                logger.error(f"ì‹ í˜¸ ì²˜ë¦¬ ì‹¤íŒ¨ {signal.stock_code}: {e}")
    
    async def create_and_execute_order(self, signal: TradingSignal, strategy_id: int) -> Optional[int]:
        """ì£¼ë¬¸ ìƒì„± ë° ì‹¤í–‰"""
        try:
            with get_db_session() as db:
                # ì¢…ëª© ì •ë³´ ì¡°íšŒ
                stock = db.query(Stock).filter(Stock.code == signal.stock_code).first()
                if not stock:
                    logger.error(f"ì¢…ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: {signal.stock_code}")
                    return None
                
                # ì£¼ë¬¸ ìƒì„±
                order = Order(
                    strategy_id=strategy_id,
                    stock_id=stock.id,
                    order_type=signal.signal_type,
                    quantity=signal.quantity,
                    price=signal.price,
                    status=OrderStatus.PENDING,
                    order_time=datetime.now()
                )
                
                db.add(order)
                db.commit()
                db.refresh(order)
                
                # í‚¤ì›€ APIë¥¼ í†µí•œ ì£¼ë¬¸ ì „ì†¡
                kiwoom_order_id = await self.kiwoom_client.send_order(
                    stock_code=signal.stock_code,
                    order_type=signal.signal_type,
                    quantity=signal.quantity,
                    price=signal.price
                )
                
                # í‚¤ì›€ ì£¼ë¬¸ ë²ˆí˜¸ ì—…ë°ì´íŠ¸
                order.kiwoom_order_id = kiwoom_order_id
                db.commit()
                
                # ì£¼ë¬¸ ìƒíƒœ ëª¨ë‹ˆí„°ë§ ì‹œì‘
                asyncio.create_task(self.monitor_order(order.id))
                
                return order.id
                
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ ìƒì„± ì‹¤íŒ¨: {e}")
            return None
    
    async def monitor_order(self, order_id: int):
        """ì£¼ë¬¸ ìƒíƒœ ëª¨ë‹ˆí„°ë§"""
        try:
            max_wait_time = 300  # 5ë¶„ ìµœëŒ€ ëŒ€ê¸°
            start_time = datetime.now()
            
            while (datetime.now() - start_time).seconds < max_wait_time:
                with get_db_session() as db:
                    order = db.query(Order).filter(Order.id == order_id).first()
                    if not order:
                        break
                    
                    # í‚¤ì›€ APIì—ì„œ ì£¼ë¬¸ ìƒíƒœ ì¡°íšŒ
                    order_status = await self.kiwoom_client.get_order_status(order.kiwoom_order_id)
                    
                    if order_status['status'] == 'filled':
                        # ì£¼ë¬¸ ì²´ê²° ì²˜ë¦¬
                        order.status = OrderStatus.FILLED
                        order.fill_time = datetime.now()
                        order.fill_price = order_status['fill_price']
                        order.fill_quantity = order_status['fill_quantity']
                        order.commission = order_status.get('commission', 0.0)
                        
                        db.commit()
                        
                        # í¬ì§€ì…˜ ì—…ë°ì´íŠ¸
                        await self.update_position_from_order(order)
                        
                        logger.info(f"ì£¼ë¬¸ ì²´ê²°: {order.id} - {order_status['fill_quantity']}ì£¼ @ {order_status['fill_price']}")
                        break
                    
                    elif order_status['status'] == 'cancelled':
                        order.status = OrderStatus.CANCELLED
                        db.commit()
                        logger.info(f"ì£¼ë¬¸ ì·¨ì†Œ: {order.id}")
                        break
                    
                    elif order_status['status'] == 'rejected':
                        order.status = OrderStatus.REJECTED
                        db.commit()
                        logger.warning(f"ì£¼ë¬¸ ê±°ë¶€: {order.id}")
                        break
                
                await asyncio.sleep(1)  # 1ì´ˆë§ˆë‹¤ ì²´í¬
                
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ ëª¨ë‹ˆí„°ë§ ì‹¤íŒ¨ {order_id}: {e}")
    
    async def update_position_from_order(self, order: Order):
        """ì£¼ë¬¸ ì²´ê²° í›„ í¬ì§€ì…˜ ì—…ë°ì´íŠ¸"""
        try:
            with get_db_session() as db:
                stock = db.query(Stock).filter(Stock.id == order.stock_id).first()
                
                # ê¸°ì¡´ í¬ì§€ì…˜ ì¡°íšŒ
                position = db.query(Position)\
                    .filter(Position.strategy_id == order.strategy_id)\
                    .filter(Position.stock_id == order.stock_id)\
                    .first()
                
                if order.order_type == OrderType.BUY:
                    if position:
                        # ê¸°ì¡´ í¬ì§€ì…˜ì— ì¶”ê°€
                        total_cost = (position.quantity * position.avg_price) + (order.fill_quantity * order.fill_price)
                        total_quantity = position.quantity + order.fill_quantity
                        position.avg_price = total_cost / total_quantity
                        position.quantity = total_quantity
                    else:
                        # ìƒˆ í¬ì§€ì…˜ ìƒì„±
                        position = Position(
                            strategy_id=order.strategy_id,
                            stock_id=order.stock_id,
                            quantity=order.fill_quantity,
                            avg_price=order.fill_price,
                            current_price=order.fill_price
                        )
                        db.add(position)
                
                elif order.order_type == OrderType.SELL and position:
                    # ë§¤ë„ ì²˜ë¦¬
                    sell_quantity = min(order.fill_quantity, position.quantity)
                    
                    # ì‹¤í˜„ì†ìµ ê³„ì‚°
                    realized_pnl = (order.fill_price - position.avg_price) * sell_quantity - order.commission
                    position.realized_pnl += realized_pnl
                    position.quantity -= sell_quantity
                    
                    # í¬ì§€ì…˜ì´ 0ì´ ë˜ë©´ ì‚­ì œí•˜ì§€ ì•Šê³  ìœ ì§€ (íˆìŠ¤í† ë¦¬ ëª©ì )
                    if position.quantity <= 0:
                        position.quantity = 0
                
                if position:
                    position.updated_at = datetime.now()
                
                db.commit()
                
                # ë©”ëª¨ë¦¬ ìƒì˜ í¬ì§€ì…˜ ì •ë³´ë„ ì—…ë°ì´íŠ¸
                await self.load_current_positions()
                
        except Exception as e:
            logger.error(f"í¬ì§€ì…˜ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    async def update_positions(self):
        """í¬ì§€ì…˜ì˜ í˜„ì¬ê°€ ë° ë¯¸ì‹¤í˜„ì†ìµ ì—…ë°ì´íŠ¸"""
        try:
            with get_db_session() as db:
                positions = db.query(Position)\
                    .filter(Position.quantity > 0)\
                    .all()
                
                for position in positions:
                    stock = db.query(Stock).filter(Stock.id == position.stock_id).first()
                    if stock and stock.code in self.market_data:
                        current_price = self.market_data[stock.code]['current_price']
                        position.current_price = current_price
                        
                        # ë¯¸ì‹¤í˜„ì†ìµ ê³„ì‚°
                        position.unrealized_pnl = (current_price - position.avg_price) * position.quantity
                        position.updated_at = datetime.now()
                
                db.commit()
                
        except Exception as e:
            logger.error(f"í¬ì§€ì…˜ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    async def update_portfolio(self):
        """í¬íŠ¸í´ë¦¬ì˜¤ ìƒíƒœ ì—…ë°ì´íŠ¸"""
        try:
            with get_db_session() as db:
                # í˜„ì¬ í¬ì§€ì…˜ë“¤ì˜ ì •ë³´ ìˆ˜ì§‘
                positions = db.query(Position)\
                    .filter(Position.quantity > 0)\
                    .all()
                
                total_invested = sum(pos.avg_price * pos.quantity for pos in positions)
                total_current_value = sum((pos.current_price or pos.avg_price) * pos.quantity for pos in positions)
                total_unrealized_pnl = sum(pos.unrealized_pnl for pos in positions)
                total_realized_pnl = sum(pos.realized_pnl for pos in positions)
                
                # í˜„ê¸ˆ ì”ê³  (ì´ˆê¸° ìë³¸ì—ì„œ íˆ¬ìê¸ˆ ì°¨ê°)
                initial_cash = 50000000.0  # 5ì²œë§Œì›
                cash_balance = initial_cash - total_invested + total_realized_pnl
                
                # ì´ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜
                total_portfolio_value = cash_balance + total_current_value
                
                # ì¼ì¼ ì†ìµ ê³„ì‚° (ì˜¤ëŠ˜ ê±°ë˜ë¶„ë§Œ)
                today = datetime.now().date()
                today_orders = db.query(Order)\
                    .filter(Order.fill_time >= datetime.combine(today, time.min))\
                    .filter(Order.status == OrderStatus.FILLED)\
                    .all()
                
                daily_realized_pnl = 0.0
                for order in today_orders:
                    if order.order_type == OrderType.SELL:
                        # ê°„ë‹¨í•œ ì¼ì¼ ì‹¤í˜„ì†ìµ ê³„ì‚°
                        position = db.query(Position)\
                            .filter(Position.strategy_id == order.strategy_id)\
                            .filter(Position.stock_id == order.stock_id)\
                            .first()
                        if position:
                            daily_realized_pnl += (order.fill_price - position.avg_price) * order.fill_quantity
                
                # í¬íŠ¸í´ë¦¬ì˜¤ ë ˆì½”ë“œ ìƒì„±
                portfolio_record = Portfolio(
                    total_value=total_portfolio_value,
                    cash=cash_balance,
                    invested_amount=total_invested,
                    realized_pnl=total_realized_pnl,
                    unrealized_pnl=total_unrealized_pnl,
                    daily_pnl=daily_realized_pnl + total_unrealized_pnl,
                    total_return=((total_portfolio_value - initial_cash) / initial_cash) * 100,
                    timestamp=datetime.now()
                )
                
                db.add(portfolio_record)
                db.commit()
                
                self.daily_pnl = portfolio_record.daily_pnl
                
        except Exception as e:
            logger.error(f"í¬íŠ¸í´ë¦¬ì˜¤ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    async def check_risk_limits(self):
        """ë¦¬ìŠ¤í¬ í•œë„ ì²´í¬"""
        try:
            risk_check = await self.risk_manager.check_daily_limits(
                current_pnl=self.daily_pnl,
                current_positions=self.current_positions
            )
            
            if not risk_check['is_safe']:
                logger.warning(f"ë¦¬ìŠ¤í¬ í•œë„ ì´ˆê³¼: {risk_check['message']}")
                
                # ì‹¬ê°í•œ ë¦¬ìŠ¤í¬ì¸ ê²½ìš° ìë™ ì¤‘ë‹¨
                if risk_check['severity'] == 'critical':
                    await self.emergency_stop()
                    
        except Exception as e:
            logger.error(f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤íŒ¨: {e}")
    
    async def load_active_strategies(self):
        """í™œì„±í™”ëœ ì „ëµ ë¡œë“œ"""
        try:
            with get_db_session() as db:
                strategies = db.query(Strategy).filter(Strategy.is_active == True).all()
                
                self.active_strategies = {}
                for strategy in strategies:
                    self.active_strategies[strategy.id] = strategy
                    logger.info(f"í™œì„± ì „ëµ ë¡œë“œ: {strategy.name}")
                    
        except Exception as e:
            logger.error(f"í™œì„± ì „ëµ ë¡œë“œ ì‹¤íŒ¨: {e}")
    
    async def load_current_positions(self):
        """í˜„ì¬ í¬ì§€ì…˜ ë¡œë“œ"""
        try:
            with get_db_session() as db:
                positions = db.query(Position)\
                    .join(Stock)\
                    .filter(Position.quantity > 0)\
                    .all()
                
                self.current_positions = {}
                for pos in positions:
                    key = f"{pos.strategy_id}_{pos.stock_id}"
                    self.current_positions[key] = {
                        'strategy_id': pos.strategy_id,
                        'stock_id': pos.stock_id,
                        'stock_code': pos.stock.code,
                        'quantity': pos.quantity,
                        'avg_price': pos.avg_price,
                        'current_price': pos.current_price,
                        'unrealized_pnl': pos.unrealized_pnl
                    }
                    
        except Exception as e:
            logger.error(f"í¬ì§€ì…˜ ë¡œë“œ ì‹¤íŒ¨: {e}")
    
    async def after_market_tasks(self):
        """ì¥ ë§ˆê° í›„ ì‘ì—…ë“¤"""
        try:
            # 5ë¶„ë§ˆë‹¤ í•œ ë²ˆì”© ì‹¤í–‰
            if datetime.now().minute % 5 == 0:
                # ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬
                DatabaseManager.cleanup_old_data(days=30)
                
                # ë°±ì—… ìƒì„± (ì¼ì£¼ì¼ì— í•œ ë²ˆ)
                if datetime.now().weekday() == 6:  # ì¼ìš”ì¼
                    from database import backup_database
                    backup_database()
                    
        except Exception as e:
            logger.error(f"ì¥ ë§ˆê° í›„ ì‘ì—… ì‹¤íŒ¨: {e}")
    
    def is_market_hours(self, current_time: time) -> bool:
        """ì‹œì¥ ì‹œê°„ì¸ì§€ í™•ì¸"""
        # ì£¼ë§ ì œì™¸
        if datetime.now().weekday() >= 5:  # í† ìš”ì¼(5), ì¼ìš”ì¼(6)
            return False
        
        # ì‹œì¥ ì‹œê°„ ì²´í¬
        return self.market_open_time <= current_time <= self.market_close_time
    
    async def start_trading(self):
        """ìë™ë§¤ë§¤ ìˆ˜ë™ ì‹œì‘"""
        self.is_trading_enabled = True
        logger.info("ìë™ë§¤ë§¤ ìˆ˜ë™ ì‹œì‘ë¨")
    
    async def stop_trading(self):
        """ìë™ë§¤ë§¤ ì¤‘ì§€"""
        self.is_trading_enabled = False
        logger.info("ìë™ë§¤ë§¤ ì¤‘ì§€ë¨")
    
    async def emergency_stop(self):
        """ê¸´ê¸‰ ì¤‘ë‹¨"""
        try:
            logger.critical("ê¸´ê¸‰ì¤‘ë‹¨ ì‹¤í–‰ ì‹œì‘")
            
            # 1. ëª¨ë“  íŠ¸ë ˆì´ë”© ì¤‘ì§€
            self.is_trading_enabled = False
            
            # 2. ëŒ€ê¸°ì¤‘ì¸ ì£¼ë¬¸ ëª¨ë‘ ì·¨ì†Œ
            with get_db_session() as db:
                pending_orders = db.query(Order)\
                    .filter(Order.status == OrderStatus.PENDING)\
                    .all()
                
                for order in pending_orders:
                    try:
                        await self.kiwoom_client.cancel_order(order.kiwoom_order_id)
                        order.status = OrderStatus.CANCELLED
                        logger.info(f"ì£¼ë¬¸ ì·¨ì†Œ: {order.id}")
                    except Exception as e:
                        logger.error(f"ì£¼ë¬¸ ì·¨ì†Œ ì‹¤íŒ¨ {order.id}: {e}")
                
                db.commit()
            
            # 3. ëª¨ë“  í¬ì§€ì…˜ ì‹œì¥ê°€ ë§¤ë„ (ì„ íƒì )
            if settings.emergency_sell_all:
                await self.sell_all_positions()
            
            # 4. ì•Œë¦¼ ë°œì†¡
            await self.send_emergency_notification()
            
            logger.critical("ê¸´ê¸‰ì¤‘ë‹¨ ì‹¤í–‰ ì™„ë£Œ")
            
        except Exception as e:
            logger.error(f"ê¸´ê¸‰ì¤‘ë‹¨ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
            raise
    
    async def sell_all_positions(self):
        """ëª¨ë“  í¬ì§€ì…˜ ê°•ì œ ë§¤ë„"""
        try:
            with get_db_session() as db:
                positions = db.query(Position)\
                    .join(Stock)\
                    .filter(Position.quantity > 0)\
                    .all()
                
                for position in positions:
                    try:
                        # ì‹œì¥ê°€ ë§¤ë„ ì£¼ë¬¸
                        current_price = self.market_data.get(position.stock.code, {}).get('current_price', position.avg_price)
                        
                        order = Order(
                            strategy_id=position.strategy_id,
                            stock_id=position.stock_id,
                            order_type=OrderType.SELL,
                            quantity=position.quantity,
                            price=current_price * 0.95,  # í˜„ì¬ê°€ì˜ 95%ë¡œ ì‹œì¥ê°€ ë§¤ë„
                            status=OrderStatus.PENDING,
                            order_time=datetime.now()
                        )
                        
                        db.add(order)
                        db.commit()
                        
                        # í‚¤ì›€ APIë¡œ ì£¼ë¬¸ ì „ì†¡
                        kiwoom_order_id = await self.kiwoom_client.send_order(
                            stock_code=position.stock.code,
                            order_type=OrderType.SELL,
                            quantity=position.quantity,
                            price=order.price
                        )
                        
                        order.kiwoom_order_id = kiwoom_order_id
                        db.commit()
                        
                        logger.info(f"ê¸´ê¸‰ ë§¤ë„ ì£¼ë¬¸: {position.stock.code} {position.quantity}ì£¼")
                        
                    except Exception as e:
                        logger.error(f"ê¸´ê¸‰ ë§¤ë„ ì‹¤íŒ¨ {position.stock.code}: {e}")
                        
        except Exception as e:
            logger.error(f"ì „ì²´ í¬ì§€ì…˜ ë§¤ë„ ì‹¤íŒ¨: {e}")
    
    async def send_emergency_notification(self):
        """ê¸´ê¸‰ìƒí™© ì•Œë¦¼ ë°œì†¡"""
        try:
            # ì´ë©”ì¼, SMS, ìŠ¬ë™ ë“±ìœ¼ë¡œ ì•Œë¦¼ ë°œì†¡
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì ì ˆí•œ ì•Œë¦¼ ì„œë¹„ìŠ¤ ì‚¬ìš©
            logger.critical("ê¸´ê¸‰ì¤‘ë‹¨ ì•Œë¦¼ ë°œì†¡ë¨")
            
        except Exception as e:
            logger.error(f"ê¸´ê¸‰ ì•Œë¦¼ ë°œì†¡ ì‹¤íŒ¨: {e}")
    
    async def shutdown(self):
        """íŠ¸ë ˆì´ë”© ì—”ì§„ ì¢…ë£Œ"""
        try:
            logger.info("íŠ¸ë ˆì´ë”© ì—”ì§„ ì¢…ë£Œ ì¤‘...")
            
            # íŠ¸ë ˆì´ë”© ì¤‘ì§€
            self.is_running = False
            self.is_trading_enabled = False
            
            # í‚¤ì›€ ì—°ê²° í•´ì œ
            if self.kiwoom_client:
                await self.kiwoom_client.disconnect()
            
            logger.info("íŠ¸ë ˆì´ë”© ì—”ì§„ ì¢…ë£Œ ì™„ë£Œ")
            
        except Exception as e:
            logger.error(f"íŠ¸ë ˆì´ë”© ì—”ì§„ ì¢…ë£Œ ì‹¤íŒ¨: {e}")
    
    # APIì—ì„œ ì‚¬ìš©í•˜ëŠ” í—¬í¼ ë©”ì„œë“œë“¤
    async def activate_strategy(self, strategy_id: int):
        """ì „ëµ í™œì„±í™”"""
        await self.load_active_strategies()
        logger.info(f"ì „ëµ í™œì„±í™”: {strategy_id}")
    
    async def deactivate_strategy(self, strategy_id: int):
        """ì „ëµ ë¹„í™œì„±í™”"""
        if strategy_id in self.active_strategies:
            del self.active_strategies[strategy_id]
        logger.info(f"ì „ëµ ë¹„í™œì„±í™”: {strategy_id}")
    
    async def execute_manual_order(self, order_id: int):
        """ìˆ˜ë™ ì£¼ë¬¸ ì‹¤í–‰"""
        try:
            with get_db_session() as db:
                order = db.query(Order).filter(Order.id == order_id).first()
                if order:
                    await self.monitor_order(order_id)
                    
        except Exception as e:
            logger.error(f"ìˆ˜ë™ ì£¼ë¬¸ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
    
    def get_active_strategies(self):
        """í™œì„± ì „ëµ ëª©ë¡ ë°˜í™˜"""
        return list(self.active_strategies.values())
    
    def get_current_positions(self):
        """í˜„ì¬ í¬ì§€ì…˜ ëª©ë¡ ë°˜í™˜"""
        return list(self.current_positions.values())
    
    def get_daily_order_count(self):
        """ì˜¤ëŠ˜ ì£¼ë¬¸ ìˆ˜ ë°˜í™˜"""
        try:
            with get_db_session() as db:
                today = datetime.now().date()
                count = db.query(Order)\
                    .filter(Order.order_time >= datetime.combine(today, time.min))\
                    .count()
                return count
        except:
            return 0
    
    async def get_market_data(self):
        """í˜„ì¬ ì‹œì¥ ë°ì´í„° ë°˜í™˜"""
        return self.market_data
    
    async def get_recent_signals(self, limit: int = 20):
        """ìµœê·¼ ì‹ í˜¸ ëª©ë¡ ë°˜í™˜"""
        # ì‹¤ì œë¡œëŠ” ì‹ í˜¸ íˆìŠ¤í† ë¦¬ë¥¼ ì €ì¥í•˜ê³  ì¡°íšŒí•´ì•¼ í•¨
        return []
    
    async def get_risk_metrics(self):
        """ë¦¬ìŠ¤í¬ ì§€í‘œ ë°˜í™˜"""
        return await self.risk_manager.get_current_metrics()
    
    async def update_risk_limits(self, risk_limits: dict):
        """ë¦¬ìŠ¤í¬ í•œë„ ì—…ë°ì´íŠ¸"""
        await self.risk_manager.update_limits(risk_limits) 



==================================================
File: C:\Aproject\test\quant_actual\backend\trading\indicators.py
==================================================
# file: backend/trading/indicators.py

import numpy as np
import pandas as pd
from typing import List, Dict, Optional, Union
import logging

logger = logging.getLogger(__name__)

class TechnicalIndicators:
    """ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚° í´ë˜ìŠ¤"""
    
    @staticmethod
    def moving_average(prices: List[float], period: int) -> List[float]:
        """ë‹¨ìˆœ ì´ë™í‰ê·  (SMA) ê³„ì‚°"""
        if len(prices) < period:
            return []
        
        try:
            df = pd.Series(prices)
            ma = df.rolling(window=period).mean()
            return ma.dropna().tolist()
        except Exception as e:
            logger.error(f"ì´ë™í‰ê·  ê³„ì‚° ì˜¤ë¥˜: {e}")
            return []
    
    @staticmethod
    def exponential_moving_average(prices: List[float], period: int) -> List[float]:
        """ì§€ìˆ˜ ì´ë™í‰ê·  (EMA) ê³„ì‚°"""
        if len(prices) < period:
            return []
        
        try:
            df = pd.Series(prices)
            ema = df.ewm(span=period, adjust=False).mean()
            return ema.tolist()
        except Exception as e:
            logger.error(f"ì§€ìˆ˜ì´ë™í‰ê·  ê³„ì‚° ì˜¤ë¥˜: {e}")
            return []
    
    @staticmethod
    def bollinger_bands(prices: List[float], period: int = 20, std_dev: float = 2.0) -> Optional[Dict[str, List[float]]]:
        """ë³¼ë¦°ì € ë°´ë“œ ê³„ì‚°"""
        if len(prices) < period:
            return None
        
        try:
            df = pd.Series(prices)
            
            # í›„í–‰ìŠ¤íŒ¬ (Chikou Span)
            chikou_span = close_df.shift(-kijun_period)
            
            return {
                'tenkan_sen': tenkan_sen.dropna().tolist(),
                'kijun_sen': kijun_sen.dropna().tolist(),
                'senkou_span_a': senkou_span_a.dropna().tolist(),
                'senkou_span_b': senkou_span_b.dropna().tolist(),
                'chikou_span': chikou_span.dropna().tolist()
            }
        except Exception as e:
            logger.error(f"ì¼ëª©ê· í˜•í‘œ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return None

class PatternRecognition:
    """ìº”ë“¤ íŒ¨í„´ ì¸ì‹ í´ë˜ìŠ¤"""
    
    @staticmethod
    def is_doji(open_price: float, high_price: float, low_price: float, close_price: float, threshold: float = 0.1) -> bool:
        """ë„ì§€ íŒ¨í„´ ì¸ì‹"""
        try:
            body = abs(close_price - open_price)
            range_price = high_price - low_price
            
            if range_price == 0:
                return False
                
            body_ratio = body / range_price
            return body_ratio <= threshold
        except:
            return False
    
    @staticmethod
    def is_hammer(open_price: float, high_price: float, low_price: float, close_price: float) -> bool:
        """í•´ë¨¸ íŒ¨í„´ ì¸ì‹"""
        try:
            body = abs(close_price - open_price)
            upper_shadow = high_price - max(open_price, close_price)
            lower_shadow = min(open_price, close_price) - low_price
            
            # í•´ë¨¸ ì¡°ê±´: ì§§ì€ ëª¸í†µ, ê¸´ ì•„ë˜ê¼¬ë¦¬, ì§§ì€ ìœ„ê¼¬ë¦¬
            return (lower_shadow >= 2 * body and 
                   upper_shadow <= body * 0.5 and
                   body > 0)
        except:
            return False
    
    @staticmethod
    def is_shooting_star(open_price: float, high_price: float, low_price: float, close_price: float) -> bool:
        """ìœ ì„± íŒ¨í„´ ì¸ì‹"""
        try:
            body = abs(close_price - open_price)
            upper_shadow = high_price - max(open_price, close_price)
            lower_shadow = min(open_price, close_price) - low_price
            
            # ìœ ì„± ì¡°ê±´: ì§§ì€ ëª¸í†µ, ê¸´ ìœ„ê¼¬ë¦¬, ì§§ì€ ì•„ë˜ê¼¬ë¦¬
            return (upper_shadow >= 2 * body and 
                   lower_shadow <= body * 0.5 and
                   body > 0)
        except:
            return False
    
    @staticmethod
    def is_engulfing_bullish(candle1: Dict[str, float], candle2: Dict[str, float]) -> bool:
        """ê°•ì„¸ í¬ìš©ì„  íŒ¨í„´ ì¸ì‹"""
        try:
            # ì²« ë²ˆì§¸ ìº”ë“¤: ìŒë´‰
            first_bearish = candle1['close'] < candle1['open']
            
            # ë‘ ë²ˆì§¸ ìº”ë“¤: ì–‘ë´‰ì´ê³  ì²« ë²ˆì§¸ ìº”ë“¤ì„ ì™„ì „íˆ í¬ìš©
            second_bullish = candle2['close'] > candle2['open']
            engulfs = (candle2['open'] < candle1['close'] and 
                      candle2['close'] > candle1['open'])
            
            return first_bearish and second_bullish and engulfs
        except:
            return False
    
    @staticmethod
    def is_engulfing_bearish(candle1: Dict[str, float], candle2: Dict[str, float]) -> bool:
        """ì•½ì„¸ í¬ìš©ì„  íŒ¨í„´ ì¸ì‹"""
        try:
            # ì²« ë²ˆì§¸ ìº”ë“¤: ì–‘ë´‰
            first_bullish = candle1['close'] > candle1['open']
            
            # ë‘ ë²ˆì§¸ ìº”ë“¤: ìŒë´‰ì´ê³  ì²« ë²ˆì§¸ ìº”ë“¤ì„ ì™„ì „íˆ í¬ìš©
            second_bearish = candle2['close'] < candle2['open']
            engulfs = (candle2['open'] > candle1['close'] and 
                      candle2['close'] < candle1['open'])
            
            return first_bullish and second_bearish and engulfs
        except:
            return False

class TrendAnalysis:
    """ì¶”ì„¸ ë¶„ì„ í´ë˜ìŠ¤"""
    
    @staticmethod
    def identify_trend(prices: List[float], period: int = 20) -> str:
        """ì¶”ì„¸ ì‹ë³„ (ìƒìŠ¹/í•˜ë½/íš¡ë³´)"""
        if len(prices) < period * 2:
            return "insufficient_data"
        
        try:
            # ìµœê·¼ ê¸°ê°„ê³¼ ì´ì „ ê¸°ê°„ì˜ í‰ê·  ë¹„êµ
            recent_avg = np.mean(prices[-period:])
            previous_avg = np.mean(prices[-(period*2):-period])
            
            change_rate = (recent_avg - previous_avg) / previous_avg
            
            if change_rate > 0.02:  # 2% ì´ìƒ ìƒìŠ¹
                return "uptrend"
            elif change_rate < -0.02:  # 2% ì´ìƒ í•˜ë½
                return "downtrend"
            else:
                return "sideways"
        except:
            return "unknown"
    
    @staticmethod
    def calculate_trend_strength(prices: List[float], period: int = 20) -> float:
        """ì¶”ì„¸ ê°•ë„ ê³„ì‚° (0~1)"""
        if len(prices) < period:
            return 0.0
        
        try:
            # ì„ í˜• íšŒê·€ë¥¼ ì´ìš©í•œ ì¶”ì„¸ ê°•ë„
            x = np.arange(len(prices[-period:]))
            y = np.array(prices[-period:])
            
            correlation = np.corrcoef(x, y)[0, 1]
            return abs(correlation) if not np.isnan(correlation) else 0.0
        except:
            return 0.0
    
    @staticmethod
    def detect_breakout(prices: List[float], resistance_level: float, support_level: float, 
                       current_price: float, volume_increase: bool = False) -> Dict[str, bool]:
        """ëŒíŒŒ íŒ¨í„´ ê°ì§€"""
        try:
            # ì €í•­ì„  ëŒíŒŒ
            resistance_breakout = current_price > resistance_level * 1.01  # 1% ë§ˆì§„
            
            # ì§€ì§€ì„  í•˜ë½
            support_breakdown = current_price < support_level * 0.99  # 1% ë§ˆì§„
            
            return {
                'resistance_breakout': resistance_breakout and volume_increase,
                'support_breakdown': support_breakdown and volume_increase,
                'breakout_confirmed': (resistance_breakout or support_breakdown) and volume_increase
            }
        except:
            return {'resistance_breakout': False, 'support_breakdown': False, 'breakout_confirmed': False}

class RiskMetrics:
    """ë¦¬ìŠ¤í¬ ì§€í‘œ ê³„ì‚° í´ë˜ìŠ¤"""
    
    @staticmethod
    def calculate_var(returns: List[float], confidence_level: float = 0.05) -> float:
        """VaR (Value at Risk) ê³„ì‚°"""
        if not returns:
            return 0.0
        
        try:
            return np.percentile(returns, confidence_level * 100)
        except:
            return 0.0
    
    @staticmethod
    def calculate_cvar(returns: List[float], confidence_level: float = 0.05) -> float:
        """CVaR (Conditional Value at Risk) ê³„ì‚°"""
        if not returns:
            return 0.0
        
        try:
            var = RiskMetrics.calculate_var(returns, confidence_level)
            tail_losses = [r for r in returns if r <= var]
            return np.mean(tail_losses) if tail_losses else 0.0
        except:
            return 0.0
    
    @staticmethod
    def calculate_sharpe_ratio(returns: List[float], risk_free_rate: float = 0.02) -> float:
        """ìƒ¤í”„ ë¹„ìœ¨ ê³„ì‚°"""
        if not returns:
            return 0.0
        
        try:
            excess_returns = np.array(returns) - risk_free_rate / 252  # ì¼ê°„ ë¬´ìœ„í—˜ ìˆ˜ìµë¥ 
            return np.mean(excess_returns) / np.std(excess_returns) * np.sqrt(252) if np.std(excess_returns) != 0 else 0.0
        except:
            return 0.0
    
    @staticmethod
    def calculate_sortino_ratio(returns: List[float], risk_free_rate: float = 0.02) -> float:
        """ì†Œë¥´í‹°ë…¸ ë¹„ìœ¨ ê³„ì‚°"""
        if not returns:
            return 0.0
        
        try:
            excess_returns = np.array(returns) - risk_free_rate / 252
            downside_returns = excess_returns[excess_returns < 0]
            downside_std = np.std(downside_returns) if len(downside_returns) > 0 else 0.0
            
            return np.mean(excess_returns) / downside_std * np.sqrt(252) if downside_std != 0 else 0.0
        except:
            return 0.0
    
    @staticmethod
    def calculate_max_drawdown(prices: List[float]) -> Dict[str, float]:
        """ìµœëŒ€ ë‚™í­ ê³„ì‚°"""
        if not prices:
            return {'max_drawdown': 0.0, 'max_drawdown_pct': 0.0}
        
        try:
            peak = prices[0]
            max_drawdown = 0.0
            max_drawdown_pct = 0.0
            
            for price in prices:
                if price > peak:
                    peak = price
                else:
                    drawdown = peak - price
                    drawdown_pct = drawdown / peak
                    
                    if drawdown > max_drawdown:
                        max_drawdown = drawdown
                        max_drawdown_pct = drawdown_pct
            
            return {
                'max_drawdown': max_drawdown,
                'max_drawdown_pct': max_drawdown_pct
            }
        # except:
        #     return {'max_drawdown': 0.0, 'max_drawdown_pct': 0.0} 
        #     middle = df.rolling(window=period).mean()
            
        #     # í‘œì¤€í¸ì°¨
        #     std = df.rolling(window=period).std()
            
        #     # ìƒë‹¨ì„ , í•˜ë‹¨ì„ 
        #     upper = middle + (std * std_dev)
        #     lower = middle - (std * std_dev)
            
        #     return {
        #         'upper': upper.dropna().tolist(),
        #         'middle': middle.dropna().tolist(),
        #         'lower': lower.dropna().tolist()
        #     }
        except Exception as e:
            logger.error(f"ë³¼ë¦°ì €ë°´ë“œ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return None
    
    @staticmethod
    def rsi(prices: List[float], period: int = 14) -> List[float]:
        """RSI (Relative Strength Index) ê³„ì‚°"""
        if len(prices) < period + 1:
            return []
        
        try:
            df = pd.Series(prices)
            
            # ê°€ê²© ë³€í™” ê³„ì‚°
            delta = df.diff()
            
            # ìƒìŠ¹ë¶„ê³¼ í•˜ë½ë¶„ ë¶„ë¦¬
            gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
            
            # RS ê³„ì‚°
            rs = gain / loss
            
            # RSI ê³„ì‚°
            rsi = 100 - (100 / (1 + rs))
            
            return rsi.dropna().tolist()
        except Exception as e:
            logger.error(f"RSI ê³„ì‚° ì˜¤ë¥˜: {e}")
            return []
    
    @staticmethod
    def macd(prices: List[float], fast_period: int = 12, slow_period: int = 26, signal_period: int = 9) -> Optional[Dict[str, List[float]]]:
        """MACD (Moving Average Convergence Divergence) ê³„ì‚°"""
        if len(prices) < slow_period:
            return None
        
        try:
            df = pd.Series(prices)
            
            # ë¹ ë¥¸ EMAì™€ ëŠë¦° EMA ê³„ì‚°
            ema_fast = df.ewm(span=fast_period).mean()
            ema_slow = df.ewm(span=slow_period).mean()
            
            # MACD ë¼ì¸
            macd_line = ema_fast - ema_slow
            
            # ì‹ í˜¸ì„  (MACDì˜ EMA)
            signal_line = macd_line.ewm(span=signal_period).mean()
            
            # íˆìŠ¤í† ê·¸ë¨
            histogram = macd_line - signal_line
            
            return {
                'macd': macd_line.dropna().tolist(),
                'signal': signal_line.dropna().tolist(),
                'histogram': histogram.dropna().tolist()
            }
        except Exception as e:
            logger.error(f"MACD ê³„ì‚° ì˜¤ë¥˜: {e}")
            return None
    
    @staticmethod
    def stochastic(high_prices: List[float], low_prices: List[float], close_prices: List[float], 
                  k_period: int = 14, d_period: int = 3) -> Optional[Dict[str, List[float]]]:
        """ìŠ¤í† ìºìŠ¤í‹± ì˜¤ì‹¤ë ˆì´í„° ê³„ì‚°"""
        if len(high_prices) < k_period or len(low_prices) < k_period or len(close_prices) < k_period:
            return None
        
        try:
            high_df = pd.Series(high_prices)
            low_df = pd.Series(low_prices)
            close_df = pd.Series(close_prices)
            
            # %K ê³„ì‚°
            lowest_low = low_df.rolling(window=k_period).min()
            highest_high = high_df.rolling(window=k_period).max()
            
            k_percent = 100 * ((close_df - lowest_low) / (highest_high - lowest_low))
            
            # %D ê³„ì‚° (%Kì˜ ì´ë™í‰ê· )
            d_percent = k_percent.rolling(window=d_period).mean()
            
            return {
                'k': k_percent.dropna().tolist(),
                'd': d_percent.dropna().tolist()
            }
        except Exception as e:
            logger.error(f"ìŠ¤í† ìºìŠ¤í‹± ê³„ì‚° ì˜¤ë¥˜: {e}")
            return None
    
    @staticmethod
    def williams_r(high_prices: List[float], low_prices: List[float], close_prices: List[float], 
                  period: int = 14) -> List[float]:
        """ìœŒë¦¬ì—„ìŠ¤ %R ê³„ì‚°"""
        if len(high_prices) < period:
            return []
        
        try:
            high_df = pd.Series(high_prices)
            low_df = pd.Series(low_prices)
            close_df = pd.Series(close_prices)
            
            highest_high = high_df.rolling(window=period).max()
            lowest_low = low_df.rolling(window=period).min()
            
            williams_r = -100 * ((highest_high - close_df) / (highest_high - lowest_low))
            
            return williams_r.dropna().tolist()
        except Exception as e:
            logger.error(f"ìœŒë¦¬ì—„ìŠ¤ %R ê³„ì‚° ì˜¤ë¥˜: {e}")
            return []
    
    @staticmethod
    def cci(high_prices: List[float], low_prices: List[float], close_prices: List[float], 
            period: int = 20) -> List[float]:
        """CCI (Commodity Channel Index) ê³„ì‚°"""
        if len(high_prices) < period:
            return []
        
        try:
            high_df = pd.Series(high_prices)
            low_df = pd.Series(low_prices)
            close_df = pd.Series(close_prices)
            
            # ì¼ë°˜ì ì¸ ê°€ê²© (Typical Price)
            tp = (high_df + low_df + close_df) / 3
            
            # ì´ë™í‰ê· 
            ma_tp = tp.rolling(window=period).mean()
            
            # í‰ê· ì ˆëŒ€í¸ì°¨
            mad = tp.rolling(window=period).apply(lambda x: np.abs(x - x.mean()).mean())
            
            # CCI ê³„ì‚°
            cci = (tp - ma_tp) / (0.015 * mad)
            
            return cci.dropna().tolist()
        except Exception as e:
            logger.error(f"CCI ê³„ì‚° ì˜¤ë¥˜: {e}")
            return []
    
    @staticmethod
    def atr(high_prices: List[float], low_prices: List[float], close_prices: List[float], 
            period: int = 14) -> List[float]:
        """ATR (Average True Range) ê³„ì‚°"""
        if len(high_prices) < period + 1:
            return []
        
        try:
            high_df = pd.Series(high_prices)
            low_df = pd.Series(low_prices)
            close_df = pd.Series(close_prices)
            
            # True Range ê³„ì‚°
            prev_close = close_df.shift(1)
            
            tr1 = high_df - low_df
            tr2 = abs(high_df - prev_close)
            tr3 = abs(low_df - prev_close)
            
            true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
            
            # ATR ê³„ì‚° (True Rangeì˜ ì´ë™í‰ê· )
            atr = true_range.rolling(window=period).mean()
            
            return atr.dropna().tolist()
        except Exception as e:
            logger.error(f"ATR ê³„ì‚° ì˜¤ë¥˜: {e}")
            return []
    
    @staticmethod
    def obv(close_prices: List[float], volumes: List[int]) -> List[float]:
        """OBV (On-Balance Volume) ê³„ì‚°"""
        if len(close_prices) != len(volumes) or len(close_prices) < 2:
            return []
        
        try:
            close_df = pd.Series(close_prices)
            volume_df = pd.Series(volumes)
            
            # ê°€ê²© ë³€í™” ë°©í–¥
            price_change = close_df.diff()
            
            # OBV ê³„ì‚°
            obv_values = []
            obv = 0
            
            for i, (price_diff, volume) in enumerate(zip(price_change, volume_df)):
                if i == 0:  # ì²« ë²ˆì§¸ ê°’
                    obv = volume
                elif price_diff > 0:  # ê°€ê²© ìƒìŠ¹
                    obv += volume
                elif price_diff < 0:  # ê°€ê²© í•˜ë½
                    obv -= volume
                # ê°€ê²© ë³€í™” ì—†ìœ¼ë©´ OBV ë³€í™” ì—†ìŒ
                
                obv_values.append(obv)
            
            return obv_values
        except Exception as e:
            logger.error(f"OBV ê³„ì‚° ì˜¤ë¥˜: {e}")
            return []
    
    @staticmethod
    def fibonacci_retracement(high_price: float, low_price: float) -> Dict[str, float]:
        """í”¼ë³´ë‚˜ì¹˜ ë˜ëŒë¦¼ ê³„ì‚°"""
        try:
            diff = high_price - low_price
            
            return {
                '0%': high_price,
                '23.6%': high_price - (diff * 0.236),
                '38.2%': high_price - (diff * 0.382),
                '50%': high_price - (diff * 0.5),
                '61.8%': high_price - (diff * 0.618),
                '100%': low_price
            }
        except Exception as e:
            logger.error(f"í”¼ë³´ë‚˜ì¹˜ ë˜ëŒë¦¼ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return {}
    
    @staticmethod
    def pivot_points(high_price: float, low_price: float, close_price: float) -> Dict[str, float]:
        """í”¼ë²— í¬ì¸íŠ¸ ê³„ì‚°"""
        try:
            pivot = (high_price + low_price + close_price) / 3
            
            return {
                'pivot': pivot,
                'r1': 2 * pivot - low_price,
                'r2': pivot + (high_price - low_price),
                'r3': high_price + 2 * (pivot - low_price),
                's1': 2 * pivot - high_price,
                's2': pivot - (high_price - low_price),
                's3': low_price - 2 * (high_price - pivot)
            }
        except Exception as e:
            logger.error(f"í”¼ë²— í¬ì¸íŠ¸ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return {}
    
    @staticmethod
    def support_resistance(prices: List[float], window: int = 20, min_touches: int = 2) -> Dict[str, List[float]]:
        """ì§€ì§€ì„ /ì €í•­ì„  ê³„ì‚°"""
        if len(prices) < window * 2:
            return {'support': [], 'resistance': []}
        
        try:
            df = pd.Series(prices)
            
            # êµ­ì§€ì  ê³ ì ê³¼ ì €ì  ì°¾ê¸°
            highs = []
            lows = []
            
            for i in range(window, len(prices) - window):
                # ê³ ì  ì²´í¬
                if all(prices[i] >= prices[j] for j in range(i - window, i + window + 1) if j != i):
                    highs.append((i, prices[i]))
                
                # ì €ì  ì²´í¬
                if all(prices[i] <= prices[j] for j in range(i - window, i + window + 1) if j != i):
                    lows.append((i, prices[i]))
            
            # ì €í•­ì„ ê³¼ ì§€ì§€ì„  ë ˆë²¨ ê·¸ë£¹í™”
            resistance_levels = []
            support_levels = []
            
            # ë¹„ìŠ·í•œ ê°€ê²©ëŒ€ì˜ ê³ ì ë“¤ì„ ê·¸ë£¹í™”
            tolerance = 0.02  # 2% í—ˆìš©ì˜¤ì°¨
            
            for _, price in highs:
                found_group = False
                for level in resistance_levels:
                    if abs(price - level) / level < tolerance:
                        found_group = True
                        break
                if not found_group:
                    resistance_levels.append(price)
            
            # ë¹„ìŠ·í•œ ê°€ê²©ëŒ€ì˜ ì €ì ë“¤ì„ ê·¸ë£¹í™”
            for _, price in lows:
                found_group = False
                for level in support_levels:
                    if abs(price - level) / level < tolerance:
                        found_group = True
                        break
                if not found_group:
                    support_levels.append(price)
            
            return {
                'support': sorted(support_levels),
                'resistance': sorted(resistance_levels, reverse=True)
            }
        except Exception as e:
            logger.error(f"ì§€ì§€/ì €í•­ì„  ê³„ì‚° ì˜¤ë¥˜: {e}")
            return {'support': [], 'resistance': []}
    
    @staticmethod
    def calculate_volatility(prices: List[float], period: int = 20) -> float:
        """ë³€ë™ì„± ê³„ì‚° (í‘œì¤€í¸ì°¨ ê¸°ë°˜)"""
        if len(prices) < period:
            return 0.0
        
        try:
            df = pd.Series(prices)
            returns = df.pct_change().dropna()
            volatility = returns.rolling(window=period).std().iloc[-1]
            
            # ì—°ìœ¨í™” (ì¼ê°„ ë³€ë™ì„±ì„ ì—°ê°„ìœ¼ë¡œ ë³€í™˜)
            return volatility * np.sqrt(252)  # 252 = ì—°ê°„ ê±°ë˜ì¼ìˆ˜
        except Exception as e:
            logger.error(f"ë³€ë™ì„± ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
    
    @staticmethod
    def calculate_correlation(prices1: List[float], prices2: List[float], period: int = 20) -> float:
        """ë‘ ìì‚°ê°„ ìƒê´€ê³„ìˆ˜ ê³„ì‚°"""
        if len(prices1) < period or len(prices2) < period or len(prices1) != len(prices2):
            return 0.0
        
        try:
            df1 = pd.Series(prices1)
            df2 = pd.Series(prices2)
            
            returns1 = df1.pct_change().dropna()
            returns2 = df2.pct_change().dropna()
            
            correlation = returns1.rolling(window=period).corr(returns2).iloc[-1]
            
            return correlation if not np.isnan(correlation) else 0.0
        except Exception as e:
            logger.error(f"ìƒê´€ê³„ìˆ˜ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
        
    # @staticmethod
    #     def ichimoku_cloud(high_prices: List[float], low_prices: List[float], close_prices: List[float], tenkan_period: int = 9, kijun_period: int = 26, senkou_span_b_period: int = 52) -> Optional[Dict[str, List[float]]]:
    #         """ì¼ëª©ê· í˜•í‘œ ê³„ì‚°"""
    #         if len(high_prices) < senkou_span_b_period:
    #             return None
            
    #         try:
    #             high_df = pd.Series(high_prices)
    #             low_df = pd.Series(low_prices)
    #             close_df = pd.Series(close_prices)
                
    #             # ì „í™˜ì„  (Tenkan-sen)
    #             tenkan_high = high_df.rolling(window=tenkan_period).max()
    #             tenkan_low = low_df.rolling(window=tenkan_period).min()
    #             tenkan_sen = (tenkan_high + tenkan_low) / 2
                
    #             # ê¸°ì¤€ì„  (Kijun-sen)
    #             kijun_high = high_df.rolling(window=kijun_period).max()
    #             kijun_low = low_df.rolling(window=kijun_period).min()
    #             kijun_sen = (kijun_high + kijun_low) / 2
                
    #             # ì„ í–‰ìŠ¤íŒ¬ A (Senkou Span A)
    #             senkou_span_a = ((tenkan_sen + kijun_sen) / 2).shift(kijun_period)
                
    #             # ì„ í–‰ìŠ¤íŒ¬ B (Senkou Span B)
    #             senkou_high = high_df.rolling(window=senkou_span_b_period).max()
    #             senkou_low = low_df.rolling(window=senkou_span_b_period).min()
    #             senkou_span_b = ((senkou_high + senkou_low) / 2).shift(kijun_period)
                
    #             # í›„í–‰ìŠ¤íŒ¬ (Chikou Span)
    #             chikou_span = close_df.shift(-kijun_period)
                
    #             return {
    #                 'tenkan_sen': tenkan_sen.dropna().tolist(),
    #                 'kijun_sen': kijun_sen.dropna().tolist(),
    #                 'senkou_span_a': senkou_span_a.dropna().tolist(),
    #                 'senkou_span_b': senkou_span_b.dropna().tolist(),
    #                 'chikou_span': chikou_span.dropna().tolist()
    #             }
    #         except Exception as e:
    #             logger.error(f"ì¼ëª©ê· í˜•í‘œ ê³„ì‚° ì˜¤ë¥˜: {e}")
    #             return None

class PatternRecognition:
    """ìº”ë“¤ íŒ¨í„´ ì¸ì‹ í´ë˜ìŠ¤"""
    
    @staticmethod
    def is_doji(open_price: float, high_price: float, low_price: float, close_price: float, threshold: float = 0.1) -> bool:
        """ë„ì§€ íŒ¨í„´ ì¸ì‹"""
        try:
            body = abs(close_price - open_price)
            range_price = high_price - low_price
            
            if range_price == 0:
                return False
                
            body_ratio = body / range_price
            return body_ratio <= threshold
        except:
            return False
    
    @staticmethod
    def is_hammer(open_price: float, high_price: float, low_price: float, close_price: float) -> bool:
        """í•´ë¨¸ íŒ¨í„´ ì¸ì‹"""
        try:
            body = abs(close_price - open_price)
            upper_shadow = high_price - max(open_price, close_price)
            lower_shadow = min(open_price, close_price) - low_price
            
            # í•´ë¨¸ ì¡°ê±´: ì§§ì€ ëª¸í†µ, ê¸´ ì•„ë˜ê¼¬ë¦¬, ì§§ì€ ìœ„ê¼¬ë¦¬
            return (lower_shadow >= 2 * body and 
                   upper_shadow <= body * 0.5 and
                   body > 0)
        except:
            return False
    
    @staticmethod
    def is_shooting_star(open_price: float, high_price: float, low_price: float, close_price: float) -> bool:
        """ìœ ì„± íŒ¨í„´ ì¸ì‹"""
        try:
            body = abs(close_price - open_price)
            upper_shadow = high_price - max(open_price, close_price)
            lower_shadow = min(open_price, close_price) - low_price
            
            # ìœ ì„± ì¡°ê±´: ì§§ì€ ëª¸í†µ, ê¸´ ìœ„ê¼¬ë¦¬, ì§§ì€ ì•„ë˜ê¼¬ë¦¬
            return (upper_shadow >= 2 * body and 
                   lower_shadow <= body * 0.5 and
                   body > 0)
        except:
            return False
    
    @staticmethod
    def is_engulfing_bullish(candle1: Dict[str, float], candle2: Dict[str, float]) -> bool:
        """ê°•ì„¸ í¬ìš©ì„  íŒ¨í„´ ì¸ì‹"""
        try:
            # ì²« ë²ˆì§¸ ìº”ë“¤: ìŒë´‰
            first_bearish = candle1['close'] < candle1['open']
            
            # ë‘ ë²ˆì§¸ ìº”ë“¤: ì–‘ë´‰ì´ê³  ì²« ë²ˆì§¸ ìº”ë“¤ì„ ì™„ì „íˆ í¬ìš©
            second_bullish = candle2['close'] > candle2['open']
            engulfs = (candle2['open'] < candle1['close'] and 
                      candle2['close'] > candle1['open'])
            
            return first_bearish and second_bullish and engulfs
        except:
            return False
    
    @staticmethod
    def is_engulfing_bearish(candle1: Dict[str, float], candle2: Dict[str, float]) -> bool:
        """ì•½ì„¸ í¬ìš©ì„  íŒ¨í„´ ì¸ì‹"""
        try:
            # ì²« ë²ˆì§¸ ìº”ë“¤: ì–‘ë´‰
            first_bullish = candle1['close'] > candle1['open']
            
            # ë‘ ë²ˆì§¸ ìº”ë“¤: ìŒë´‰ì´ê³  ì²« ë²ˆì§¸ ìº”ë“¤ì„ ì™„ì „íˆ í¬ìš©
            second_bearish = candle2['close'] < candle2['open']
            engulfs = (candle2['open'] > candle1['close'] and 
                      candle2['close'] < candle1['open'])
            
            return first_bullish and second_bearish and engulfs
        except:
            return False

class TrendAnalysis:
    """ì¶”ì„¸ ë¶„ì„ í´ë˜ìŠ¤"""
    
    @staticmethod
    def identify_trend(prices: List[float], period: int = 20) -> str:
        """ì¶”ì„¸ ì‹ë³„ (ìƒìŠ¹/í•˜ë½/íš¡ë³´)"""
        if len(prices) < period * 2:
            return "insufficient_data"
        
        try:
            # ìµœê·¼ ê¸°ê°„ê³¼ ì´ì „ ê¸°ê°„ì˜ í‰ê·  ë¹„êµ
            recent_avg = np.mean(prices[-period:])
            previous_avg = np.mean(prices[-(period*2):-period])
            
            change_rate = (recent_avg - previous_avg) / previous_avg
            
            if change_rate > 0.02:  # 2% ì´ìƒ ìƒìŠ¹
                return "uptrend"
            elif change_rate < -0.02:  # 2% ì´ìƒ í•˜ë½
                return "downtrend"
            else:
                return "sideways"
        except:
            return "unknown"
    
    @staticmethod
    def calculate_trend_strength(prices: List[float], period: int = 20) -> float:
        """ì¶”ì„¸ ê°•ë„ ê³„ì‚° (0~1)"""
        if len(prices) < period:
            return 0.0
        
        try:
            # ì„ í˜• íšŒê·€ë¥¼ ì´ìš©í•œ ì¶”ì„¸ ê°•ë„
            x = np.arange(len(prices[-period:]))
            y = np.array(prices[-period:])
            
            correlation = np.corrcoef(x, y)[0, 1]
            return abs(correlation) if not np.isnan(correlation) else 0.0
        except:
            return 0.0
    
    @staticmethod
    def detect_breakout(prices: List[float], resistance_level: float, support_level: float, 
                       current_price: float, volume_increase: bool = False) -> Dict[str, bool]:
        """ëŒíŒŒ íŒ¨í„´ ê°ì§€"""
        try:
            # ì €í•­ì„  ëŒíŒŒ
            resistance_breakout = current_price > resistance_level * 1.01  # 1% ë§ˆì§„
            
            # ì§€ì§€ì„  í•˜ë½
            support_breakdown = current_price < support_level * 0.99  # 1% ë§ˆì§„
            
            return {
                'resistance_breakout': resistance_breakout and volume_increase,
                'support_breakdown': support_breakdown and volume_increase,
                'breakout_confirmed': (resistance_breakout or support_breakdown) and volume_increase
            }
        except:
            return {'resistance_breakout': False, 'support_breakdown': False, 'breakout_confirmed': False}

class RiskMetrics:
    """ë¦¬ìŠ¤í¬ ì§€í‘œ ê³„ì‚° í´ë˜ìŠ¤"""
    
    @staticmethod
    def calculate_var(returns: List[float], confidence_level: float = 0.05) -> float:
        """VaR (Value at Risk) ê³„ì‚°"""
        if not returns:
            return 0.0
        
        try:
            return np.percentile(returns, confidence_level * 100)
        except:
            return 0.0
    
    @staticmethod
    def calculate_cvar(returns: List[float], confidence_level: float = 0.05) -> float:
        """CVaR (Conditional Value at Risk) ê³„ì‚°"""
        if not returns:
            return 0.0
        
        try:
            var = RiskMetrics.calculate_var(returns, confidence_level)
            tail_losses = [r for r in returns if r <= var]
            return np.mean(tail_losses) if tail_losses else 0.0
        except:
            return 0.0
    
    @staticmethod
    def calculate_sharpe_ratio(returns: List[float], risk_free_rate: float = 0.02) -> float:
        """ìƒ¤í”„ ë¹„ìœ¨ ê³„ì‚°"""
        if not returns:
            return 0.0
        
        try:
            excess_returns = np.array(returns) - risk_free_rate / 252  # ì¼ê°„ ë¬´ìœ„í—˜ ìˆ˜ìµë¥ 
            return np.mean(excess_returns) / np.std(excess_returns) * np.sqrt(252) if np.std(excess_returns) != 0 else 0.0
        except:
            return 0.0
    
    @staticmethod
    def calculate_sortino_ratio(returns: List[float], risk_free_rate: float = 0.02) -> float:
        """ì†Œë¥´í‹°ë…¸ ë¹„ìœ¨ ê³„ì‚°"""
        if not returns:
            return 0.0
        
        try:
            excess_returns = np.array(returns) - risk_free_rate / 252
            downside_returns = excess_returns[excess_returns < 0]
            downside_std = np.std(downside_returns) if len(downside_returns) > 0 else 0.0
            
            return np.mean(excess_returns) / downside_std * np.sqrt(252) if downside_std != 0 else 0.0
        except:
            return 0.0
    
    @staticmethod
    def calculate_max_drawdown(prices: List[float]) -> Dict[str, float]:
        """ìµœëŒ€ ë‚™í­ ê³„ì‚°"""
        if not prices:
            return {'max_drawdown': 0.0, 'max_drawdown_pct': 0.0}
        
        try:
            peak = prices[0]
            max_drawdown = 0.0
            max_drawdown_pct = 0.0
            
            for price in prices:
                if price > peak:
                    peak = price
                else:
                    drawdown = peak - price
                    drawdown_pct = drawdown / peak
                    
                    if drawdown > max_drawdown:
                        max_drawdown = drawdown
                        max_drawdown_pct = drawdown_pct
            
            return {
                'max_drawdown': max_drawdown,
                'max_drawdown_pct': max_drawdown_pct
            }
        except:
            return {'max_drawdown': 0.0, 'max_drawdown_pct': 0.0}


==================================================
File: C:\Aproject\test\quant_actual\backend\trading\risk_manager.py
==================================================
# file: backend/trading/risk_manager.py

import logging
from typing import Dict, List, Any, Optional
from datetime import datetime, date, time
import json

from models import TradingSignal, RiskMetrics
from database import get_db_session
from utils.config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

class RiskManager:
    """ë¦¬ìŠ¤í¬ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self):
        # ê¸°ë³¸ ë¦¬ìŠ¤í¬ í•œë„ ì„¤ì •
        self.daily_loss_limit = -0.02  # -2%
        self.position_size_limit = 0.05  # 5%
        self.max_positions = 10
        self.max_single_stock_weight = 0.15  # 15%
        self.max_sector_weight = 0.3  # 30%
        
        # ë™ì  ë¦¬ìŠ¤í¬ ì¶”ì 
        self.current_daily_loss = 0.0
        self.current_positions_count = 0
        self.sector_exposure = {}
        
        # ë¦¬ìŠ¤í¬ ìƒíƒœ
        self.risk_level = "LOW"  # LOW, MEDIUM, HIGH, CRITICAL
        self.trading_allowed = True
        
    async def validate_signal(self, signal: TradingSignal, current_positions: Dict[str, Any]) -> bool:
        """íŠ¸ë ˆì´ë”© ì‹ í˜¸ì˜ ë¦¬ìŠ¤í¬ ê²€ì¦"""
        try:
            # 1. ê¸°ë³¸ ë¦¬ìŠ¤í¬ ì²´í¬
            if not self.trading_allowed:
                logger.warning("íŠ¸ë ˆì´ë”©ì´ ë¹„í™œì„±í™”ë¨ - ì‹ í˜¸ ê±°ë¶€")
                return False
            
            # 2. ì¼ì¼ ì†ì‹¤ í•œë„ ì²´í¬
            if not await self.check_daily_loss_limit():
                logger.warning("ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼ - ì‹ í˜¸ ê±°ë¶€")
                return False
            
            # 3. í¬ì§€ì…˜ ìˆ˜ í•œë„ ì²´í¬
            if signal.signal_type == "buy" and not self.check_position_count_limit(current_positions):
                logger.warning("ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ì´ˆê³¼ - ë§¤ìˆ˜ ì‹ í˜¸ ê±°ë¶€")
                return False
            
            # 4. í¬ì§€ì…˜ í¬ê¸° í•œë„ ì²´í¬
            if not await self.check_position_size_limit(signal):
                logger.warning("í¬ì§€ì…˜ í¬ê¸° í•œë„ ì´ˆê³¼ - ì‹ í˜¸ ê±°ë¶€")
                return False
            
            # 5. ì¢…ëª©ë³„ ì§‘ì¤‘ë„ ì²´í¬
            if not await self.check_concentration_risk(signal, current_positions):
                logger.warning("ì§‘ì¤‘ë„ ë¦¬ìŠ¤í¬ - ì‹ í˜¸ ê±°ë¶€")
                return False
            
            # 6. ì‹œì¥ ì‹œê°„ ì²´í¬
            if not self.check_market_hours():
                logger.warning("ì‹œì¥ ì‹œê°„ ì™¸ - ì‹ í˜¸ ê±°ë¶€")
                return False
            
            # 7. ë³€ë™ì„± ì²´í¬
            if not await self.check_volatility_risk(signal):
                logger.warning("ë³€ë™ì„± ë¦¬ìŠ¤í¬ ë†’ìŒ - ì‹ í˜¸ ê±°ë¶€")
                return False
            
            logger.info(f"ë¦¬ìŠ¤í¬ ê²€ì¦ í†µê³¼: {signal.stock_code} {signal.signal_type}")
            return True
            
        except Exception as e:
            logger.error(f"ë¦¬ìŠ¤í¬ ê²€ì¦ ì˜¤ë¥˜: {e}")
            return False
    
    async def check_daily_loss_limit(self) -> bool:
        """ì¼ì¼ ì†ì‹¤ í•œë„ ì²´í¬"""
        try:
            # ì˜¤ëŠ˜ì˜ ì‹¤í˜„ ì†ìµ ì¡°íšŒ
            today_pnl = await self.get_today_pnl()
            self.current_daily_loss = today_pnl
            
            # ì†ì‹¤ í•œë„ ë¹„êµ
            if today_pnl < self.daily_loss_limit:
                self.risk_level = "CRITICAL"
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"ì¼ì¼ ì†ì‹¤ í•œë„ ì²´í¬ ì˜¤ë¥˜: {e}")
            return True  # ì˜¤ë¥˜ ì‹œ ì•ˆì „í•˜ê²Œ í—ˆìš©
    
    def check_position_count_limit(self, current_positions: Dict[str, Any]) -> bool:
        """í¬ì§€ì…˜ ìˆ˜ í•œë„ ì²´í¬"""
        try:
            active_positions = len([pos for pos in current_positions.values() if pos['quantity'] > 0])
            self.current_positions_count = active_positions
            
            return active_positions < self.max_positions
            
        except Exception as e:
            logger.error(f"í¬ì§€ì…˜ ìˆ˜ ì²´í¬ ì˜¤ë¥˜: {e}")
            return True
    
    async def check_position_size_limit(self, signal: TradingSignal) -> bool:
        """í¬ì§€ì…˜ í¬ê¸° í•œë„ ì²´í¬"""
        try:
            # í˜„ì¬ í¬íŠ¸í´ë¦¬ì˜¤ ì´ ê°€ì¹˜ ì¡°íšŒ
            total_portfolio_value = await self.get_total_portfolio_value()
            
            # ì‹ í˜¸ì˜ íˆ¬ì ê¸ˆì•¡ ê³„ì‚°
            signal_value = signal.quantity * signal.price
            
            # í¬íŠ¸í´ë¦¬ì˜¤ ëŒ€ë¹„ ë¹„ì¤‘ ê³„ì‚°
            position_weight = signal_value / total_portfolio_value
            
            return position_weight <= self.position_size_limit
            
        except Exception as e:
            logger.error(f"í¬ì§€ì…˜ í¬ê¸° ì²´í¬ ì˜¤ë¥˜: {e}")
            return True
    
    async def check_concentration_risk(self, signal: TradingSignal, current_positions: Dict[str, Any]) -> bool:
        """ì§‘ì¤‘ë„ ë¦¬ìŠ¤í¬ ì²´í¬"""
        try:
            if signal.signal_type != "buy":
                return True  # ë§¤ë„ëŠ” ì§‘ì¤‘ë„ ê°ì†Œ
            
            # ì´ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜
            total_value = await self.get_total_portfolio_value()
            
            # ë™ì¼ ì¢…ëª© ì§‘ì¤‘ë„ ì²´í¬
            current_stock_value = 0
            for pos in current_positions.values():
                if pos['stock_code'] == signal.stock_code:
                    current_stock_value += pos['quantity'] * pos['current_price']
            
            new_investment = signal.quantity * signal.price
            total_stock_value = current_stock_value + new_investment
            stock_weight = total_stock_value / total_value
            
            if stock_weight > self.max_single_stock_weight:
                logger.warning(f"ì¢…ëª© ì§‘ì¤‘ë„ ì´ˆê³¼: {signal.stock_code} {stock_weight:.1%}")
                return False
            
            # ì„¹í„° ì§‘ì¤‘ë„ ì²´í¬ (ì‹¤ì œë¡œëŠ” ì¢…ëª©-ì„¹í„° ë§¤í•‘ ë°ì´í„° í•„ìš”)
            sector = await self.get_stock_sector(signal.stock_code)
            if sector:
                sector_weight = await self.calculate_sector_weight(sector, current_positions, signal)
                if sector_weight > self.max_sector_weight:
                    logger.warning(f"ì„¹í„° ì§‘ì¤‘ë„ ì´ˆê³¼: {sector} {sector_weight:.1%}")
                    return False
            
            return True
            
        except Exception as e:
            logger.error(f"ì§‘ì¤‘ë„ ë¦¬ìŠ¤í¬ ì²´í¬ ì˜¤ë¥˜: {e}")
            return True
    
    def check_market_hours(self) -> bool:
        """ì‹œì¥ ì‹œê°„ ì²´í¬"""
        try:
            now = datetime.now()
            
            # ì£¼ë§ ì²´í¬
            if now.weekday() >= 5:  # í† ìš”ì¼(5), ì¼ìš”ì¼(6)
                return False
            
            # ì‹œì¥ ì‹œê°„ ì²´í¬ (9:00 - 15:30)
            market_open = time(9, 0)
            market_close = time(15, 30)
            current_time = now.time()
            
            return market_open <= current_time <= market_close
            
        except Exception as e:
            logger.error(f"ì‹œì¥ ì‹œê°„ ì²´í¬ ì˜¤ë¥˜: {e}")
            return False
    
    async def check_volatility_risk(self, signal: TradingSignal) -> bool:
        """ë³€ë™ì„± ë¦¬ìŠ¤í¬ ì²´í¬"""
        try:
            # ì¢…ëª©ì˜ ìµœê·¼ ë³€ë™ì„± ì¡°íšŒ
            volatility = await self.get_stock_volatility(signal.stock_code)
            
            # ë†’ì€ ë³€ë™ì„± ì¢…ëª©ì˜ ê²½ìš° í¬ì§€ì…˜ í¬ê¸° ì œí•œ
            high_volatility_threshold = 0.4  # 40% ì—° ë³€ë™ì„±
            
            if volatility > high_volatility_threshold:
                # ì‹ í˜¸ì˜ ì‹ ë¢°ë„ê°€ ë†’ì€ ê²½ìš°ë§Œ í—ˆìš©
                return signal.confidence > 0.8
            
            return True
            
        except Exception as e:
            logger.error(f"ë³€ë™ì„± ë¦¬ìŠ¤í¬ ì²´í¬ ì˜¤ë¥˜: {e}")
            return True
    
    async def check_daily_limits(self, current_pnl: float, current_positions: Dict[str, Any]) -> Dict[str, Any]:
        """ì¼ì¼ ë¦¬ìŠ¤í¬ í•œë„ ì²´í¬"""
        try:
            risk_status = {
                'is_safe': True,
                'risk_level': 'LOW',
                'message': '',
                'severity': 'normal'
            }
            
            # 1. ì¼ì¼ ì†ì‹¤ ì²´í¬
            loss_ratio = current_pnl / await self.get_total_portfolio_value()
            
            if loss_ratio <= self.daily_loss_limit:
                risk_status.update({
                    'is_safe': False,
                    'risk_level': 'CRITICAL',
                    'message': f'ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼: {loss_ratio:.2%}',
                    'severity': 'critical'
                })
            elif loss_ratio <= self.daily_loss_limit * 0.7:
                risk_status.update({
                    'risk_level': 'HIGH',
                    'message': f'ì¼ì¼ ì†ì‹¤ ê²½ê³ : {loss_ratio:.2%}',
                    'severity': 'high'
                })
            elif loss_ratio <= self.daily_loss_limit * 0.5:
                risk_status.update({
                    'risk_level': 'MEDIUM',
                    'message': f'ì¼ì¼ ì†ì‹¤ ì£¼ì˜: {loss_ratio:.2%}',
                    'severity': 'medium'
                })
            
            # 2. í¬ì§€ì…˜ ìˆ˜ ì²´í¬
            position_count = len([pos for pos in current_positions.values() if pos['quantity'] > 0])
            if position_count >= self.max_positions:
                risk_status.update({
                    'risk_level': 'HIGH',
                    'message': f'ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ë„ë‹¬: {position_count}',
                    'severity': 'high'
                })
            
            # 3. ì§‘ì¤‘ë„ ë¦¬ìŠ¤í¬ ì²´í¬
            concentration_risk = await self.check_portfolio_concentration(current_positions)
            if concentration_risk['high_concentration']:
                risk_status.update({
                    'risk_level': 'MEDIUM',
                    'message': concentration_risk['message'],
                    'severity': 'medium'
                })
            
            return risk_status
            
        except Exception as e:
            logger.error(f"ì¼ì¼ ë¦¬ìŠ¤í¬ ì²´í¬ ì˜¤ë¥˜: {e}")
            return {'is_safe': True, 'risk_level': 'UNKNOWN', 'message': 'Risk check failed'}
    
    async def get_current_metrics(self) -> RiskMetrics:
        """í˜„ì¬ ë¦¬ìŠ¤í¬ ì§€í‘œ ë°˜í™˜"""
        try:
            return RiskMetrics(
                daily_loss_limit=self.daily_loss_limit,
                position_size_limit=self.position_size_limit,
                max_positions=self.max_positions,
                current_daily_loss=self.current_daily_loss,
                is_safe_to_trade=self.trading_allowed
            )
        except Exception as e:
            logger.error(f"ë¦¬ìŠ¤í¬ ì§€í‘œ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return RiskMetrics()
    
    async def update_limits(self, new_limits: Dict[str, Any]):
        """ë¦¬ìŠ¤í¬ í•œë„ ì—…ë°ì´íŠ¸"""
        try:
            if 'daily_loss_limit' in new_limits:
                self.daily_loss_limit = new_limits['daily_loss_limit']
            
            if 'position_size_limit' in new_limits:
                self.position_size_limit = new_limits['position_size_limit']
            
            if 'max_positions' in new_limits:
                self.max_positions = new_limits['max_positions']
            
            if 'max_single_stock_weight' in new_limits:
                self.max_single_stock_weight = new_limits['max_single_stock_weight']
            
            if 'max_sector_weight' in new_limits:
                self.max_sector_weight = new_limits['max_sector_weight']
            
            logger.info("ë¦¬ìŠ¤í¬ í•œë„ ì—…ë°ì´íŠ¸ ì™„ë£Œ")
            
        except Exception as e:
            logger.error(f"ë¦¬ìŠ¤í¬ í•œë„ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
    
    # í—¬í¼ ë©”ì„œë“œë“¤
    async def get_today_pnl(self) -> float:
        """ì˜¤ëŠ˜ì˜ ì‹¤í˜„ ì†ìµ ì¡°íšŒ"""
        try:
            from models import Order, OrderStatus
            
            with get_db_session() as db:
                today = date.today()
                today_orders = db.query(Order)\
                    .filter(Order.fill_time >= datetime.combine(today, time.min))\
                    .filter(Order.status == OrderStatus.FILLED)\
                    .all()
                
                total_pnl = 0.0
                for order in today_orders:
                    if order.order_type == "sell":
                        # ê°„ë‹¨í•œ ì†ìµ ê³„ì‚° (ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ ê³„ì‚° í•„ìš”)
                        total_pnl += (order.fill_price - order.price) * order.fill_quantity
                
                return total_pnl
                
        except Exception as e:
            logger.error(f"ì˜¤ëŠ˜ ì†ìµ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return 0.0
    
    async def get_total_portfolio_value(self) -> float:
        """ì´ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ì¡°íšŒ"""
        try:
            from models import Portfolio
            
            with get_db_session() as db:
                latest_portfolio = db.query(Portfolio)\
                    .order_by(Portfolio.timestamp.desc())\
                    .first()
                
                return latest_portfolio.total_value if latest_portfolio else 50000000.0
                
        except Exception as e:
            logger.error(f"í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return 50000000.0  # ê¸°ë³¸ê°’
    
    async def get_stock_sector(self, stock_code: str) -> Optional[str]:
        """ì¢…ëª©ì˜ ì„¹í„° ì •ë³´ ì¡°íšŒ"""
        try:
            # ê°„ë‹¨í•œ ì„¹í„° ë§¤í•‘ (ì‹¤ì œë¡œëŠ” ë°ì´í„°ë² ì´ìŠ¤ë‚˜ APIì—ì„œ ì¡°íšŒ)
            sector_map = {
                '005930': 'Technology',  # ì‚¼ì„±ì „ì
                '000660': 'Technology',  # SKí•˜ì´ë‹‰ìŠ¤
                '035420': 'Technology',  # NAVER
                '035720': 'Technology',  # ì¹´ì¹´ì˜¤
                '051910': 'Chemical',    # LGí™”í•™
                '006400': 'Technology',  # ì‚¼ì„±SDI
                '207940': 'Biotech',     # ì‚¼ì„±ë°”ì´ì˜¤ë¡œì§ìŠ¤
                '373220': 'Battery',     # LGì—ë„ˆì§€ì†”ë£¨ì…˜
            }
            
            return sector_map.get(stock_code)
            
        except Exception as e:
            logger.error(f"ì„¹í„° ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return None
    
    async def calculate_sector_weight(self, sector: str, current_positions: Dict[str, Any], 
                                   new_signal: TradingSignal) -> float:
        """ì„¹í„°ë³„ íˆ¬ì ë¹„ì¤‘ ê³„ì‚°"""
        try:
            total_value = await self.get_total_portfolio_value()
            sector_value = 0.0
            
            # í˜„ì¬ ì„¹í„° íˆ¬ì ê¸ˆì•¡ ê³„ì‚°
            for pos in current_positions.values():
                stock_sector = await self.get_stock_sector(pos['stock_code'])
                if stock_sector == sector:
                    sector_value += pos['quantity'] * pos['current_price']
            
            # ì‹ ê·œ íˆ¬ì ê¸ˆì•¡ ì¶”ê°€
            if new_signal.signal_type == "buy":
                signal_sector = await self.get_stock_sector(new_signal.stock_code)
                if signal_sector == sector:
                    sector_value += new_signal.quantity * new_signal.price
            
            return sector_value / total_value
            
        except Exception as e:
            logger.error(f"ì„¹í„° ë¹„ì¤‘ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
    
    async def get_stock_volatility(self, stock_code: str, days: int = 30) -> float:
        """ì¢…ëª© ë³€ë™ì„± ê³„ì‚°"""
        try:
            from models import Stock, PriceHistory
            from trading.indicators import TechnicalIndicators
            
            with get_db_session() as db:
                stock = db.query(Stock).filter(Stock.code == stock_code).first()
                if not stock:
                    return 0.0
                
                # ìµœê·¼ 30ì¼ ê°€ê²© ë°ì´í„° ì¡°íšŒ
                price_records = db.query(PriceHistory)\
                    .filter(PriceHistory.stock_id == stock.id)\
                    .order_by(PriceHistory.timestamp.desc())\
                    .limit(days)\
                    .all()
                
                if len(price_records) < 10:
                    return 0.0
                
                prices = [record.price for record in reversed(price_records)]
                return TechnicalIndicators.calculate_volatility(prices, min(20, len(prices)))
                
        except Exception as e:
            logger.error(f"ë³€ë™ì„± ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
    
    async def check_portfolio_concentration(self, current_positions: Dict[str, Any]) -> Dict[str, Any]:
        """í¬íŠ¸í´ë¦¬ì˜¤ ì§‘ì¤‘ë„ ì²´í¬"""
        try:
            total_value = await self.get_total_portfolio_value()
            
            # ì¢…ëª©ë³„ ë¹„ì¤‘ ê³„ì‚°
            stock_weights = {}
            for pos in current_positions.values():
                stock_value = pos['quantity'] * pos['current_price']
                weight = stock_value / total_value
                stock_weights[pos['stock_code']] = weight
            
            # ìµœëŒ€ ì¢…ëª© ë¹„ì¤‘ ì²´í¬
            max_weight = max(stock_weights.values()) if stock_weights else 0.0
            high_concentration = max_weight > self.max_single_stock_weight
            
            result = {
                'high_concentration': high_concentration,
                'max_stock_weight': max_weight,
                'message': f'ìµœëŒ€ ì¢…ëª© ë¹„ì¤‘: {max_weight:.1%}' if high_concentration else ''
            }
            
            return result
            
        except Exception as e:
            logger.error(f"ì§‘ì¤‘ë„ ì²´í¬ ì˜¤ë¥˜: {e}")
            return {'high_concentration': False, 'max_stock_weight': 0.0, 'message': ''}
    
    def enable_trading(self):
        """íŠ¸ë ˆì´ë”© í™œì„±í™”"""
        self.trading_allowed = True
        logger.info("íŠ¸ë ˆì´ë”© í™œì„±í™”ë¨")
    
    def disable_trading(self):
        """íŠ¸ë ˆì´ë”© ë¹„í™œì„±í™”"""
        self.trading_allowed = False
        logger.warning("íŠ¸ë ˆì´ë”© ë¹„í™œì„±í™”ë¨")
    
    def set_risk_level(self, level: str):
        """ë¦¬ìŠ¤í¬ ë ˆë²¨ ì„¤ì •"""
        valid_levels = ["LOW", "MEDIUM", "HIGH", "CRITICAL"]
        if level in valid_levels:
            self.risk_level = level
            logger.info(f"ë¦¬ìŠ¤í¬ ë ˆë²¨ ì„¤ì •: {level}")
            
            # ë¦¬ìŠ¤í¬ ë ˆë²¨ì— ë”°ë¥¸ íŠ¸ë ˆì´ë”© ì œí•œ
            if level == "CRITICAL":
                self.disable_trading()
            elif level in ["LOW", "MEDIUM"]:
                self.enable_trading()

class PositionSizer:
    """í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° í´ë˜ìŠ¤"""
    
    def __init__(self, risk_manager: RiskManager):
        self.risk_manager = risk_manager
    
    def calculate_position_size(self, signal: TradingSignal, portfolio_value: float, 
                              volatility: float = 0.2) -> int:
        """í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° (Kelly Criterion ê¸°ë°˜)"""
        try:
            # ê¸°ë³¸ í¬ì§€ì…˜ í¬ê¸° (í¬íŠ¸í´ë¦¬ì˜¤ì˜ 5%)
            base_position_value = portfolio_value * self.risk_manager.position_size_limit
            
            # ì‹ í˜¸ ì‹ ë¢°ë„ì— ë”°ë¥¸ ì¡°ì •
            confidence_multiplier = min(1.5, signal.confidence * 1.5)
            
            # ë³€ë™ì„±ì— ë”°ë¥¸ ì¡°ì • (ë³€ë™ì„±ì´ ë†’ì„ìˆ˜ë¡ í¬ì§€ì…˜ í¬ê¸° ê°ì†Œ)
            volatility_multiplier = max(0.5, 1 - volatility)
            
            # ìµœì¢… í¬ì§€ì…˜ ê°’ ê³„ì‚°
            adjusted_position_value = base_position_value * confidence_multiplier * volatility_multiplier
            
            # ì£¼ì‹ ìˆ˜ëŸ‰ ê³„ì‚° (100ì£¼ ë‹¨ìœ„)
            quantity = int(adjusted_position_value / signal.price / 100) * 100
            
            return max(100, quantity)  # ìµœì†Œ 100ì£¼
            
        except Exception as e:
            logger.error(f"í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 100
    
    def calculate_stop_loss_price(self, entry_price: float, atr: float, 
                                 multiplier: float = 2.0) -> float:
        """ì†ì ˆê°€ ê³„ì‚° (ATR ê¸°ë°˜)"""
        try:
            return entry_price - (atr * multiplier)
        except:
            return entry_price * 0.95  # ê¸°ë³¸ 5% ì†ì ˆ
    
    def calculate_take_profit_price(self, entry_price: float, atr: float, 
                                  risk_reward_ratio: float = 2.0) -> float:
        """ìµì ˆê°€ ê³„ì‚°"""
        try:
            stop_loss = self.calculate_stop_loss_price(entry_price, atr)
            risk_amount = entry_price - stop_loss
            return entry_price + (risk_amount * risk_reward_ratio)
        except:
            return entry_price * 1.1  # ê¸°ë³¸ 10% ìµì ˆ

class DrawdownManager:
    """ë‚™í­ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.peak_portfolio_value = 0.0
        self.current_drawdown = 0.0
        self.max_drawdown = 0.0
        self.max_drawdown_allowed = 0.15  # 15%
        
    def update_drawdown(self, current_portfolio_value: float):
        """ë‚™í­ ì—…ë°ì´íŠ¸"""
        try:
            # ì‹ ê³ ì  ì—…ë°ì´íŠ¸
            if current_portfolio_value > self.peak_portfolio_value:
                self.peak_portfolio_value = current_portfolio_value
                self.current_drawdown = 0.0
            else:
                # í˜„ì¬ ë‚™í­ ê³„ì‚°
                self.current_drawdown = (self.peak_portfolio_value - current_portfolio_value) / self.peak_portfolio_value
                
                # ìµœëŒ€ ë‚™í­ ì—…ë°ì´íŠ¸
                if self.current_drawdown > self.max_drawdown:
                    self.max_drawdown = self.current_drawdown
            
        except Exception as e:
            logger.error(f"ë‚™í­ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
    
    def is_drawdown_acceptable(self) -> bool:
        """ë‚™í­ì´ í—ˆìš© ë²”ìœ„ ë‚´ì¸ì§€ í™•ì¸"""
        return self.current_drawdown < self.max_drawdown_allowed
    
    def get_drawdown_status(self) -> Dict[str, float]:
        """ë‚™í­ ìƒíƒœ ë°˜í™˜"""
        return {
            'current_drawdown': self.current_drawdown,
            'max_drawdown': self.max_drawdown,
            'peak_value': self.peak_portfolio_value,
            'is_acceptable': self.is_drawdown_acceptable()
        }

class CorrelationManager:
    """ìƒê´€ê´€ê³„ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.correlation_matrix = {}
        self.max_correlation = 0.7  # ìµœëŒ€ í—ˆìš© ìƒê´€ê³„ìˆ˜
    
    async def update_correlations(self, stock_codes: List[str], days: int = 60):
        """ì¢…ëª©ê°„ ìƒê´€ê´€ê³„ ì—…ë°ì´íŠ¸"""
        try:
            from models import Stock, PriceHistory
            from trading.indicators import TechnicalIndicators
            
            price_data = {}
            
            # ê° ì¢…ëª©ì˜ ê°€ê²© ë°ì´í„° ìˆ˜ì§‘
            with get_db_session() as db:
                for stock_code in stock_codes:
                    stock = db.query(Stock).filter(Stock.code == stock_code).first()
                    if stock:
                        price_records = db.query(PriceHistory)\
                            .filter(PriceHistory.stock_id == stock.id)\
                            .order_by(PriceHistory.timestamp)\
                            .limit(days)\
                            .all()
                        
                        prices = [record.price for record in price_records]
                        if len(prices) >= days // 2:
                            price_data[stock_code] = prices
            
            # ìƒê´€ê³„ìˆ˜ í–‰ë ¬ ê³„ì‚°
            for code1 in price_data:
                for code2 in price_data:
                    if code1 != code2:
                        correlation = TechnicalIndicators.calculate_correlation(
                            price_data[code1], price_data[code2]
                        )
                        self.correlation_matrix[f"{code1}_{code2}"] = correlation
            
        except Exception as e:
            logger.error(f"ìƒê´€ê´€ê³„ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
    
    def check_correlation_risk(self, new_stock: str, existing_stocks: List[str]) -> bool:
        """ìƒˆë¡œìš´ ì¢…ëª© ì¶”ê°€ì‹œ ìƒê´€ê´€ê³„ ë¦¬ìŠ¤í¬ ì²´í¬"""
        try:
            for existing_stock in existing_stocks:
                key = f"{new_stock}_{existing_stock}"
                reverse_key = f"{existing_stock}_{new_stock}"
                
                correlation = self.correlation_matrix.get(key) or self.correlation_matrix.get(reverse_key, 0)
                
                if abs(correlation) > self.max_correlation:
                    logger.warning(f"ë†’ì€ ìƒê´€ê´€ê³„ ê°ì§€: {new_stock} - {existing_stock} ({correlation:.2f})")
                    return False
            
            return True
            
        except Exception as e:
            logger.error(f"ìƒê´€ê´€ê³„ ì²´í¬ ì˜¤ë¥˜: {e}")
            return True

class RiskAlert:
    """ë¦¬ìŠ¤í¬ ì•Œë¦¼ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.alert_thresholds = {
            'daily_loss': -0.015,  # -1.5%
            'drawdown': 0.10,      # 10%
            'volatility': 0.35     # 35%
        }
    
    async def check_and_send_alerts(self, portfolio_data: Dict[str, Any]):
        """ë¦¬ìŠ¤í¬ ì•Œë¦¼ ì²´í¬ ë° ë°œì†¡"""
        try:
            alerts = []
            
            # ì¼ì¼ ì†ì‹¤ ì•Œë¦¼
            daily_loss_ratio = portfolio_data.get('daily_pnl', 0) / portfolio_data.get('total_value', 1)
            if daily_loss_ratio <= self.alert_thresholds['daily_loss']:
                alerts.append({
                    'type': 'daily_loss',
                    'severity': 'high',
                    'message': f'ì¼ì¼ ì†ì‹¤ ê²½ê³ : {daily_loss_ratio:.2%}',
                    'timestamp': datetime.now()
                })
            
            # ë‚™í­ ì•Œë¦¼
            drawdown = portfolio_data.get('current_drawdown', 0)
            if drawdown >= self.alert_thresholds['drawdown']:
                alerts.append({
                    'type': 'drawdown',
                    'severity': 'high',
                    'message': f'ë‚™í­ ê²½ê³ : {drawdown:.2%}',
                    'timestamp': datetime.now()
                })
            
            # ë³€ë™ì„± ì•Œë¦¼
            portfolio_volatility = portfolio_data.get('volatility', 0)
            if portfolio_volatility >= self.alert_thresholds['volatility']:
                alerts.append({
                    'type': 'volatility',
                    'severity': 'medium',
                    'message': f'ë†’ì€ ë³€ë™ì„± ê°ì§€: {portfolio_volatility:.2%}',
                    'timestamp': datetime.now()
                })
            
            # ì•Œë¦¼ ë°œì†¡
            for alert in alerts:
                await self.send_alert(alert)
            
        except Exception as e:
            logger.error(f"ë¦¬ìŠ¤í¬ ì•Œë¦¼ ì²´í¬ ì˜¤ë¥˜: {e}")
    
    async def send_alert(self, alert: Dict[str, Any]):
        """ì•Œë¦¼ ë°œì†¡"""
        try:
            # ì‹¤ì œë¡œëŠ” ì´ë©”ì¼, SMS, ìŠ¬ë™ ë“±ìœ¼ë¡œ ì•Œë¦¼ ë°œì†¡
            logger.warning(f"ë¦¬ìŠ¤í¬ ì•Œë¦¼: {alert['message']}")
            
            # ë°ì´í„°ë² ì´ìŠ¤ì— ì•Œë¦¼ ê¸°ë¡ ì €ì¥
            await self.save_alert_to_db(alert)
            
        except Exception as e:
            logger.error(f"ì•Œë¦¼ ë°œì†¡ ì˜¤ë¥˜: {e}")
    
    async def save_alert_to_db(self, alert: Dict[str, Any]):
        """ì•Œë¦¼ì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” Alert í…Œì´ë¸”ì— ì €ì¥
            pass
        except Exception as e:
            logger.error(f"ì•Œë¦¼ ì €ì¥ ì˜¤ë¥˜: {e}")

class EmergencyManager:
    """ë¹„ìƒ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, risk_manager: RiskManager):
        self.risk_manager = risk_manager
        self.emergency_triggers = {
            'flash_crash': -0.05,  # 5% ê¸‰ë½
            'circuit_breaker': -0.08,  # 8% ê¸‰ë½
            'system_error': True
        }
    
    async def check_emergency_conditions(self, market_data: Dict[str, Any]) -> Dict[str, Any]:
        """ë¹„ìƒ ìƒí™© ì²´í¬"""
        try:
            emergency_status = {
                'emergency': False,
                'type': None,
                'severity': 'normal',
                'action_required': None
            }
            
            # ê¸‰ë½ ì²´í¬
            portfolio_change = market_data.get('portfolio_change_rate', 0)
            
            if portfolio_change <= self.emergency_triggers['circuit_breaker']:
                emergency_status.update({
                    'emergency': True,
                    'type': 'circuit_breaker',
                    'severity': 'critical',
                    'action_required': 'emergency_stop'
                })
            elif portfolio_change <= self.emergency_triggers['flash_crash']:
                emergency_status.update({
                    'emergency': True,
                    'type': 'flash_crash',
                    'severity': 'high',
                    'action_required': 'stop_trading'
                })
            
            # ì‹œìŠ¤í…œ ì˜¤ë¥˜ ì²´í¬
            if market_data.get('api_error', False):
                emergency_status.update({
                    'emergency': True,
                    'type': 'system_error',
                    'severity': 'high',
                    'action_required': 'emergency_stop'
                })
            
            return emergency_status
            
        except Exception as e:
            logger.error(f"ë¹„ìƒ ìƒí™© ì²´í¬ ì˜¤ë¥˜: {e}")
            return {'emergency': False}
    
    async def execute_emergency_action(self, action: str):
        """ë¹„ìƒ ì¡°ì¹˜ ì‹¤í–‰"""
        try:
            if action == 'emergency_stop':
                self.risk_manager.disable_trading()
                logger.critical("ë¹„ìƒ ì¤‘ë‹¨ ì‹¤í–‰ë¨")
                
            elif action == 'stop_trading':
                self.risk_manager.disable_trading()
                logger.warning("íŠ¸ë ˆì´ë”© ì¤‘ì§€ë¨")
                
            elif action == 'reduce_positions':
                # í¬ì§€ì…˜ í¬ê¸° ì¶•ì†Œ ë¡œì§
                logger.info("í¬ì§€ì…˜ ì¶•ì†Œ ëª¨ë“œ í™œì„±í™”")
                
        except Exception as e:
            logger.error(f"ë¹„ìƒ ì¡°ì¹˜ ì‹¤í–‰ ì˜¤ë¥˜: {e}") 



==================================================
File: C:\Aproject\test\quant_actual\backend\trading\strategies.py
==================================================
# file: backend/trading/strategies.py

import json
import logging
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
import numpy as np
import pandas as pd

from models import TradingSignal, OrderType, Strategy
from trading.indicators import TechnicalIndicators
from database import get_db_session

logger = logging.getLogger(__name__)

class BaseStrategy(ABC):
    """ì „ëµ ë² ì´ìŠ¤ í´ë˜ìŠ¤"""
    
    def __init__(self, strategy_config: Strategy):
        self.config = strategy_config
        self.name = strategy_config.name
        self.strategy_type = strategy_config.strategy_type
        self.target_stocks = json.loads(strategy_config.target_stocks)
        self.parameters = json.loads(strategy_config.parameters)
        self.indicators = TechnicalIndicators()
    
    @abstractmethod
    async def generate_signals(self, market_data: Dict[str, Any]) -> List[TradingSignal]:
        """ë§¤ë§¤ ì‹ í˜¸ ìƒì„± - ê° ì „ëµì—ì„œ êµ¬í˜„"""
        pass
    
    def get_position_size(self, stock_code: str, current_price: float) -> int:
        """í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°"""
        try:
            investment_amount = self.config.investment_amount
            max_position_value = investment_amount * 0.3  # ì „ëµ ìê¸ˆì˜ 30%ê¹Œì§€
            quantity = int(max_position_value / current_price / 100) * 100  # 100ì£¼ ë‹¨ìœ„
            return max(100, quantity)  # ìµœì†Œ 100ì£¼
        except:
            return 100
    
    async def get_price_history(self, stock_code: str, days: int = 30) -> List[float]:
        """ì¢…ëª©ì˜ ê³¼ê±° ê°€ê²© ë°ì´í„° ì¡°íšŒ"""
        try:
            from models import Stock, PriceHistory
            
            with get_db_session() as db:
                stock = db.query(Stock).filter(Stock.code == stock_code).first()
                if not stock:
                    return []
                
                start_date = datetime.now() - timedelta(days=days)
                price_records = db.query(PriceHistory)\
                    .filter(PriceHistory.stock_id == stock.id)\
                    .filter(PriceHistory.timestamp >= start_date)\
                    .order_by(PriceHistory.timestamp)\
                    .all()
                
                return [record.price for record in price_records]
                
        except Exception as e:
            logger.error(f"ê°€ê²© íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì‹¤íŒ¨ {stock_code}: {e}")
            return []
    
    async def get_volume_history(self, stock_code: str, days: int = 5) -> List[int]:
        """ì¢…ëª©ì˜ ê³¼ê±° ê±°ë˜ëŸ‰ ë°ì´í„° ì¡°íšŒ"""
        try:
            from models import Stock, PriceHistory
            
            with get_db_session() as db:
                stock = db.query(Stock).filter(Stock.code == stock_code).first()
                if not stock:
                    return []
                
                start_date = datetime.now() - timedelta(days=days)
                volume_records = db.query(PriceHistory)\
                    .filter(PriceHistory.stock_id == stock.id)\
                    .filter(PriceHistory.timestamp >= start_date)\
                    .order_by(PriceHistory.timestamp)\
                    .all()
                
                return [record.volume for record in volume_records if record.volume]
                
        except Exception as e:
            logger.error(f"ê±°ë˜ëŸ‰ íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì‹¤íŒ¨ {stock_code}: {e}")
            return []
    
    async def get_current_position(self, stock_code: str) -> Optional[Dict[str, Any]]:
        """í˜„ì¬ ë³´ìœ  í¬ì§€ì…˜ ì¡°íšŒ"""
        try:
            from models import Position, Stock
            
            with get_db_session() as db:
                position = db.query(Position)\
                    .join(Stock)\
                    .filter(Stock.code == stock_code)\
                    .filter(Position.strategy_id == self.config.id)\
                    .filter(Position.quantity > 0)\
                    .first()
                
                if position:
                    return {
                        'quantity': position.quantity,
                        'avg_price': position.avg_price,
                        'current_price': position.current_price,
                        'unrealized_pnl': position.unrealized_pnl
                    }
                return None
                
        except Exception as e:
            logger.error(f"í¬ì§€ì…˜ ì¡°íšŒ ì‹¤íŒ¨ {stock_code}: {e}")
            return None
    
    def should_stop_loss(self, position: Dict[str, Any], current_price: float) -> bool:
        """ì†ì ˆ ì—¬ë¶€ íŒë‹¨"""
        try:
            stop_loss_rate = self.parameters.get('stop_loss', 0.05)  # ê¸°ë³¸ 5% ì†ì ˆ
            avg_price = position['avg_price']
            loss_rate = (avg_price - current_price) / avg_price
            
            return loss_rate >= stop_loss_rate
            
        except:
            return False
    
    def should_take_profit(self, position: Dict[str, Any], current_price: float) -> bool:
        """ìµì ˆ ì—¬ë¶€ íŒë‹¨"""
        try:
            take_profit_rate = self.parameters.get('take_profit', 0.1)  # ê¸°ë³¸ 10% ìµì ˆ
            avg_price = position['avg_price']
            profit_rate = (current_price - avg_price) / avg_price
            
            return profit_rate >= take_profit_rate
            
        except:
            return False

class BollingerBandStrategy(BaseStrategy):
    """ë³¼ë¦°ì €ë°´ë“œ í‰ê· íšŒê·€ ì „ëµ"""
    
    async def generate_signals(self, market_data: Dict[str, Any]) -> List[TradingSignal]:
        signals = []
        
        for stock_code in self.target_stocks:
            try:
                if stock_code not in market_data:
                    continue
                
                current_data = market_data[stock_code]
                current_price = current_data['current_price']
                
                # ê³¼ê±° ê°€ê²© ë°ì´í„° ì¡°íšŒ
                price_history = await self.get_price_history(stock_code, days=30)
                if len(price_history) < self.parameters.get('period', 20):
                    continue
                
                # ë³¼ë¦°ì €ë°´ë“œ ê³„ì‚°
                period = self.parameters.get('period', 20)
                std_multiplier = self.parameters.get('std_multiplier', 2.0)
                
                bb_result = self.indicators.bollinger_bands(
                    price_history, period, std_multiplier
                )
                
                if not bb_result:
                    continue
                
                upper_band = bb_result['upper'][-1]
                lower_band = bb_result['lower'][-1]
                middle_band = bb_result['middle'][-1]
                
                # í˜„ì¬ í¬ì§€ì…˜ í™•ì¸
                current_position = await self.get_current_position(stock_code)
                
                # ë§¤ìˆ˜ ì‹ í˜¸: ê°€ê²©ì´ í•˜ë‹¨ì„  ì•„ë˜ë¡œ ë‚´ë ¤ê°”ì„ ë•Œ
                if current_price <= lower_band and not current_position:
                    quantity = self.get_position_size(stock_code, current_price)
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.BUY,
                        quantity=quantity,
                        price=current_price,
                        confidence=self.calculate_confidence(current_price, lower_band, middle_band),
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"ë³¼ë¦°ì €ë°´ë“œ ë§¤ìˆ˜ ì‹ í˜¸: {stock_code} @ {current_price}")
                
                # ë§¤ë„ ì‹ í˜¸: ê°€ê²©ì´ ìƒë‹¨ì„  ìœ„ë¡œ ì˜¬ë¼ê°”ì„ ë•Œ ë˜ëŠ” ì¤‘ê°„ì„  íšŒê·€
                elif current_position and (current_price >= upper_band or 
                    (current_price >= middle_band and self.should_take_profit(current_position, current_price))):
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.8,
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"ë³¼ë¦°ì €ë°´ë“œ ë§¤ë„ ì‹ í˜¸: {stock_code} @ {current_price}")
                
                # ì†ì ˆ ì²´í¬
                elif current_position and self.should_stop_loss(current_position, current_price):
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.9,  # ì†ì ˆì€ ë†’ì€ í™•ì‹ ë„
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"ë³¼ë¦°ì €ë°´ë“œ ì†ì ˆ ì‹ í˜¸: {stock_code} @ {current_price}")
                    
            except Exception as e:
                logger.error(f"ë³¼ë¦°ì €ë°´ë“œ ì „ëµ ì˜¤ë¥˜ {stock_code}: {e}")
        
        return signals
    
    def calculate_confidence(self, current_price: float, lower_band: float, middle_band: float) -> float:
        """ì‹ í˜¸ì˜ ì‹ ë¢°ë„ ê³„ì‚°"""
        # í•˜ë‹¨ì„ ì—ì„œ ë©€ìˆ˜ë¡ ë†’ì€ ì‹ ë¢°ë„
        distance_ratio = (lower_band - current_price) / (middle_band - lower_band)
        return min(0.95, max(0.5, 0.7 + distance_ratio * 0.3))

class RSIReversalStrategy(BaseStrategy):
    """RSI ì—­ì¶”ì„¸ ì „ëµ"""
    
    async def generate_signals(self, market_data: Dict[str, Any]) -> List[TradingSignal]:
        signals = []
        
        for stock_code in self.target_stocks:
            try:
                if stock_code not in market_data:
                    continue
                
                current_data = market_data[stock_code]
                current_price = current_data['current_price']
                
                # ê³¼ê±° ê°€ê²© ë°ì´í„° ì¡°íšŒ
                price_history = await self.get_price_history(stock_code, days=30)
                rsi_period = self.parameters.get('period', 14)
                
                if len(price_history) < rsi_period + 1:
                    continue
                
                # RSI ê³„ì‚°
                rsi_values = self.indicators.rsi(price_history, rsi_period)
                if not rsi_values or len(rsi_values) == 0:
                    continue
                
                current_rsi = rsi_values[-1]
                oversold_level = self.parameters.get('oversold', 30)
                overbought_level = self.parameters.get('overbought', 70)
                
                # í˜„ì¬ í¬ì§€ì…˜ í™•ì¸
                current_position = await self.get_current_position(stock_code)
                
                # ë§¤ìˆ˜ ì‹ í˜¸: RSIê°€ ê³¼ë§¤ë„ ì˜ì—­ì—ì„œ ë°˜ë“±
                if (current_rsi <= oversold_level and 
                    len(rsi_values) >= 2 and rsi_values[-2] < rsi_values[-1] and
                    not current_position):
                    
                    quantity = self.get_position_size(stock_code, current_price)
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.BUY,
                        quantity=quantity,
                        price=current_price,
                        confidence=self.calculate_rsi_confidence(current_rsi, oversold_level),
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"RSI ë§¤ìˆ˜ ì‹ í˜¸: {stock_code} @ {current_price} (RSI: {current_rsi:.1f})")
                
                # ë§¤ë„ ì‹ í˜¸: RSIê°€ ê³¼ë§¤ìˆ˜ ì˜ì—­ì— ì§„ì…
                elif (current_position and current_rsi >= overbought_level):
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=self.calculate_rsi_confidence(current_rsi, overbought_level, is_sell=True),
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"RSI ë§¤ë„ ì‹ í˜¸: {stock_code} @ {current_price} (RSI: {current_rsi:.1f})")
                
                # ì†ì ˆ ì²´í¬
                elif current_position and self.should_stop_loss(current_position, current_price):
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.9,
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"RSI ì†ì ˆ ì‹ í˜¸: {stock_code} @ {current_price}")
                    
            except Exception as e:
                logger.error(f"RSI ì „ëµ ì˜¤ë¥˜ {stock_code}: {e}")
        
        return signals
    
    def calculate_rsi_confidence(self, rsi_value: float, threshold: float, is_sell: bool = False) -> float:
        """RSI ê¸°ë°˜ ì‹ ë¢°ë„ ê³„ì‚°"""
        if is_sell:
            # ê³¼ë§¤ìˆ˜ ì˜ì—­ì—ì„œ ë†’ì„ìˆ˜ë¡ ì‹ ë¢°ë„ ë†’ìŒ
            excess = max(0, rsi_value - threshold)
            return min(0.95, 0.6 + excess * 0.01)
        else:
            # ê³¼ë§¤ë„ ì˜ì—­ì—ì„œ ë‚®ì„ìˆ˜ë¡ ì‹ ë¢°ë„ ë†’ìŒ
            excess = max(0, threshold - rsi_value)
            return min(0.95, 0.6 + excess * 0.01)

class MomentumStrategy(BaseStrategy):
    """ëª¨ë©˜í…€ ì¶”ì„¸ì¶”ì¢… ì „ëµ"""
    
    async def generate_signals(self, market_data: Dict[str, Any]) -> List[TradingSignal]:
        signals = []
        
        for stock_code in self.target_stocks:
            try:
                if stock_code not in market_data:
                    continue
                
                current_data = market_data[stock_code]
                current_price = current_data['current_price']
                volume = current_data.get('volume', 0)
                
                # ê³¼ê±° ê°€ê²© ë°ì´í„° ì¡°íšŒ
                price_history = await self.get_price_history(stock_code, days=60)
                if len(price_history) < 30:
                    continue
                
                # MACD ê³„ì‚°
                short_period = self.parameters.get('short_period', 12)
                long_period = self.parameters.get('long_period', 26)
                signal_period = self.parameters.get('signal_period', 9)
                
                macd_result = self.indicators.macd(
                    price_history, short_period, long_period, signal_period
                )
                
                if not macd_result or len(macd_result['macd']) < 2:
                    continue
                
                current_macd = macd_result['macd'][-1]
                current_signal_line = macd_result['signal'][-1]
                prev_macd = macd_result['macd'][-2]
                prev_signal_line = macd_result['signal'][-2]
                
                # í˜„ì¬ í¬ì§€ì…˜ í™•ì¸
                current_position = await self.get_current_position(stock_code)
                
                # ë§¤ìˆ˜ ì‹ í˜¸: MACDê°€ ì‹œê·¸ë„ì„ ì„ ìƒí–¥ëŒíŒŒ + ê±°ë˜ëŸ‰ ì¦ê°€
                if (current_macd > current_signal_line and 
                    prev_macd <= prev_signal_line and
                    not current_position and
                    await self.is_volume_increasing(stock_code, volume)):
                    
                    quantity = self.get_position_size(stock_code, current_price)
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.BUY,
                        quantity=quantity,
                        price=current_price,
                        confidence=self.calculate_momentum_confidence(macd_result, volume),
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"ëª¨ë©˜í…€ ë§¤ìˆ˜ ì‹ í˜¸: {stock_code} @ {current_price}")
                
                # ë§¤ë„ ì‹ í˜¸: MACDê°€ ì‹œê·¸ë„ì„ ì„ í•˜í–¥ëŒíŒŒ
                elif (current_position and 
                      current_macd < current_signal_line and 
                      prev_macd >= prev_signal_line):
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.8,
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"ëª¨ë©˜í…€ ë§¤ë„ ì‹ í˜¸: {stock_code} @ {current_price}")
                
                # ì†ì ˆ ì²´í¬
                elif current_position and self.should_stop_loss(current_position, current_price):
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.9,
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
            except Exception as e:
                logger.error(f"ëª¨ë©˜í…€ ì „ëµ ì˜¤ë¥˜ {stock_code}: {e}")
        
        return signals
    
    async def is_volume_increasing(self, stock_code: str, current_volume: int) -> bool:
        """ê±°ë˜ëŸ‰ ì¦ê°€ í™•ì¸"""
        try:
            # ìµœê·¼ 5ì¼ í‰ê·  ê±°ë˜ëŸ‰ê³¼ ë¹„êµ
            volume_history = await self.get_volume_history(stock_code, days=5)
            if len(volume_history) < 3:
                return True  # ë°ì´í„° ë¶€ì¡±ì‹œ true
            
            avg_volume = sum(volume_history) / len(volume_history)
            return current_volume > avg_volume * 1.2  # 20% ì´ìƒ ì¦ê°€
            
        except:
            return True
    
    def calculate_momentum_confidence(self, macd_result: dict, volume: int) -> float:
        """ëª¨ë©˜í…€ ì‹ ë¢°ë„ ê³„ì‚°"""
        try:
            # MACD íˆìŠ¤í† ê·¸ë¨ì˜ ê°•ë„ì™€ ê±°ë˜ëŸ‰ì„ ê³ ë ¤
            histogram = macd_result.get('histogram', [0])
            if len(histogram) > 0:
                current_histogram = abs(histogram[-1])
                base_confidence = 0.6
                histogram_bonus = min(0.3, current_histogram * 0.1)
                return base_confidence + histogram_bonus
            return 0.7
        except:
            return 0.7

class MovingAverageStrategy(BaseStrategy):
    """ì´ë™í‰ê·  ê³¨ë“ í¬ë¡œìŠ¤ ì „ëµ"""
    
    async def generate_signals(self, market_data: Dict[str, Any]) -> List[TradingSignal]:
        signals = []
        
        for stock_code in self.target_stocks:
            try:
                if stock_code not in market_data:
                    continue
                
                current_data = market_data[stock_code]
                current_price = current_data['current_price']
                volume = current_data.get('volume', 0)
                
                # ê³¼ê±° ê°€ê²© ë°ì´í„° ì¡°íšŒ
                price_history = await self.get_price_history(stock_code, days=40)
                short_ma_period = self.parameters.get('short_ma', 5)
                long_ma_period = self.parameters.get('long_ma', 20)
                
                if len(price_history) < long_ma_period + 1:
                    continue
                
                # ì´ë™í‰ê·  ê³„ì‚°
                short_ma = self.indicators.moving_average(price_history, short_ma_period)
                long_ma = self.indicators.moving_average(price_history, long_ma_period)
                
                if len(short_ma) < 2 or len(long_ma) < 2:
                    continue
                
                current_short_ma = short_ma[-1]
                current_long_ma = long_ma[-1]
                prev_short_ma = short_ma[-2]
                prev_long_ma = long_ma[-2]
                
                # í˜„ì¬ í¬ì§€ì…˜ í™•ì¸
                current_position = await self.get_current_position(stock_code)
                
                # ê³¨ë“ í¬ë¡œìŠ¤: ë‹¨ê¸° ì´ë™í‰ê· ì´ ì¥ê¸° ì´ë™í‰ê· ì„ ìƒí–¥ëŒíŒŒ
                if (current_short_ma > current_long_ma and 
                    prev_short_ma <= prev_long_ma and
                    not current_position and
                    volume > self.parameters.get('volume_threshold', 1000000)):
                    
                    quantity = self.get_position_size(stock_code, current_price)
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.BUY,
                        quantity=quantity,
                        price=current_price,
                        confidence=self.calculate_ma_confidence(current_price, current_short_ma, current_long_ma),
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"ê³¨ë“ í¬ë¡œìŠ¤ ë§¤ìˆ˜ ì‹ í˜¸: {stock_code} @ {current_price}")
                
                # ë°ë“œí¬ë¡œìŠ¤: ë‹¨ê¸° ì´ë™í‰ê· ì´ ì¥ê¸° ì´ë™í‰ê· ì„ í•˜í–¥ëŒíŒŒ
                elif (current_position and 
                      current_short_ma < current_long_ma and 
                      prev_short_ma >= prev_long_ma):
                    
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.8,
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
                    logger.info(f"ë°ë“œí¬ë¡œìŠ¤ ë§¤ë„ ì‹ í˜¸: {stock_code} @ {current_price}")
                
                # ì†ì ˆ ì²´í¬
                elif current_position and self.should_stop_loss(current_position, current_price):
                    signal = TradingSignal(
                        stock_code=stock_code,
                        strategy_name=self.name,
                        signal_type=OrderType.SELL,
                        quantity=current_position['quantity'],
                        price=current_price,
                        confidence=0.9,
                        timestamp=datetime.now()
                    )
                    signals.append(signal)
                    
            except Exception as e:
                logger.error(f"ì´ë™í‰ê·  ì „ëµ ì˜¤ë¥˜ {stock_code}: {e}")
        
        return signals
    
    def calculate_ma_confidence(self, current_price: float, short_ma: float, long_ma: float) -> float:
        """ì´ë™í‰ê·  ê¸°ë°˜ ì‹ ë¢°ë„ ê³„ì‚°"""
        # í˜„ì¬ê°€ê°€ ë‘ ì´ë™í‰ê· ë³´ë‹¤ ë†’ê³ , ì´ë™í‰ê· ê°„ ê°„ê²©ì´ í´ìˆ˜ë¡ ì‹ ë¢°ë„ ë†’ìŒ
        if current_price > short_ma > long_ma:
            gap_ratio = (short_ma - long_ma) / long_ma
            return min(0.95, 0.6 + gap_ratio * 10)
        return 0.5

class StrategyManager:
    """ì „ëµ ê´€ë¦¬ì"""
    
    def __init__(self):
        self.strategies = {}
        
    async def initialize(self):
        """ì „ëµ ë§¤ë‹ˆì € ì´ˆê¸°í™”"""
        try:
            # ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ í™œì„± ì „ëµ ë¡œë“œ
            with get_db_session() as db:
                active_strategies = db.query(Strategy).filter(Strategy.is_active == True).all()
                
                for strategy_config in active_strategies:
                    strategy = self.create_strategy(strategy_config)
                    if strategy:
                        self.strategies[strategy_config.id] = strategy
                        logger.info(f"ì „ëµ ì´ˆê¸°í™”: {strategy_config.name}")
            
        except Exception as e:
            logger.error(f"ì „ëµ ë§¤ë‹ˆì € ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            raise
    
    def create_strategy(self, strategy_config: Strategy) -> Optional[BaseStrategy]:
        """ì „ëµ íƒ€ì…ì— ë”°ë¥¸ ì „ëµ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±"""
        try:
            strategy_map = {
                "bollinger_bands": BollingerBandStrategy,
                "rsi_reversal": RSIReversalStrategy,
                "momentum": MomentumStrategy,
                "moving_average": MovingAverageStrategy
            }
            
            strategy_class = strategy_map.get(strategy_config.strategy_type)
            if strategy_class:
                return strategy_class(strategy_config)
            else:
                logger.warning(f"ì•Œ ìˆ˜ ì—†ëŠ” ì „ëµ íƒ€ì…: {strategy_config.strategy_type}")
                return None
                
        except Exception as e:
            logger.error(f"ì „ëµ ìƒì„± ì‹¤íŒ¨ {strategy_config.name}: {e}")
            return None
    
    async def generate_signals(self, strategy_id: int, market_data: Dict[str, Any]) -> List[TradingSignal]:
        """íŠ¹ì • ì „ëµì˜ ì‹ í˜¸ ìƒì„±"""
        try:
            if strategy_id not in self.strategies:
                return []
            
            strategy = self.strategies[strategy_id]
            signals = await strategy.generate_signals(market_data)
            
            return signals
            
        except Exception as e:
            logger.error(f"ì‹ í˜¸ ìƒì„± ì‹¤íŒ¨ {strategy_id}: {e}")
            return []
    
    async def add_strategy(self, strategy_config: Strategy):
        """ìƒˆ ì „ëµ ì¶”ê°€"""
        strategy = self.create_strategy(strategy_config)
        if strategy:
            self.strategies[strategy_config.id] = strategy
            logger.info(f"ìƒˆ ì „ëµ ì¶”ê°€: {strategy_config.name}")
    
    async def remove_strategy(self, strategy_id: int):
        """ì „ëµ ì œê±°"""
        if strategy_id in self.strategies:
            strategy_name = self.strategies[strategy_id].name
            del self.strategies[strategy_id]
            logger.info(f"ì „ëµ ì œê±°: {strategy_name}")
    
    async def update_strategy(self, strategy_config: Strategy):
        """ì „ëµ ì—…ë°ì´íŠ¸"""
        # ê¸°ì¡´ ì „ëµ ì œê±° í›„ ìƒˆë¡œ ì¶”ê°€
        await self.remove_strategy(strategy_config.id)
        await self.add_strategy(strategy_config)


==================================================
File: C:\Aproject\test\quant_actual\backend\trading\__init__.py
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\backend\utils\config.py
==================================================
# file: backend/utils/config.py

import os
import json
from pathlib import Path
from typing import Dict, Any, Optional
from pydantic_settings import BaseSettings
from pydantic import Field
import logging

logger = logging.getLogger(__name__)

class Settings(BaseSettings):
    """ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì •"""
    
    # ì• í”Œë¦¬ì¼€ì´ì…˜ ê¸°ë³¸ ì„¤ì •
    app_name: str = "QuanTrade Pro"
    app_version: str = "1.0.0"
    debug: bool = False
    environment: str = Field(default="development", description="Environment (development, production)")
    
    # ì„œë²„ ì„¤ì •
    host: str = "0.0.0.0"
    port: int = 8000
    reload: bool = True
    
    # ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
    database_url: str = "sqlite:///./data/quantrade.db"
    database_echo: bool = False
    
    # í‚¤ì›€ API ì„¤ì •
    kiwoom_server_type: str = "DEMO"  # DEMO or REAL
    kiwoom_account: str = ""
    kiwoom_password: str = ""
    kiwoom_cert_password: str = ""
    
    # íŠ¸ë ˆì´ë”© ì„¤ì •
    initial_capital: float = 50000000.0  # 5ì²œë§Œì›
    max_daily_loss: float = -0.02  # -2%
    max_position_size: float = 0.05  # 5%
    max_positions: int = 10
    emergency_sell_all: bool = False
    
    # ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì„¤ì •
    risk_daily_loss_limit: float = -0.02
    risk_position_size_limit: float = 0.05
    risk_max_positions: int = 10
    risk_max_single_stock_weight: float = 0.15
    risk_max_sector_weight: float = 0.30
    
    # ì•Œë¦¼ ì„¤ì •
    email_enabled: bool = False
    email_smtp_server: str = ""
    email_smtp_port: int = 587
    email_username: str = ""
    email_password: str = ""
    email_recipients: list = []
    
    slack_enabled: bool = False
    slack_webhook_url: str = ""
    slack_channel: str = "#trading"
    
    # ë¡œê¹… ì„¤ì •
    log_level: str = "INFO"
    log_file: str = "logs/quantrade.log"
    log_max_size: int = 10485760  # 10MB
    log_backup_count: int = 5
    
    # ì‹œì¥ ì‹œê°„ ì„¤ì •
    market_open_time: str = "09:00"
    market_close_time: str = "15:30"
    market_timezone: str = "Asia/Seoul"
    
    # ë°±í…ŒìŠ¤íŠ¸ ì„¤ì •
    backtest_initial_capital: float = 10000000.0  # 1ì²œë§Œì›
    backtest_commission_rate: float = 0.00015  # 0.015%
    backtest_slippage: float = 0.001  # 0.1%
    
    # ìºì‹œ ì„¤ì •
    redis_url: str = "redis://localhost:6379"
    cache_ttl: int = 300  # 5ë¶„
    
    # ë³´ì•ˆ ì„¤ì •
    secret_key: str = "your-secret-key-here"
    access_token_expire_minutes: int = 1440  # 24ì‹œê°„
    
    # API ì œí•œ ì„¤ì •
    rate_limit_per_minute: int = 60
    max_concurrent_requests: int = 10
    
    class Config:
        env_file = ".env"
        case_sensitive = False

class ConfigManager:
    """ì„¤ì • ê´€ë¦¬ì"""
    
    def __init__(self, config_dir: str = "config"):
        self.config_dir = Path(config_dir)
        self.config_dir.mkdir(exist_ok=True)
        
        self.settings = Settings()
        self.strategy_configs = {}
        self.risk_configs = {}
        
        # ì„¤ì • íŒŒì¼ ë¡œë“œ
        self.load_all_configs()
    
    def load_all_configs(self):
        """ëª¨ë“  ì„¤ì • íŒŒì¼ ë¡œë“œ"""
        try:
            self.load_strategy_configs()
            self.load_risk_configs()
            logger.info("ëª¨ë“  ì„¤ì • íŒŒì¼ ë¡œë“œ ì™„ë£Œ")
        except Exception as e:
            logger.error(f"ì„¤ì • íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: {e}")
    
    def load_strategy_configs(self):
        """ì „ëµ ì„¤ì • ë¡œë“œ"""
        try:
            config_file = self.config_dir / "strategies.json"
            
            if config_file.exists():
                with open(config_file, 'r', encoding='utf-8') as f:
                    self.strategy_configs = json.load(f)
            else:
                # ê¸°ë³¸ ì „ëµ ì„¤ì • ìƒì„±
                self.strategy_configs = self.get_default_strategy_configs()
                self.save_strategy_configs()
            
            logger.info(f"ì „ëµ ì„¤ì • ë¡œë“œ ì™„ë£Œ: {len(self.strategy_configs)}ê°œ")
            
        except Exception as e:
            logger.error(f"ì „ëµ ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}")
            self.strategy_configs = self.get_default_strategy_configs()
    
    def load_risk_configs(self):
        """ë¦¬ìŠ¤í¬ ì„¤ì • ë¡œë“œ"""
        try:
            config_file = self.config_dir / "risk_limits.json"
            
            if config_file.exists():
                with open(config_file, 'r', encoding='utf-8') as f:
                    self.risk_configs = json.load(f)
            else:
                # ê¸°ë³¸ ë¦¬ìŠ¤í¬ ì„¤ì • ìƒì„±
                self.risk_configs = self.get_default_risk_configs()
                self.save_risk_configs()
            
            logger.info("ë¦¬ìŠ¤í¬ ì„¤ì • ë¡œë“œ ì™„ë£Œ")
            
        except Exception as e:
            logger.error(f"ë¦¬ìŠ¤í¬ ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}")
            self.risk_configs = self.get_default_risk_configs()
    
    def get_default_strategy_configs(self) -> Dict[str, Any]:
        """ê¸°ë³¸ ì „ëµ ì„¤ì • ë°˜í™˜"""
        return {
            "bollinger_bands": {
                "name": "ë³¼ë¦°ì €ë°´ë“œ í‰ê· íšŒê·€",
                "enabled": True,
                "parameters": {
                    "period": 20,
                    "std_multiplier": 2.0,
                    "stop_loss": 0.05,
                    "take_profit": 0.03,
                    "min_volume": 100000
                },
                "target_stocks": ["005930", "000660", "035420"],
                "investment_amount": 10000000,
                "max_position_size": 0.05,
                "confidence_threshold": 0.6
            },
            "rsi_reversal": {
                "name": "RSI ì—­ì¶”ì„¸",
                "enabled": True,
                "parameters": {
                    "period": 14,
                    "oversold": 30,
                    "overbought": 70,
                    "stop_loss": 0.04,
                    "min_rsi_change": 2
                },
                "target_stocks": ["035720", "051910"],
                "investment_amount": 8000000,
                "max_position_size": 0.04,
                "confidence_threshold": 0.7
            },
            "momentum": {
                "name": "ëª¨ë©˜í…€ ì¶”ì„¸ì¶”ì¢…",
                "enabled": False,
                "parameters": {
                    "short_period": 12,
                    "long_period": 26,
                    "signal_period": 9,
                    "volume_threshold": 1.2,
                    "trend_strength_min": 0.6
                },
                "target_stocks": ["006400", "207940"],
                "investment_amount": 5000000,
                "max_position_size": 0.03,
                "confidence_threshold": 0.8
            },
            "moving_average": {
                "name": "ì´ë™í‰ê·  ê³¨ë“ í¬ë¡œìŠ¤",
                "enabled": False,
                "parameters": {
                    "short_ma": 5,
                    "long_ma": 20,
                    "volume_threshold": 1000000,
                    "confirmation_period": 3
                },
                "target_stocks": ["373220"],
                "investment_amount": 3000000,
                "max_position_size": 0.02,
                "confidence_threshold": 0.7
            }
        }
    
    def get_default_risk_configs(self) -> Dict[str, Any]:
        """ê¸°ë³¸ ë¦¬ìŠ¤í¬ ì„¤ì • ë°˜í™˜"""
        return {
            "daily_limits": {
                "max_daily_loss": -0.02,
                "max_daily_trades": 50,
                "max_daily_volume": 100000000
            },
            "position_limits": {
                "max_position_size": 0.05,
                "max_positions": 10,
                "max_single_stock_weight": 0.15,
                "max_sector_weight": 0.30
            },
            "volatility_limits": {
                "max_portfolio_volatility": 0.25,
                "high_volatility_threshold": 0.40,
                "volatility_adjustment": True
            },
            "correlation_limits": {
                "max_correlation": 0.70,
                "correlation_check_enabled": True,
                "correlation_period": 60
            },
            "drawdown_limits": {
                "max_drawdown": 0.15,
                "drawdown_alert_level": 0.10,
                "recovery_time_limit": 30
            },
            "emergency_settings": {
                "auto_stop_on_loss": True,
                "emergency_sell_enabled": False,
                "circuit_breaker_level": -0.08,
                "flash_crash_level": -0.05
            }
        }
    
    def save_strategy_configs(self):
        """ì „ëµ ì„¤ì • ì €ì¥"""
        try:
            config_file = self.config_dir / "strategies.json"
            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(self.strategy_configs, f, indent=2, ensure_ascii=False)
            logger.info("ì „ëµ ì„¤ì • ì €ì¥ ì™„ë£Œ")
        except Exception as e:
            logger.error(f"ì „ëµ ì„¤ì • ì €ì¥ ì‹¤íŒ¨: {e}")
    
    def save_risk_configs(self):
        """ë¦¬ìŠ¤í¬ ì„¤ì • ì €ì¥"""
        try:
            config_file = self.config_dir / "risk_limits.json"
            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(self.risk_configs, f, indent=2, ensure_ascii=False)
            logger.info("ë¦¬ìŠ¤í¬ ì„¤ì • ì €ì¥ ì™„ë£Œ")
        except Exception as e:
            logger.error(f"ë¦¬ìŠ¤í¬ ì„¤ì • ì €ì¥ ì‹¤íŒ¨: {e}")
    
    def get_strategy_config(self, strategy_name: str) -> Optional[Dict[str, Any]]:
        """íŠ¹ì • ì „ëµ ì„¤ì • ì¡°íšŒ"""
        return self.strategy_configs.get(strategy_name)
    
    def update_strategy_config(self, strategy_name: str, config: Dict[str, Any]):
        """ì „ëµ ì„¤ì • ì—…ë°ì´íŠ¸"""
        try:
            self.strategy_configs[strategy_name] = config
            self.save_strategy_configs()
            logger.info(f"ì „ëµ ì„¤ì • ì—…ë°ì´íŠ¸: {strategy_name}")
        except Exception as e:
            logger.error(f"ì „ëµ ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    def get_risk_config(self, category: str = None) -> Dict[str, Any]:
        """ë¦¬ìŠ¤í¬ ì„¤ì • ì¡°íšŒ"""
        if category:
            return self.risk_configs.get(category, {})
        return self.risk_configs
    
    def update_risk_config(self, category: str, config: Dict[str, Any]):
        """ë¦¬ìŠ¤í¬ ì„¤ì • ì—…ë°ì´íŠ¸"""
        try:
            self.risk_configs[category] = config
            self.save_risk_configs()
            logger.info(f"ë¦¬ìŠ¤í¬ ì„¤ì • ì—…ë°ì´íŠ¸: {category}")
        except Exception as e:
            logger.error(f"ë¦¬ìŠ¤í¬ ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    def get_market_config(self) -> Dict[str, Any]:
        """ì‹œì¥ ì„¤ì • ì¡°íšŒ"""
        return {
            "open_time": self.settings.market_open_time,
            "close_time": self.settings.market_close_time,
            "timezone": self.settings.market_timezone,
            "trading_days": ["monday", "tuesday", "wednesday", "thursday", "friday"]
        }
    
    def get_api_config(self) -> Dict[str, Any]:
        """API ì„¤ì • ì¡°íšŒ"""
        return {
            "kiwoom": {
                "server_type": self.settings.kiwoom_server_type,
                "account": self.settings.kiwoom_account,
                # ë¹„ë°€ë²ˆí˜¸ëŠ” ë³´ì•ˆìƒ ë°˜í™˜í•˜ì§€ ì•ŠìŒ
            },
            "rate_limit": self.settings.rate_limit_per_minute,
            "max_concurrent": self.settings.max_concurrent_requests
        }
    
    def get_notification_config(self) -> Dict[str, Any]:
        """ì•Œë¦¼ ì„¤ì • ì¡°íšŒ"""
        return {
            "email": {
                "enabled": self.settings.email_enabled,
                "recipients": self.settings.email_recipients,
                "smtp_server": self.settings.email_smtp_server,
                "smtp_port": self.settings.email_smtp_port
            },
            "slack": {
                "enabled": self.settings.slack_enabled,
                "channel": self.settings.slack_channel
            }
        }
    
    def validate_config(self) -> Dict[str, Any]:
        """ì„¤ì • ìœ íš¨ì„± ê²€ì‚¬"""
        validation_result = {
            "valid": True,
            "errors": [],
            "warnings": []
        }
        
        try:
            # í•„ìˆ˜ ì„¤ì • ì²´í¬
            if not self.settings.secret_key or self.settings.secret_key == "your-secret-key-here":
                validation_result["errors"].append("SECRET_KEYê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
                validation_result["valid"] = False
            
            # íŠ¸ë ˆì´ë”© ì„¤ì • ì²´í¬
            if self.settings.max_daily_loss >= 0:
                validation_result["errors"].append("ì¼ì¼ ì†ì‹¤ í•œë„ëŠ” ìŒìˆ˜ì—¬ì•¼ í•¨")
                validation_result["valid"] = False
            
            if self.settings.max_position_size <= 0 or self.settings.max_position_size > 1:
                validation_result["errors"].append("í¬ì§€ì…˜ í¬ê¸° í•œë„ëŠ” 0ê³¼ 1 ì‚¬ì´ì—¬ì•¼ í•¨")
                validation_result["valid"] = False
            
            # ì „ëµ ì„¤ì • ì²´í¬
            active_strategies = [name for name, config in self.strategy_configs.items() if config.get("enabled")]
            if not active_strategies:
                validation_result["warnings"].append("í™œì„±í™”ëœ ì „ëµì´ ì—†ìŒ")
            
            # íˆ¬ì ê¸ˆì•¡ ì²´í¬
            total_investment = sum(
                config.get("investment_amount", 0) 
                for config in self.strategy_configs.values() 
                if config.get("enabled")
            )
            
            if total_investment > self.settings.initial_capital:
                validation_result["warnings"].append(
                    f"ì „ëµë³„ íˆ¬ìê¸ˆì•¡ í•©ê³„({total_investment:,})ê°€ ì´ˆê¸° ìë³¸({self.settings.initial_capital:,})ì„ ì´ˆê³¼"
                )
            
            # ë¦¬ìŠ¤í¬ ì„¤ì • ì²´í¬
            risk_limits = self.risk_configs.get("position_limits", {})
            if risk_limits.get("max_single_stock_weight", 0) > risk_limits.get("max_sector_weight", 1):
                validation_result["warnings"].append("ê°œë³„ ì¢…ëª© í•œë„ê°€ ì„¹í„° í•œë„ë³´ë‹¤ í¼")
            
        except Exception as e:
            validation_result["errors"].append(f"ì„¤ì • ê²€ì¦ ì¤‘ ì˜¤ë¥˜: {e}")
            validation_result["valid"] = False
        
        return validation_result
    
    def export_config(self, file_path: str):
        """ì„¤ì •ì„ íŒŒì¼ë¡œ ë‚´ë³´ë‚´ê¸°"""
        try:
            export_data = {
                "app_settings": {
                    "app_name": self.settings.app_name,
                    "version": self.settings.app_version,
                    "environment": self.settings.environment,
                    "initial_capital": self.settings.initial_capital
                },
                "trading_settings": {
                    "max_daily_loss": self.settings.max_daily_loss,
                    "max_position_size": self.settings.max_position_size,
                    "max_positions": self.settings.max_positions,
                    "emergency_sell_all": self.settings.emergency_sell_all
                },
                "market_settings": {
                    "open_time": self.settings.market_open_time,
                    "close_time": self.settings.market_close_time,
                    "timezone": self.settings.market_timezone
                },
                "strategies": self.strategy_configs,
                "risk_limits": self.risk_configs,
                "export_timestamp": datetime.now().isoformat()
            }
            
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, indent=2, ensure_ascii=False)
            
            logger.info(f"ì„¤ì • ë‚´ë³´ë‚´ê¸° ì™„ë£Œ: {file_path}")
            
        except Exception as e:
            logger.error(f"ì„¤ì • ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨: {e}")
            raise
    
    def import_config(self, file_path: str):
        """íŒŒì¼ì—ì„œ ì„¤ì • ê°€ì ¸ì˜¤ê¸°"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                import_data = json.load(f)
            
            # ì„¤ì • ë³µì›
            if "strategies" in import_data:
                self.strategy_configs = import_data["strategies"]
                self.save_strategy_configs()
            
            if "risk_limits" in import_data:
                self.risk_configs = import_data["risk_limits"]
                self.save_risk_configs()
            
            logger.info(f"ì„¤ì • ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ: {file_path}")
            
        except Exception as e:
            logger.error(f"ì„¤ì • ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: {e}")
            raise
    
    def reset_to_defaults(self):
        """ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ì´ˆê¸°í™”"""
        try:
            self.strategy_configs = self.get_default_strategy_configs()
            self.risk_configs = self.get_default_risk_configs()
            
            self.save_strategy_configs()
            self.save_risk_configs()
            
            logger.info("ì„¤ì •ì´ ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”ë¨")
            
        except Exception as e:
            logger.error(f"ì„¤ì • ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            raise

class EnvironmentManager:
    """í™˜ê²½ë³„ ì„¤ì • ê´€ë¦¬"""
    
    def __init__(self):
        self.current_env = os.getenv("ENVIRONMENT", "development")
    
    def get_database_url(self) -> str:
        """í™˜ê²½ë³„ ë°ì´í„°ë² ì´ìŠ¤ URL"""
        if self.current_env == "production":
            return os.getenv("DATABASE_URL", "postgresql://user:pass@localhost/quantrade_prod")
        elif self.current_env == "testing":
            return "sqlite:///:memory:"
        else:  # development
            return "sqlite:///./data/quantrade_dev.db"
    
    def get_log_level(self) -> str:
        """í™˜ê²½ë³„ ë¡œê·¸ ë ˆë²¨"""
        env_log_levels = {
            "production": "WARNING",
            "development": "DEBUG",
            "testing": "ERROR"
        }
        return env_log_levels.get(self.current_env, "INFO")
    
    def is_debug_mode(self) -> bool:
        """ë””ë²„ê·¸ ëª¨ë“œ ì—¬ë¶€"""
        return self.current_env == "development"
    
    def get_api_rate_limit(self) -> int:
        """í™˜ê²½ë³„ API ìš”ì²­ ì œí•œ"""
        if self.current_env == "production":
            return 30  # ë¶„ë‹¹ 30íšŒ
        else:
            return 100  # ê°œë°œ/í…ŒìŠ¤íŠ¸ í™˜ê²½ì—ì„œëŠ” ë” ë§ì´ í—ˆìš©

class ConfigValidator:
    """ì„¤ì • ìœ íš¨ì„± ê²€ì¦ í´ë˜ìŠ¤"""
    
    @staticmethod
    def validate_strategy_config(config: Dict[str, Any]) -> Dict[str, Any]:
        """ì „ëµ ì„¤ì • ìœ íš¨ì„± ê²€ì‚¬"""
        result = {"valid": True, "errors": []}
        
        # í•„ìˆ˜ í•„ë“œ ì²´í¬
        required_fields = ["name", "parameters", "target_stocks", "investment_amount"]
        for field in required_fields:
            if field not in config:
                result["errors"].append(f"í•„ìˆ˜ í•„ë“œ ëˆ„ë½: {field}")
                result["valid"] = False
        
        # íˆ¬ì ê¸ˆì•¡ ì²´í¬
        investment_amount = config.get("investment_amount", 0)
        if investment_amount <= 0:
            result["errors"].append("íˆ¬ì ê¸ˆì•¡ì€ 0ë³´ë‹¤ ì»¤ì•¼ í•¨")
            result["valid"] = False
        
        # ëŒ€ìƒ ì¢…ëª© ì²´í¬
        target_stocks = config.get("target_stocks", [])
        if not target_stocks:
            result["errors"].append("ëŒ€ìƒ ì¢…ëª©ì´ ì—†ìŒ")
            result["valid"] = False
        
        return result
    
    @staticmethod
    def validate_risk_config(config: Dict[str, Any]) -> Dict[str, Any]:
        """ë¦¬ìŠ¤í¬ ì„¤ì • ìœ íš¨ì„± ê²€ì‚¬"""
        result = {"valid": True, "errors": []}
        
        # ì†ì‹¤ í•œë„ ì²´í¬
        daily_loss = config.get("daily_limits", {}).get("max_daily_loss", 0)
        if daily_loss >= 0:
            result["errors"].append("ì¼ì¼ ì†ì‹¤ í•œë„ëŠ” ìŒìˆ˜ì—¬ì•¼ í•¨")
            result["valid"] = False
        
        # í¬ì§€ì…˜ í•œë„ ì²´í¬
        position_limits = config.get("position_limits", {})
        max_position_size = position_limits.get("max_position_size", 0)
        
        if max_position_size <= 0 or max_position_size > 1:
            result["errors"].append("í¬ì§€ì…˜ í¬ê¸° í•œë„ëŠ” 0ê³¼ 1 ì‚¬ì´ì—¬ì•¼ í•¨")
            result["valid"] = False
        
        return result

# ì „ì—­ ì„¤ì • ì¸ìŠ¤í„´ìŠ¤
_config_manager = None
_settings = None

def get_config_manager() -> ConfigManager:
    """ì„¤ì • ê´€ë¦¬ì ì‹±ê¸€í†¤"""
    global _config_manager
    if _config_manager is None:
        _config_manager = ConfigManager()
    return _config_manager

def get_settings() -> Settings:
    """ì„¤ì • ì‹±ê¸€í†¤"""
    global _settings
    if _settings is None:
        _settings = Settings()
    return _settings

def reload_config():
    """ì„¤ì • ë‹¤ì‹œ ë¡œë“œ"""
    global _config_manager, _settings
    _config_manager = None
    _settings = None
    logger.info("ì„¤ì •ì´ ë‹¤ì‹œ ë¡œë“œë¨")

# í™˜ê²½ë³„ ì„¤ì • ë¡œë“œ
def load_environment_config():
    """í™˜ê²½ë³„ ì„¤ì • ë¡œë“œ"""
    env_manager = EnvironmentManager()
    settings = get_settings()
    
    # í™˜ê²½ë³„ ì„¤ì • ì ìš©
    if hasattr(settings, 'database_url'):
        settings.database_url = env_manager.get_database_url()
    
    settings.debug = env_manager.is_debug_mode()
    settings.log_level = env_manager.get_log_level()
    
    return settings 



==================================================
File: C:\Aproject\test\quant_actual\backend\utils\logger.py
==================================================
# file: backend/utils/logger.py

import logging
import logging.handlers
import sys
from pathlib import Path
from typing import Optional
from datetime import datetime
import json
import traceback

class ColoredFormatter(logging.Formatter):
    """ì»¬ëŸ¬ ë¡œê·¸ í¬ë§¤í„°"""
    
    # ìƒ‰ìƒ ì½”ë“œ
    COLORS = {
        'DEBUG': '\033[36m',     # ì²­ë¡
        'INFO': '\033[32m',      # ë…¹ìƒ‰
        'WARNING': '\033[33m',   # ë…¸ë€ìƒ‰
        'ERROR': '\033[31m',     # ë¹¨ê°„ìƒ‰
        'CRITICAL': '\033[35m',  # ìí™ìƒ‰
        'RESET': '\033[0m'       # ë¦¬ì…‹
    }
    
    def format(self, record):
        # ê¸°ë³¸ í¬ë§·íŒ…
        log_message = super().format(record)
        
        # ìƒ‰ìƒ ì ìš©
        color = self.COLORS.get(record.levelname, self.COLORS['RESET'])
        reset = self.COLORS['RESET']
        
        return f"{color}{log_message}{reset}"

class JSONFormatter(logging.Formatter):
    """JSON ë¡œê·¸ í¬ë§¤í„°"""
    
    def format(self, record):
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'level': record.levelname,
            'logger': record.name,
            'message': record.getMessage(),
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno,
            'process_id': record.process,
            'thread_id': record.thread
        }
        
        # ì˜ˆì™¸ ì •ë³´ ì¶”ê°€
        if record.exc_info:
            log_data['exception'] = {
                'type': record.exc_info[0].__name__,
                'message': str(record.exc_info[1]),
                'traceback': traceback.format_exception(*record.exc_info)
            }
        
        # ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸ ì •ë³´
        if hasattr(record, 'extra_data'):
            log_data['extra'] = record.extra_data
        
        return json.dumps(log_data, ensure_ascii=False)

class TradingLogFilter(logging.Filter):
    """íŠ¸ë ˆì´ë”© ê´€ë ¨ ë¡œê·¸ í•„í„°"""
    
    def __init__(self, include_trading_only=False):
        super().__init__()
        self.include_trading_only = include_trading_only
        
        # íŠ¸ë ˆì´ë”© ê´€ë ¨ ëª¨ë“ˆ ëª©ë¡
        self.trading_modules = [
            'trading.engine',
            'trading.strategies', 
            'trading.risk_manager',
            'data.kiwoom_mock',
            'api'
        ]
    
    def filter(self, record):
        is_trading_log = any(
            module in record.name 
            for module in self.trading_modules
        )
        
        if self.include_trading_only:
            return is_trading_log
        else:
            return True  # ëª¨ë“  ë¡œê·¸ í—ˆìš©

class DatabaseLogHandler(logging.Handler):
    """ë°ì´í„°ë² ì´ìŠ¤ ë¡œê·¸ í•¸ë“¤ëŸ¬"""
    
    def __init__(self, db_session_factory=None):
        super().__init__()
        self.db_session_factory = db_session_factory
    
    def emit(self, record):
        try:
            if not self.db_session_factory:
                return
            
            # ë¡œê·¸ ë ˆì½”ë“œë¥¼ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” LogEntry ëª¨ë¸ ì‚¬ìš©
            log_entry = {
                'timestamp': datetime.utcnow(),
                'level': record.levelname,
                'logger_name': record.name,
                'message': record.getMessage(),
                'module': record.module,
                'function_name': record.funcName,
                'line_number': record.lineno,
                'exception_info': self.format(record) if record.exc_info else None
            }
            
            # ì‹¤ì œ DB ì €ì¥ ë¡œì§ì€ ì—¬ê¸°ì— êµ¬í˜„
            # with self.db_session_factory() as session:
            #     session.add(LogEntry(**log_entry))
            #     session.commit()
            
        except Exception as e:
            # ë¡œê¹… ì˜¤ë¥˜ëŠ” ë¬´ì‹œ (ë¬´í•œ ë£¨í”„ ë°©ì§€)
            print(f"Database logging error: {e}", file=sys.stderr)

def setup_logger(
    name: Optional[str] = None,
    level: str = "INFO",
    log_file: Optional[str] = None,
    max_size: int = 10485760,  # 10MB
    backup_count: int = 5,
    use_colors: bool = True,
    json_format: bool = False,
    include_trading_only: bool = False
) -> logging.Logger:
    """ë¡œê±° ì„¤ì •"""
    
    logger = logging.getLogger(name)
    
    # ê¸°ì¡´ í•¸ë“¤ëŸ¬ ì œê±° (ì¤‘ë³µ ë°©ì§€)
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)
    
    # ë¡œê·¸ ë ˆë²¨ ì„¤ì •
    logger.setLevel(getattr(logging, level.upper()))
    
    # í¬ë§¤í„° ì„ íƒ
    if json_format:
        formatter = JSONFormatter()
    elif use_colors and sys.stderr.isatty():
        formatter = ColoredFormatter(
            fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
    else:
        formatter = logging.Formatter(
            fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
    
    # ì½˜ì†” í•¸ë“¤ëŸ¬
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    
    # íŠ¸ë ˆì´ë”© ë¡œê·¸ í•„í„° ì ìš©
    if include_trading_only:
        trading_filter = TradingLogFilter(include_trading_only=True)
        console_handler.addFilter(trading_filter)
    
    logger.addHandler(console_handler)
    
    # íŒŒì¼ í•¸ë“¤ëŸ¬ (ì„ íƒì )
    if log_file:
        log_path = Path(log_file)
        log_path.parent.mkdir(parents=True, exist_ok=True)
        
        # ë¡œí…Œì´íŒ… íŒŒì¼ í•¸ë“¤ëŸ¬
        file_handler = logging.handlers.RotatingFileHandler(
            filename=log_file,
            maxBytes=max_size,
            backupCount=backup_count,
            encoding='utf-8'
        )
        
        # íŒŒì¼ì€ í•­ìƒ JSON í¬ë§· ì‚¬ìš©
        file_formatter = JSONFormatter() if json_format else logging.Formatter(
            fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        file_handler.setFormatter(file_formatter)
        
        logger.addHandler(file_handler)
    
    return logger

class LoggerManager:
    """ë¡œê±° ê´€ë¦¬ì"""
    
    def __init__(self):
        self.loggers = {}
        self.handlers = {}
        
        # ê¸°ë³¸ ë¡œê·¸ ë””ë ‰í† ë¦¬ ìƒì„±
        self.log_dir = Path("logs")
        self.log_dir.mkdir(exist_ok=True)
    
    def get_logger(
        self, 
        name: str, 
        level: str = "INFO",
        log_file: Optional[str] = None,
        **kwargs
    ) -> logging.Logger:
        """ë¡œê±° ìƒì„± ë˜ëŠ” ë°˜í™˜"""
        
        if name not in self.loggers:
            if log_file:
                log_file = self.log_dir / log_file
            
            logger = setup_logger(
                name=name,
                level=level,
                log_file=str(log_file) if log_file else None,
                **kwargs
            )
            
            self.loggers[name] = logger
        
        return self.loggers[name]
    
    def get_trading_logger(self) -> logging.Logger:
        """íŠ¸ë ˆì´ë”© ì „ìš© ë¡œê±°"""
        return self.get_logger(
            name="trading",
            level="INFO",
            log_file="trading.log",
            include_trading_only=True
        )
    
    def get_api_logger(self) -> logging.Logger:
        """API ì „ìš© ë¡œê±°"""
        return self.get_logger(
            name="api",
            level="INFO", 
            log_file="api.log"
        )
    
    def get_error_logger(self) -> logging.Logger:
        """ì˜¤ë¥˜ ì „ìš© ë¡œê±°"""
        error_logger = self.get_logger(
            name="errors",
            level="ERROR",
            log_file="errors.log",
            json_format=True
        )
        
        # ì˜¤ë¥˜ ë¡œê±°ëŠ” ERROR ë ˆë²¨ ì´ìƒë§Œ ê¸°ë¡
        error_logger.setLevel(logging.ERROR)
        
        return error_logger
    
    def setup_application_logging(self, config=None):
        """ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì²´ ë¡œê¹… ì„¤ì •"""
        from utils.config import get_settings
        
        settings = get_settings() if not config else config
        
        # ë£¨íŠ¸ ë¡œê±° ì„¤ì •
        root_logger = setup_logger(
            name=None,
            level=settings.log_level,
            log_file=settings.log_file,
            max_size=settings.log_max_size,
            backup_count=settings.log_backup_count,
            use_colors=settings.debug,
            json_format=not settings.debug
        )
        
        # ëª¨ë“ˆë³„ ë¡œê±° ì„¤ì •
        module_loggers = [
            ("trading.engine", "INFO", "trading_engine.log"),
            ("trading.strategies", "INFO", "strategies.log"),
            ("trading.risk_manager", "WARNING", "risk.log"),
            ("data.kiwoom_mock", "INFO", "kiwoom.log"),
            ("database", "WARNING", "database.log"),
            ("api", "INFO", "api.log")
        ]
        
        for module_name, level, log_file in module_loggers:
            self.get_logger(
                name=module_name,
                level=level,
                log_file=log_file
            )
        
        # ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œê¹… ë ˆë²¨ ì¡°ì •
        logging.getLogger("uvicorn").setLevel(logging.WARNING)
        logging.getLogger("fastapi").setLevel(logging.WARNING)
        logging.getLogger("sqlalchemy.engine").setLevel(logging.WARNING)
        
        return root_logger
    
    def add_performance_logging(self):
        """ì„±ëŠ¥ ë¡œê¹… ì¶”ê°€"""
        perf_logger = self.get_logger(
            name="performance",
            level="INFO",
            log_file="performance.log",
            json_format=True
        )
        
        return perf_logger
    
    def add_audit_logging(self):
        """ê°ì‚¬ ë¡œê¹… ì¶”ê°€ (ì¤‘ìš”í•œ ê±°ë˜ í™œë™ ê¸°ë¡)"""
        audit_logger = self.get_logger(
            name="audit",
            level="INFO",
            log_file="audit.log",
            json_format=True
        )
        
        # ê°ì‚¬ ë¡œê·¸ëŠ” ë³„ë„ í¬ë§¤í„° ì‚¬ìš©
        audit_formatter = logging.Formatter(
            fmt='%(asctime)s [AUDIT] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        for handler in audit_logger.handlers:
            if isinstance(handler, logging.FileHandler):
                handler.setFormatter(audit_formatter)
        
        return audit_logger

class AuditLogger:
    """ê°ì‚¬ ë¡œê¹… ì „ìš© í´ë˜ìŠ¤"""
    
    def __init__(self, logger_manager: LoggerManager):
        self.audit_logger = logger_manager.add_audit_logging()
    
    def log_order(self, order_data: dict):
        """ì£¼ë¬¸ ë¡œê¹…"""
        self.audit_logger.info(
            f"ORDER - {order_data.get('action', 'UNKNOWN')} "
            f"{order_data.get('stock_code', 'N/A')} "
            f"{order_data.get('quantity', 0)} shares "
            f"@ {order_data.get('price', 0)} "
            f"({order_data.get('strategy', 'manual')})"
        )
    
    def log_trade(self, trade_data: dict):
        """ê±°ë˜ ì²´ê²° ë¡œê¹…"""
        self.audit_logger.info(
            f"TRADE - {trade_data.get('action', 'UNKNOWN')} "
            f"{trade_data.get('stock_code', 'N/A')} "
            f"{trade_data.get('quantity', 0)} shares "
            f"@ {trade_data.get('price', 0)} "
            f"PnL: {trade_data.get('pnl', 0)}"
        )
    
    def log_risk_event(self, event_type: str, details: dict):
        """ë¦¬ìŠ¤í¬ ì´ë²¤íŠ¸ ë¡œê¹…"""
        self.audit_logger.warning(
            f"RISK_EVENT - {event_type}: {details}"
        )
    
    def log_system_event(self, event_type: str, details: dict):
        """ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ ë¡œê¹…"""
        self.audit_logger.info(
            f"SYSTEM - {event_type}: {details}"
        )

class PerformanceLogger:
    """ì„±ëŠ¥ ë¡œê¹… ì „ìš© í´ë˜ìŠ¤"""
    
    def __init__(self, logger_manager: LoggerManager):
        self.perf_logger = logger_manager.add_performance_logging()
    
    def log_execution_time(self, function_name: str, execution_time: float, **kwargs):
        """í•¨ìˆ˜ ì‹¤í–‰ ì‹œê°„ ë¡œê¹…"""
        self.perf_logger.info(
            f"PERFORMANCE - {function_name}: {execution_time:.4f}s",
            extra={'extra_data': {'execution_time': execution_time, **kwargs}}
        )
    
    def log_memory_usage(self, context: str, memory_mb: float):
        """ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë¡œê¹…"""
        self.perf_logger.info(
            f"MEMORY - {context}: {memory_mb:.2f}MB",
            extra={'extra_data': {'memory_mb': memory_mb}}
        )
    
    def log_api_response_time(self, endpoint: str, response_time: float, status_code: int):
        """API ì‘ë‹µ ì‹œê°„ ë¡œê¹…"""
        self.perf_logger.info(
            f"API - {endpoint}: {response_time:.4f}s (status: {status_code})",
            extra={'extra_data': {
                'endpoint': endpoint,
                'response_time': response_time,
                'status_code': status_code
            }}
        )

def performance_monitor(func):
    """ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë°ì½”ë ˆì´í„°"""
    import time
    import functools
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        
        try:
            result = func(*args, **kwargs)
            execution_time = time.time() - start_time
            
            # ì„±ëŠ¥ ë¡œê·¸ ê¸°ë¡
            perf_logger = logging.getLogger("performance")
            perf_logger.info(
                f"Function {func.__name__} executed in {execution_time:.4f}s"
            )
            
            return result
            
        except Exception as e:
            execution_time = time.time() - start_time
            
            # ì˜¤ë¥˜ì™€ í•¨ê»˜ ì„±ëŠ¥ ì •ë³´ ê¸°ë¡
            error_logger = logging.getLogger("errors")
            error_logger.error(
                f"Function {func.__name__} failed after {execution_time:.4f}s: {e}",
                exc_info=True
            )
            
            raise
    
    return wrapper

# ì „ì—­ ë¡œê±° ë§¤ë‹ˆì €
_logger_manager = None

def get_logger_manager() -> LoggerManager:
    """ë¡œê±° ë§¤ë‹ˆì € ì‹±ê¸€í†¤"""
    global _logger_manager
    if _logger_manager is None:
        _logger_manager = LoggerManager()
    return _logger_manager

def get_logger(name: str = None) -> logging.Logger:
    """í¸ì˜ í•¨ìˆ˜: ë¡œê±° ë°˜í™˜"""
    if name:
        return logging.getLogger(name)
    else:
        return logging.getLogger()

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì‹œ í˜¸ì¶œ
def initialize_logging():
    """ë¡œê¹… ì‹œìŠ¤í…œ ì´ˆê¸°í™”"""
    logger_manager = get_logger_manager()
    return logger_manager.setup_application_logging() 



==================================================
File: C:\Aproject\test\quant_actual\backend\utils\__init__.py
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\next.config.js
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\tailwind.config.js
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\app\layout.tsx
==================================================
# layout.tsx

import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'QuanTrade Pro - í€€íŠ¸ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ',
  description: 'ì‹¤ì‹œê°„ í€€íŠ¸ ìë™ë§¤ë§¤ ëŒ€ì‹œë³´ë“œ',
  keywords: 'í€€íŠ¸, ìë™ë§¤ë§¤, ì£¼ì‹, íŠ¸ë ˆì´ë”©, ëŒ€ì‹œë³´ë“œ',
  authors: [{ name: 'QuanTrade Team' }],
  viewport: 'width=device-width, initial-scale=1',
  robots: 'noindex, nofollow', // ë³´ì•ˆìƒ ê²€ìƒ‰ì—”ì§„ ì°¨ë‹¨
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="ko" className="dark">
      <head>
        <meta name="theme-color" content="#111827" />
        <link rel="icon" href="/favicon.ico" />
      </head>
      <body className={`${inter.className} bg-gray-900 text-white antialiased`}>
        <div id="root">
          {children}
        </div>
      </body>
    </html>
  )
} 



==================================================
File: C:\Aproject\test\quant_actual\frontend\app\page.tsx
==================================================
'use client'

import { useEffect, useState } from 'react'
import { formatCurrency, formatPercentage, getCurrentTime } from '@/lib/utils'

interface PortfolioData {
  total_value: number
  cash: number
  invested_amount: number
  realized_pnl: number
  unrealized_pnl: number
  daily_pnl: number
  total_return: number
  timestamp: string
}

interface Position {
  id: number
  strategy_name: string
  stock_code: string
  stock_name: string
  quantity: number
  avg_price: number
  current_price: number
  unrealized_pnl: number
  realized_pnl: number
}

interface Order {
  id: number
  strategy_id: number
  stock_code: string
  stock_name: string
  order_type: string
  quantity: number
  price: number
  status: string
  order_time: string
  fill_time?: string
  fill_price?: number
}

interface Strategy {
  id: number
  name: string
  strategy_type: string
  is_active: boolean
  investment_amount: number
  target_stocks: string[]
  parameters: Record<string, any>
}

export default function DashboardPage() {
  const [portfolio, setPortfolio] = useState<PortfolioData | null>(null)
  const [positions, setPositions] = useState<Position[]>([])
  const [orders, setOrders] = useState<Order[]>([])
  const [strategies, setStrategies] = useState<Strategy[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [lastUpdate, setLastUpdate] = useState<string>('')
  const [isConnected, setIsConnected] = useState(true)
  const [tradingStatus, setTradingStatus] = useState('stopped')

  // ì‹¤ì‹œê°„ ë°ì´í„° ì—…ë°ì´íŠ¸
  useEffect(() => {
    const fetchData = async () => {
      try {
        // í¬íŠ¸í´ë¦¬ì˜¤ ë°ì´í„°
        const portfolioRes = await fetch('/api/proxy/portfolio')
        const portfolioData = await portfolioRes.json()
        setPortfolio(portfolioData)

        // í¬ì§€ì…˜ ë°ì´í„°
        const positionsRes = await fetch('/api/proxy/portfolio/positions')
        const positionsData = await positionsRes.json()
        setPositions(positionsData)

        // ì£¼ë¬¸ ë‚´ì—­
        const ordersRes = await fetch('/api/proxy/orders?limit=10')
        const ordersData = await ordersRes.json()
        setOrders(ordersData)

        // ì „ëµ ëª©ë¡
        const strategiesRes = await fetch('/api/proxy/strategies')
        const strategiesData = await strategiesRes.json()
        setStrategies(strategiesData)

        // ì‹œìŠ¤í…œ ìƒíƒœ
        const statusRes = await fetch('/api/proxy/system/status')
        const statusData = await statusRes.json()
        setIsConnected(statusData.api_connected)
        setTradingStatus(statusData.is_running ? 'running' : 'stopped')

        setLastUpdate(getCurrentTime())
        setError(null)
      } catch (err) {
        setError('ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨')
        console.error('Data fetch error:', err)
      } finally {
        setIsLoading(false)
      }
    }

    // ì´ˆê¸° ë¡œë“œ
    fetchData()

    // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ (1ì´ˆë§ˆë‹¤)
    const interval = setInterval(fetchData, 1000)
    return () => clearInterval(interval)
  }, [])

  // ì „ëµ í† ê¸€
  const toggleStrategy = async (strategyId: number) => {
    try {
      const strategy = strategies.find(s => s.id === strategyId)
      if (!strategy) return

      const response = await fetch('/api/proxy/strategies/toggle', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          id: strategyId,
          active: !strategy.is_active
        })
      })

      if (response.ok) {
        setStrategies(prev =>
          prev.map(s =>
            s.id === strategyId ? { ...s, is_active: !s.is_active } : s
          )
        )
      }
    } catch (error) {
      console.error('ì „ëµ í† ê¸€ ì‹¤íŒ¨:', error)
    }
  }

  // íŠ¸ë ˆì´ë”© ì œì–´
  const startTrading = async () => {
    try {
      const response = await fetch('/api/proxy/trading/start', { method: 'POST' })
      if (response.ok) {
        setTradingStatus('running')
        alert('ìë™ë§¤ë§¤ê°€ ì‹œì‘ë©ë‹ˆë‹¤.')
      }
    } catch (error) {
      console.error('ìë™ë§¤ë§¤ ì‹œì‘ ì‹¤íŒ¨:', error)
    }
  }

  const stopTrading = async () => {
    try {
      const response = await fetch('/api/proxy/trading/stop', { method: 'POST' })
      if (response.ok) {
        setTradingStatus('stopped')
        alert('ìë™ë§¤ë§¤ê°€ ì¤‘ì§€ë©ë‹ˆë‹¤.')
      }
    } catch (error) {
      console.error('ìë™ë§¤ë§¤ ì¤‘ì§€ ì‹¤íŒ¨:', error)
    }
  }

  const emergencyStop = async () => {
    if (confirm('ëª¨ë“  ì£¼ë¬¸ì„ ì·¨ì†Œí•˜ê³  ê¸´ê¸‰ì¤‘ë‹¨í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
      try {
        const response = await fetch('/api/proxy/trading/emergency-stop', { method: 'POST' })
        if (response.ok) {
          setTradingStatus('emergency_stopped')
          alert('ê¸´ê¸‰ì¤‘ë‹¨ ì‹¤í–‰ë¨')
        }
      } catch (error) {
        console.error('ê¸´ê¸‰ì¤‘ë‹¨ ì‹¤íŒ¨:', error)
      }
    }
  }

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-white text-xl">ì‹œìŠ¤í…œ ë¡œë”© ì¤‘...</div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-red-400 text-xl">{error}</div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gray-900 text-white">
      {/* í—¤ë” */}
      <header className="bg-gray-800 px-6 py-4 flex items-center justify-between border-b border-gray-700">
        <div className="flex items-center space-x-4">
          <h1 className="text-2xl font-bold text-green-400">QuanTrade Pro</h1>
          <div className="flex items-center space-x-2">
            <span className="text-sm">í‚¤ì›€ API</span>
            <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-400 animate-pulse' : 'bg-red-400'}`}></div>
            <span className="text-sm">{isConnected ? 'ì—°ê²°ë¨' : 'ì—°ê²° ëŠê¹€'}</span>
          </div>
        </div>

        <div className="flex items-center space-x-2">
          <span className="text-sm text-gray-400">ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: {lastUpdate}</span>
        </div>

        <div className="flex space-x-2">
          <button
            onClick={startTrading}
            disabled={tradingStatus === 'running'}
            className="bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white px-4 py-2 rounded text-sm font-medium transition-colors"
          >
            ìë™ë§¤ë§¤ ì‹œì‘
          </button>
          <button
            onClick={stopTrading}
            disabled={tradingStatus === 'stopped'}
            className="bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white px-4 py-2 rounded text-sm font-medium transition-colors"
          >
            ì¤‘ì§€
          </button>
          <button
            onClick={emergencyStop}
            className="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded text-sm font-medium animate-pulse transition-colors"
          >
            ê¸´ê¸‰ì¤‘ë‹¨
          </button>
        </div>
      </header>

      <div className="flex h-[calc(100vh-80px)]">
        {/* ì‚¬ì´ë“œë°” - ì „ëµ ê´€ë¦¬ */}
        <div className="w-80 bg-gray-800 p-6 overflow-y-auto border-r border-gray-700">
          <h2 className="text-lg font-semibold mb-4 text-gray-300">í™œì„± ì „ëµ</h2>
          
          <div className="space-y-4">
            {strategies.map(strategy => (
              <div key={strategy.id} className="bg-gray-700 p-4 rounded-lg">
                <div className="flex items-center justify-between mb-3">
                  <h3 className="font-medium text-white">{strategy.name}</h3>
                  <button
                    onClick={() => toggleStrategy(strategy.id)}
                    className={`relative w-12 h-6 rounded-full transition-colors ${
                      strategy.is_active ? 'bg-green-500' : 'bg-gray-500'
                    }`}
                  >
                    <div
                      className={`absolute top-1 w-4 h-4 bg-white rounded-full transition-transform ${
                        strategy.is_active ? 'translate-x-7' : 'translate-x-1'
                      }`}
                    ></div>
                  </button>
                </div>
                
                <div className="text-sm text-gray-300 space-y-1">
                  <div>íˆ¬ìê¸ˆì•¡: {formatCurrency(strategy.investment_amount)}</div>
                  <div>ëŒ€ìƒì¢…ëª©: {strategy.target_stocks?.join(', ') || 'N/A'}</div>
                  <div className={`inline-block px-2 py-1 rounded text-xs ${
                    strategy.is_active 
                      ? 'bg-green-900 text-green-300' 
                      : 'bg-gray-600 text-gray-400'
                  }`}>
                    {strategy.is_active ? 'í™œì„±' : 'ë¹„í™œì„±'}
                  </div>
                </div>
              </div>
            ))}
          </div>

          {/* ë¦¬ìŠ¤í¬ ê´€ë¦¬ */}
          <div className="mt-8">
            <h3 className="text-lg font-semibold mb-4 text-gray-300">ë¦¬ìŠ¤í¬ ê´€ë¦¬</h3>
            <div className="space-y-3 text-sm">
              <div className="flex justify-between">
                <span className="text-gray-400">ì¼ì¼ ì†ì‹¤í•œë„:</span>
                <span className="text-red-400">-2%</span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-400">í¬ì§€ì…˜ í¬ê¸°:</span>
                <span className="text-blue-400">5%</span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-400">ìµœëŒ€ ë³´ìœ ì¢…ëª©:</span>
                <span className="text-blue-400">10ê°œ</span>
              </div>
            </div>
          </div>
        </div>

        {/* ë©”ì¸ ì½˜í…ì¸  */}
        <div className="flex-1 flex flex-col">
          {/* í¬íŠ¸í´ë¦¬ì˜¤ ê°œìš” */}
          <div className="bg-gray-800 p-6 border-b border-gray-700">
            <div className="grid grid-cols-4 gap-6">
              <div className="bg-gray-700 p-4 rounded-lg text-center">
                <div className="text-sm text-gray-400 mb-1">ì´ í‰ê°€ê¸ˆì•¡</div>
                <div className="text-2xl font-bold text-white">
                  {formatCurrency(portfolio?.total_value || 0)}
                </div>
                <div className="text-sm text-green-400">
                  +{formatCurrency(portfolio?.daily_pnl || 0)}
                </div>
              </div>

              <div className="bg-gray-700 p-4 rounded-lg text-center">
                <div className="text-sm text-gray-400 mb-1">ì‹¤ì‹œê°„ ì†ìµ</div>
                <div className={`text-2xl font-bold ${
                  (portfolio?.unrealized_pnl || 0) >= 0 ? 'text-green-400' : 'text-red-400'
                }`}>
                  {formatCurrency(portfolio?.unrealized_pnl || 0)}
                </div>
                <div className="text-sm text-gray-400">
                  ì‹¤í˜„: {formatCurrency(portfolio?.realized_pnl || 0)}
                </div>
              </div>

              <div className="bg-gray-700 p-4 rounded-lg text-center">
                <div className="text-sm text-gray-400 mb-1">ìˆ˜ìµë¥ </div>
                <div className={`text-2xl font-bold ${
                  (portfolio?.total_return || 0) >= 0 ? 'text-green-400' : 'text-red-400'
                }`}>
                  {formatPercentage(portfolio?.total_return || 0)}
                </div>
                <div className="text-sm text-gray-400">
                  {(portfolio?.total_return || 0) >= 0 ? '+' : ''}{((portfolio?.daily_pnl || 0) / (portfolio?.total_value || 1) * 100).toFixed(1)}% (ì˜¤ëŠ˜)
                </div>
              </div>

              <div className="bg-gray-700 p-4 rounded-lg text-center">
                <div className="text-sm text-gray-400 mb-1">í™œì„± í¬ì§€ì…˜</div>
                <div className="text-2xl font-bold text-white">{positions.length}ê°œ</div>
                <div className="text-sm text-gray-400">
                  íˆ¬ì: {formatCurrency(portfolio?.invested_amount || 0)}
                </div>
              </div>
            </div>
          </div>

          {/* ì‹¤ì‹œê°„ ìˆ˜ìµ ë° í¬ì§€ì…˜ */}
          <div className="flex-1 flex">
            {/* ì‹¤ì‹œê°„ ìˆ˜ìµ í˜„í™© */}
            <div className="flex-1 p-6">
              <div className="bg-gray-700 rounded-lg p-4 h-full">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-lg font-semibold">ì‹¤ì‹œê°„ ìˆ˜ìµ í˜„í™©</h3>
                  <div className="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>
                </div>

                <div className="space-y-3 max-h-96 overflow-y-auto">
                  {positions.map(position => (
                    <div key={position.id} className="bg-gray-600 p-3 rounded flex items-center justify-between">
                      <div className="flex-1">
                        <div className="font-medium">{position.strategy_name} - {position.stock_name}</div>
                        <div className="text-sm text-gray-400">
                          {position.stock_code} | {position.quantity}ì£¼ @ {formatCurrency(position.avg_price)}
                        </div>
                      </div>
                      <div className="text-right">
                        <div className={`font-bold ${
                          position.unrealized_pnl >= 0 ? 'text-green-400' : 'text-red-400'
                        }`}>
                          {position.unrealized_pnl >= 0 ? '+' : ''}{formatCurrency(position.unrealized_pnl)}
                        </div>
                        <div className={`text-sm ${
                          position.unrealized_pnl >= 0 ? 'text-green-400' : 'text-red-400'
                        }`}>
                          {position.unrealized_pnl >= 0 ? '+' : ''}{formatPercentage(
                            ((position.current_price - position.avg_price) / position.avg_price) * 100
                          )}
                        </div>
                      </div>
                    </div>
                  ))}

                  {positions.length === 0 && (
                    <div className="text-center text-gray-400 py-8">
                      í˜„ì¬ ë³´ìœ  í¬ì§€ì…˜ì´ ì—†ìŠµë‹ˆë‹¤
                    </div>
                  )}
                </div>
              </div>
            </div>

            {/* ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­ */}
            <div className="w-96 p-6 pl-0">
              <div className="bg-gray-700 rounded-lg p-4 h-full">
                <h3 className="text-lg font-semibold mb-4">ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­</h3>
                
                <div className="space-y-2 max-h-96 overflow-y-auto">
                  {orders.map(order => (
                    <div key={order.id} className="bg-gray-600 p-3 rounded text-sm">
                      <div className="flex items-center justify-between mb-1">
                        <span className="font-medium">{order.stock_name}</span>
                        <span className={`px-2 py-1 rounded text-xs ${
                          order.order_type === 'buy' 
                            ? 'bg-blue-900 text-blue-300' 
                            : 'bg-red-900 text-red-300'
                        }`}>
                          {order.order_type === 'buy' ? 'ë§¤ìˆ˜' : 'ë§¤ë„'}
                        </span>
                      </div>
                      <div className="text-gray-400">
                        {order.quantity}ì£¼ @ {formatCurrency(order.price)}
                      </div>
                      <div className="flex items-center justify-between mt-1">
                        <span className={`text-xs px-2 py-1 rounded ${
                          order.status === 'filled' 
                            ? 'bg-green-900 text-green-300'
                            : order.status === 'pending'
                            ? 'bg-yellow-900 text-yellow-300'
                            : 'bg-gray-900 text-gray-400'
                        }`}>
                          {order.status === 'filled' ? 'ì²´ê²°' : 
                           order.status === 'pending' ? 'ëŒ€ê¸°' : 'ì·¨ì†Œ'}
                        </span>
                        <span className="text-xs text-gray-500">
                          {new Date(order.order_time).toLocaleTimeString('ko-KR')}
                        </span>
                      </div>
                    </div>
                  ))}

                  {orders.length === 0 && (
                    <div className="text-center text-gray-400 py-8">
                      ì£¼ë¬¸ ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
} 



==================================================
File: C:\Aproject\test\quant_actual\frontend\app\api\proxy\[...path]\route.ts
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\components\dashboard.tsx
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\lib\api.ts
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\lib\types.ts
==================================================
 



==================================================
File: C:\Aproject\test\quant_actual\frontend\lib\utils.ts
==================================================
// utils.ts

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

// ìˆ«ì í¬ë§·íŒ… í•¨ìˆ˜ë“¤
export function formatCurrency(amount: number): string {
  if (amount === 0) return 'â‚©0'
  
  const isNegative = amount < 0
  const absAmount = Math.abs(amount)
  
  let formatted: string
  
  if (absAmount >= 100000000) {
    // 1ì–µ ì´ìƒ
    formatted = `â‚©${(absAmount / 100000000).toFixed(1)}ì–µ`
  } else if (absAmount >= 10000) {
    // 1ë§Œ ì´ìƒ
    formatted = `â‚©${(absAmount / 10000).toFixed(1)}ë§Œ`
  } else {
    // 1ë§Œ ë¯¸ë§Œ
    formatted = `â‚©${absAmount.toLocaleString()}`
  }
  
  return isNegative ? `-${formatted}` : formatted
}

export function formatNumber(num: number): string {
  return num.toLocaleString()
}

export function formatPercentage(percentage: number): string {
  const sign = percentage >= 0 ? '+' : ''
  return `${sign}${percentage.toFixed(2)}%`
}

export function formatDecimal(num: number, decimals: number = 2): string {
  return num.toFixed(decimals)
}

// ì‹œê°„ í¬ë§·íŒ… í•¨ìˆ˜ë“¤
export function formatTime(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date
  return d.toLocaleTimeString('ko-KR', { 
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  })
}

export function formatDate(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date
  return d.toLocaleDateString('ko-KR', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit'
  })
}

export function formatDateTime(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date
  return `${formatDate(d)} ${formatTime(d)}`
}

export function getCurrentTime(): string {
  return formatTime(new Date())
}

export function getTimeAgo(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date
  const now = new Date()
  const diffMs = now.getTime() - d.getTime()
  const diffSec = Math.floor(diffMs / 1000)
  const diffMin = Math.floor(diffSec / 60)
  const diffHour = Math.floor(diffMin / 60)
  const diffDay = Math.floor(diffHour / 24)
  
  if (diffSec < 60) return `${diffSec}ì´ˆ ì „`
  if (diffMin < 60) return `${diffMin}ë¶„ ì „`
  if (diffHour < 24) return `${diffHour}ì‹œê°„ ì „`
  if (diffDay < 7) return `${diffDay}ì¼ ì „`
  
  return formatDate(d)
}

// ë°ì´í„° ê²€ì¦ í•¨ìˆ˜ë“¤
export function isValidPrice(price: number): boolean {
  return price > 0 && price < 1000000000 && Number.isFinite(price)
}

export function isValidQuantity(quantity: number): boolean {
  return Number.isInteger(quantity) && quantity > 0 && quantity <= 10000000
}

export function isValidPercentage(percentage: number): boolean {
  return Number.isFinite(percentage) && percentage >= -100 && percentage <= 1000
}

// ìƒ‰ìƒ ê´€ë ¨ í•¨ìˆ˜ë“¤
export function getPnLColor(value: number): string {
  if (value > 0) return 'text-green-400'
  if (value < 0) return 'text-red-400'
  return 'text-gray-400'
}

export function getPnLBgColor(value: number): string {
  if (value > 0) return 'bg-green-900'
  if (value < 0) return 'bg-red-900'
  return 'bg-gray-700'
}

export function getChangeColor(current: number, previous: number): string {
  if (current > previous) return 'text-green-400'
  if (current < previous) return 'text-red-400'
  return 'text-gray-400'
}

// ê³„ì‚° ê´€ë ¨ í•¨ìˆ˜ë“¤
export function calculatePnL(currentPrice: number, avgPrice: number, quantity: number): number {
  return (currentPrice - avgPrice) * quantity
}

export function calculatePnLPercentage(currentPrice: number, avgPrice: number): number {
  return ((currentPrice - avgPrice) / avgPrice) * 100
}

export function calculateTotalValue(positions: Array<{current_price: number, quantity: number}>): number {
  return positions.reduce((total, pos) => total + (pos.current_price * pos.quantity), 0)
}

export function calculateWeightedAverage(prices: number[], weights: number[]): number {
  if (prices.length !== weights.length || prices.length === 0) return 0
  
  const totalWeight = weights.reduce((sum, w) => sum + w, 0)
  if (totalWeight === 0) return 0
  
  const weightedSum = prices.reduce((sum, price, i) => sum + (price * weights[i]), 0)
  return weightedSum / totalWeight
}

// ë°°ì—´ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
export function sortByField<T>(array: T[], field: keyof T, ascending: boolean = true): T[] {
  return [...array].sort((a, b) => {
    const aVal = a[field]
    const bVal = b[field]
    
    if (aVal < bVal) return ascending ? -1 : 1
    if (aVal > bVal) return ascending ? 1 : -1
    return 0
  })
}

export function groupBy<T>(array: T[], keyFn: (item: T) => string): Record<string, T[]> {
  return array.reduce((groups, item) => {
    const key = keyFn(item)
    if (!groups[key]) groups[key] = []
    groups[key].push(item)
    return groups
  }, {} as Record<string, T[]>)
}

export function uniqueBy<T>(array: T[], keyFn: (item: T) => any): T[] {
  const seen = new Set()
  return array.filter(item => {
    const key = keyFn(item)
    if (seen.has(key)) return false
    seen.add(key)
    return true
  })
}

// ë¬¸ìì—´ ìœ í‹¸ë¦¬í‹°
export function truncateString(str: string, maxLength: number): string {
  if (str.length <= maxLength) return str
  return str.slice(0, maxLength - 3) + '...'
}

export function capitalizeFirst(str: string): string {
  if (!str) return str
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()
}

export function formatStockCode(code: string): string {
  // ì¢…ëª©ì½”ë“œë¥¼ 6ìë¦¬ë¡œ í¬ë§· (ì˜ˆ: 5930 -> 005930)
  return code.padStart(6, '0')
}

// API ê´€ë ¨ ìœ í‹¸ë¦¬í‹°
export function buildQueryString(params: Record<string, any>): string {
  const searchParams = new URLSearchParams()
  
  Object.entries(params).forEach(([key, value]) => {
    if (value != null && value !== '') {
      searchParams.append(key, String(value))
    }
  })
  
  const queryString = searchParams.toString()
  return queryString ? `?${queryString}` : ''
}

export function handleApiError(error: any): string {
  if (error?.response?.data?.detail) {
    return error.response.data.detail
  }
  if (error?.message) {
    return error.message
  }
  return 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤'
}

// ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ìœ í‹¸ë¦¬í‹° (ë¸Œë¼ìš°ì € í™˜ê²½ì—ì„œë§Œ ì‚¬ìš©)
export function setLocalStorage(key: string, value: any): void {
  if (typeof window !== 'undefined') {
    try {
      localStorage.setItem(key, JSON.stringify(value))
    } catch (error) {
      console.warn('localStorage ì €ì¥ ì‹¤íŒ¨:', error)
    }
  }
}

export function getLocalStorage<T>(key: string, defaultValue: T): T {
  if (typeof window !== 'undefined') {
    try {
      const item = localStorage.getItem(key)
      return item ? JSON.parse(item) : defaultValue
    } catch (error) {
      console.warn('localStorage ì½ê¸° ì‹¤íŒ¨:', error)
      return defaultValue
    }
  }
  return defaultValue
}

export function removeLocalStorage(key: string): void {
  if (typeof window !== 'undefined') {
    try {
      localStorage.removeItem(key)
    } catch (error) {
      console.warn('localStorage ì‚­ì œ ì‹¤íŒ¨:', error)
    }
  }
}

// ë””ë°”ìš´ì‹± í•¨ìˆ˜
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null
  
  return (...args: Parameters<T>) => {
    if (timeout) clearTimeout(timeout)
    
    timeout = setTimeout(() => {
      func(...args)
    }, wait)
  }
}

// ì“°ë¡œí‹€ë§ í•¨ìˆ˜
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean = false
  
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}

// ëœë¤ ìœ í‹¸ë¦¬í‹°
export function randomBetween(min: number, max: number): number {
  return Math.random() * (max - min) + min
}

export function randomInt(min: number, max: number): number {
  return Math.floor(randomBetween(min, max + 1))
}

export function generateId(): string {
  return Math.random().toString(36).substring(2) + Date.now().toString(36)
}

// ìƒíƒœ ê´€ë¦¬ ìœ í‹¸ë¦¬í‹°
export function createInitialState<T>(defaults: T): T {
  return { ...defaults }
}

export function updateState<T>(currentState: T, updates: Partial<T>): T {
  return { ...currentState, ...updates }
}

// íƒ€ì… ê°€ë“œ
export function isNumber(value: any): value is number {
  return typeof value === 'number' && !isNaN(value) && isFinite(value)
}

export function isString(value: any): value is string {
  return typeof value === 'string'
}

export function isArray<T>(value: any): value is T[] {
  return Array.isArray(value)
}

export function isObject(value: any): value is Record<string, any> {
  return value !== null && typeof value === 'object' && !Array.isArray(value)
}

// ì—ëŸ¬ ì²˜ë¦¬ ìœ í‹¸ë¦¬í‹°
export function createError(message: string, code?: string): Error {
  const error = new Error(message)
  if (code) {
    ;(error as any).code = code
  }
  return error
}

export function isApiError(error: any): boolean {
  return error?.response?.status !== undefined
}

// ì„±ëŠ¥ ì¸¡ì • ìœ í‹¸ë¦¬í‹°
export function measureTime<T>(fn: () => T, label?: string): T {
  const start = performance.now()
  const result = fn()
  const end = performance.now()
  
  if (label) {
    console.log(`${label}: ${end - start}ms`)
  }
  
  return result
}

export async function measureAsyncTime<T>(fn: () => Promise<T>, label?: string): Promise<T> {
  const start = performance.now()
  const result = await fn()
  const end = performance.now()
  
  if (label) {
    console.log(`${label}: ${end - start}ms`)
  }
  
  return result
}

// í™˜ê²½ ê°ì§€
export function isBrowser(): boolean {
  return typeof window !== 'undefined'
}

export function isDevelopment(): boolean {
  return process.env.NODE_ENV === 'development'
}

export function isProduction(): boolean {
  return process.env.NODE_ENV === 'production'
}

// CSS í´ë˜ìŠ¤ ìœ í‹¸ë¦¬í‹°
export function conditionalClass(condition: boolean, trueClass: string, falseClass: string = ''): string {
  return condition ? trueClass : falseClass
}

export function joinClasses(...classes: (string | undefined | null | false)[]): string {
  return classes.filter(Boolean).join(' ')
}0 


