
==================================================
File: C:\Aproject\quant_platform\backend\main.py
==================================================
# ===== backend/main.py ìˆ˜ì •ëœ ë²„ì „ =====

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import sys
import os
import traceback
from datetime import datetime
from pathlib import Path
import importlib
import pandas as pd
import numpy as np

# ê²½ë¡œ ì„¤ì •
current_dir = Path(__file__).parent
backend_quant_engine_path = current_dir / "quant_engine"
strategy_engine_path = current_dir / "strategy_engine"

# ë‘ ê²½ë¡œ ëª¨ë‘ ì¶”ê°€
sys.path.append(str(backend_quant_engine_path))
sys.path.append(str(strategy_engine_path))

# ëª¨ë“  ì „ëµ ëª¨ë“ˆë“¤ import
strategy_modules = {}

try:
    # backend/quant_engine/base_strategy.py
    from quant_engine import base_strategy
    strategy_modules['base_strategy'] = base_strategy
    print("âœ“ base_strategy ë¡œë”© ì„±ê³µ")
    
    # strategy_engine ë””ë ‰í† ë¦¬ì˜ ëª¨ë“  ëª¨ë“ˆë“¤
    strategy_files = [
        'basic_strategies',
        'cycle_contrarian_strategies', 
        'fundamental_metrics',
        'growth_momentum_stratigies',  # ì˜¤íƒ€ ê·¸ëŒ€ë¡œ ìœ ì§€
        'portfolio_utils',
        'strategy_factory',
        'technical_indicators',
        'value_strategies'
    ]
    
    for module_name in strategy_files:
        try:
            module = importlib.import_module(module_name)
            strategy_modules[module_name] = module
            print(f"âœ“ {module_name} ë¡œë”© ì„±ê³µ")
        except ImportError as e:
            print(f"âš ï¸ {module_name} ë¡œë”© ì‹¤íŒ¨: {e}")
    
    print(f"âœ“ ì´ {len(strategy_modules)}ê°œ ì „ëµ ëª¨ë“ˆ ë¡œë”© ì™„ë£Œ")
    
except ImportError as e:
    print(f"âŒ ì „ëµ ëª¨ë“ˆ import ì‹¤íŒ¨: {e}")
    print("ğŸ“ ë””ë ‰í† ë¦¬ êµ¬ì¡° í™•ì¸:")
    print(f"   backend/quant_engine/: {list(backend_quant_engine_path.glob('*.py')) if backend_quant_engine_path.exists() else 'ì¡´ì¬í•˜ì§€ ì•ŠìŒ'}")
    print(f"   backend/strategy_engine/: {list(strategy_engine_path.glob('*.py')) if strategy_engine_path.exists() else 'ì¡´ì¬í•˜ì§€ ì•ŠìŒ'}")

app = FastAPI(title="í€€íŠ¸ ë°±í…ŒìŠ¤íŠ¸ API", version="1.0.0")

# CORS ì„¤ì •
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://yourdomain.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ===== Pydantic ëª¨ë¸ë“¤ =====
class StrategyConfig(BaseModel):
    id: str
    weight: float
    params: Dict[str, Any]

class BacktestRequest(BaseModel):
    strategies: List[StrategyConfig]
    year: int
    outputCount: int

class BacktestResultModel(BaseModel):
    rank: int
    stockCode: str
    stockName: str
    compositeScore: float
    grade: str
    strengthArea: str
    strategyValues: Dict[str, float]

class PortfolioRequest(BaseModel):
    name: str
    stocks: List[str]
    strategies: List[Dict[str, Any]]
    createdAt: str

# ===== ë°±í…ŒìŠ¤íŠ¸ ê´€ë¦¬ í´ë˜ìŠ¤ =====
class QuantBacktestManager:
    """quant_engineê³¼ strategy_engineì„ í™œìš©í•œ ë°±í…ŒìŠ¤íŠ¸ ë§¤ë‹ˆì €"""
    
    def __init__(self):
        self.strategies = {}
        self.stock_data = None
        self.strategy_modules = strategy_modules
        self.load_available_strategies()
        self.load_stock_data()
    
    def load_available_strategies(self):
        """quant_engineì—ì„œ ì‹¤ì œ ì „ëµë“¤ ë¡œë”©"""
        try:
            # ì‹¤ì œ ì „ëµ íŒ©í† ë¦¬ì—ì„œ ì „ëµ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            if 'strategy_factory' in strategy_modules:
                available_strategies = strategy_registry.list_strategies()
                
                for strategy_name in available_strategies:
                    # ì „ëµ ë©”íƒ€ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                    metadata = strategy_registry.get_strategy_metadata(strategy_name)
                    
                    if 'metadata' in metadata:
                        strategy_meta = metadata['metadata']
                        self.strategies[strategy_name] = {
                            "name": strategy_meta.name,
                            "description": strategy_meta.description,
                            "default_params": metadata.get('parameters', {}),
                            "module": strategy_name,
                            "category": strategy_meta.category.value,
                            "risk_level": strategy_meta.risk_level.value,
                            "complexity": strategy_meta.complexity.value
                        }
                
            # ì¶”ê°€ë¡œ ê¸°ë³¸ ì „ëµë“¤ ì •ì˜ (ë°±ì—…ìš©)
            if not self.strategies:
                self.strategies = {
                    "low_pe": {
                        "name": "ì €PER ì „ëµ",
                        "description": "PER 15ë°° ì´í•˜ ì¢…ëª© ì„ ë³„",
                        "default_params": {"max_pe_ratio": 15},
                        "module": "basic_strategies"
                    },
                    "rsi_mean_reversion": {
                        "name": "RSI í‰ê· íšŒê·€ ì „ëµ",
                        "description": "RSI ê³¼ë§¤ìˆ˜/ê³¼ë§¤ë„ êµ¬ê°„ í™œìš©",
                        "default_params": {"rsi_period": 14, "oversold": 30, "overbought": 70},
                        "module": "basic_strategies"
                    },
                    "buffett_moat": {
                        "name": "ì›Œë Œ ë²„í•ì˜ í•´ì ì „ëµ",
                        "description": "ê²½ì œì  í•´ìê°€ ìˆëŠ” ê¸°ì—… ì¥ê¸° íˆ¬ì",
                        "default_params": {"max_pe": 20, "min_roe": 0.15, "min_roic": 0.12},
                        "module": "value_strategies"
                    },
                    "peter_lynch_peg": {
                        "name": "í”¼í„° ë¦°ì¹˜ì˜ PEG ì „ëµ", 
                        "description": "PEG 1.0 ì´í•˜ ì„±ì¥ì£¼ ë°œêµ´",
                        "default_params": {"max_peg": 1.0, "min_growth_rate": 0.1},
                        "module": "value_strategies"
                    },
                    "william_oneil_canslim": {
                        "name": "ìœŒë¦¬ì—„ ì˜¤ë‹ì˜ CAN SLIM",
                        "description": "7ê°€ì§€ ê¸°ì¤€ìœ¼ë¡œ ê³ ì„±ì¥ì£¼ ë°œêµ´",
                        "default_params": {"min_current_earnings": 0.25, "min_relative_strength": 80},
                        "module": "growth_momentum_stratigies"
                    },
                    "bollinger_band": {
                        "name": "ë³¼ë¦°ì € ë°´ë“œ ì—­ë°œìƒ ì „ëµ",
                        "description": "ë³¼ë¦°ì € ë°´ë“œ í„°ì¹˜ ì‹œì  ë§¤ë§¤",
                        "default_params": {"bb_period": 20, "bb_std": 2},
                        "module": "basic_strategies"
                    },
                    "dividend_aristocrats": {
                        "name": "ë°°ë‹¹ ê·€ì¡±ì£¼ ì „ëµ",
                        "description": "ì—°ì† ë°°ë‹¹ ì¦ê°€ ê¸°ì—… íˆ¬ì",
                        "default_params": {"min_dividend_years": 20, "min_dividend_yield": 0.02},
                        "module": "basic_strategies"
                    },
                    "ray_dalio_all_weather": {
                        "name": "ë ˆì´ ë‹¬ë¦¬ì˜¤ì˜ ì˜¬ì›¨ë”",
                        "description": "ê²½ì œ í™˜ê²½ ë³€í™”ì— ê´€ê³„ì—†ì´ ì•ˆì •ì  ìˆ˜ìµ",
                        "default_params": {"rebalance_threshold": 0.05},
                        "module": "cycle_contrarian_strategies"
                    },
                    "joel_greenblatt_magic": {
                        "name": "ì¡°ì—˜ ê·¸ë¦°ë¸”ë¼íŠ¸ì˜ ë§ˆë²•ê³µì‹",
                        "description": "ROE + ìˆ˜ìµìˆ˜ìµë¥  ê²°í•© ì²´ê³„ì  ê°€ì¹˜íˆ¬ì",
                        "default_params": {"min_market_cap": 1000, "top_stocks": 30},
                        "module": "value_strategies"
                    },
                    "simple_momentum": {
                        "name": "ë‹¨ìˆœ ëª¨ë©˜í…€ ì „ëµ",
                        "description": "ìµœê·¼ ì„±ê³¼ ìƒìœ„ ì¢…ëª© ì¶”ì¢…",
                        "default_params": {"lookback_months": 6, "top_percentile": 0.2},
                        "module": "basic_strategies"
                    }
                }
            
            print(f"âœ“ {len(self.strategies)}ê°œ ì „ëµ ì •ì˜ ì™„ë£Œ")
            
        except Exception as e:
            print(f"âœ— ì „ëµ ë¡œë”© ì‹¤íŒ¨: {str(e)}")
            self.strategies = {}
    
    def execute_strategy(self, strategy_name: str, strategy_config: Dict, data: pd.DataFrame = None) -> Dict:
        """ê°œë³„ ì „ëµ ì‹¤í–‰"""
        try:
            # ì‹¤ì œ ì „ëµ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
            if 'strategy_factory' in strategy_modules:
                strategy_instance = strategy_registry.create_strategy(strategy_name, **strategy_config['params'])
                
                if strategy_instance and data is not None:
                    # ì‹¤ì œ ì‹ í˜¸ ìƒì„± ë° ê°€ì¤‘ì¹˜ ê³„ì‚°
                    signals = strategy_instance.generate_signals(data)
                    weights = strategy_instance.calculate_weights(signals)
                    
                    return {
                        'signals': len(signals),
                        'positions': len(weights),
                        'success': True
                    }
            
            # ëª¨ì˜ ê²°ê³¼ ë°˜í™˜ (ì‹¤ì œ ë°ì´í„°ê°€ ì—†ì„ ë•Œ)
            return {
                'signals': 15,
                'positions': 10, 
                'success': True
            }
            
        except Exception as e:
            print(f"âœ— ì „ëµ {strategy_name} ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}")
            return {
                'signals': 0,
                'positions': 0,
                'success': False,
                'error': str(e)
            }
            
            print(f"âœ“ {len(self.strategies)}ê°œ ì „ëµ ì •ì˜ ì™„ë£Œ")
            
        except Exception as e:
            print(f"âœ— ì „ëµ ë¡œë”© ì‹¤íŒ¨: {str(e)}")
            self.strategies = {}
    
    def load_stock_data(self):
        """ì£¼ì‹ ë°ì´í„° ë¡œë”© (ì‹¤ì œë¡œëŠ” CSV íŒŒì¼ì—ì„œ)"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” CSV íŒŒì¼ ë¡œë”©
            # import pandas as pd
            # self.stock_data = pd.read_csv('./data/stock_data.csv')
            print("âœ“ ì£¼ì‹ ë°ì´í„° ë¡œë”© ì™„ë£Œ (ëª¨ì˜)")
            
        except Exception as e:
            print(f"âœ— ì£¼ì‹ ë°ì´í„° ë¡œë”© ì‹¤íŒ¨: {str(e)}")
    
    def get_strategy_function(self, strategy_info: Dict):
        """ì „ëµ ëª¨ë“ˆì—ì„œ ì‹¤ì œ í•¨ìˆ˜ ê°€ì ¸ì˜¤ê¸°"""
        try:
            module_name = strategy_info["module"]
            function_name = strategy_info["function"]
            
            if module_name in self.strategy_modules:
                module = self.strategy_modules[module_name]
                if hasattr(module, function_name):
                    return getattr(module, function_name)
                else:
                    print(f"âš ï¸ í•¨ìˆ˜ {function_name}ë¥¼ {module_name}ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŒ")
                    return None
            else:
                print(f"âš ï¸ ëª¨ë“ˆ {module_name}ì´ ë¡œë”©ë˜ì§€ ì•ŠìŒ")
                return None
                
        except Exception as e:
            print(f"âœ— ì „ëµ í•¨ìˆ˜ ë¡œë”© ì‹¤íŒ¨: {str(e)}")
            return None
    
    def execute_backtest(self, request_data: Dict) -> Dict:
        """ì‹¤ì œ ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""
        try:
            results = []
            
            # ê° ì „ëµë³„ë¡œ ì‹¤í–‰
            for strategy_config in request_data["strategies"]:
                strategy_id = strategy_config["id"]
                
                if strategy_id in self.strategies:
                    strategy_info = self.strategies[strategy_id]
                    strategy_func = self.get_strategy_function(strategy_info)
                    
                    if strategy_func:
                        # ì‹¤ì œ ì „ëµ ì‹¤í–‰ (ì—¬ê¸°ì„œëŠ” ëª¨ì˜ ê²°ê³¼)
                        print(f"âœ“ {strategy_info['name']} ì „ëµ ì‹¤í–‰")
                    else:
                        print(f"âœ— {strategy_info['name']} ì „ëµ í•¨ìˆ˜ ì—†ìŒ")
            
            # ëª¨ì˜ ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ ë°˜í™˜
            mock_results = [
                {
                    "rank": 1, "stockCode": "005930", "stockName": "ì‚¼ì„±ì „ì",
                    "compositeScore": 94.2, "grade": "S", "strengthArea": "ì¬ë¬´",
                    "strategyValues": {"rsi_reversal": 28.5, "roe_growth": 22.1}
                },
                {
                    "rank": 2, "stockCode": "000660", "stockName": "SKí•˜ì´ë‹‰ìŠ¤",
                    "compositeScore": 91.8, "grade": "S", "strengthArea": "ê· í˜•", 
                    "strategyValues": {"rsi_reversal": 31.2, "roe_growth": 18.9}
                },
                {
                    "rank": 3, "stockCode": "035420", "stockName": "NAVER",
                    "compositeScore": 89.3, "grade": "A", "strengthArea": "ê¸°ìˆ ",
                    "strategyValues": {"rsi_reversal": 29.8, "roe_growth": 16.2}
                },
                {
                    "rank": 4, "stockCode": "005380", "stockName": "í˜„ëŒ€ì°¨",
                    "compositeScore": 87.6, "grade": "A", "strengthArea": "ê¸°ìˆ ",
                    "strategyValues": {"rsi_reversal": 25.4, "roe_growth": 15.8}
                },
                {
                    "rank": 5, "stockCode": "051910", "stockName": "LGí™”í•™", 
                    "compositeScore": 85.1, "grade": "A", "strengthArea": "ì¬ë¬´",
                    "strategyValues": {"rsi_reversal": 32.1, "roe_growth": 14.5}
                }
            ]
            
            return {
                "results": mock_results[:request_data["outputCount"]],
                "totalAnalyzed": 2847,
                "conditionMet": 127,
                "reliability": {
                    "dataQuality": 94.2,
                    "coverage": 96.1,
                    "completedAt": datetime.now().isoformat()
                }
            }
            
        except Exception as e:
            raise Exception(f"ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì˜¤ë¥˜: {str(e)}")

# ì „ì—­ ë§¤ë‹ˆì € ì¸ìŠ¤í„´ìŠ¤
backtest_manager = None

@app.on_event("startup")
async def startup_event():
    global backtest_manager
    try:
        backtest_manager = QuantBacktestManager()
        print("âœ“ ë°±í…ŒìŠ¤íŠ¸ ë§¤ë‹ˆì € ì´ˆê¸°í™” ì™„ë£Œ")
    except Exception as e:
        print(f"âœ— ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨: {str(e)}")

# ===== API ì—”ë“œí¬ì¸íŠ¸ë“¤ =====

@app.get("/api/strategies")
async def get_strategies():
    """ì‚¬ìš© ê°€ëŠ¥í•œ ì „ëµ ëª©ë¡ ë°˜í™˜"""
    try:
        if not backtest_manager:
            raise HTTPException(status_code=500, detail="ë°±í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        
        strategies_data = []
        for strategy_id, info in backtest_manager.strategies.items():
            strategies_data.append({
                "id": strategy_id,
                "name": info["name"],
                "description": info["description"],
                "defaultParams": info["default_params"],
                "paramSchema": {}
            })
        
        return {
            "success": True,
            "strategies": strategies_data
        }
    except Exception as e:
        return {
            "success": False,
            "error": f"ì „ëµ ë¡œë”© ì‹¤íŒ¨: {str(e)}"
        }

@app.post("/api/backtest")
async def run_backtest(request: BacktestRequest):
    """ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""
    try:
        if not backtest_manager:
            raise HTTPException(status_code=500, detail="ë°±í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        
        # ìš”ì²­ ë°ì´í„° ê²€ì¦
        if not request.strategies:
            raise HTTPException(status_code=400, detail="ìµœì†Œ í•˜ë‚˜ì˜ ì „ëµì„ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.")
        
        total_weight = sum(s.weight for s in request.strategies)
        if abs(total_weight - 100) > 1:
            raise HTTPException(status_code=400, detail="ì „ëµ ê°€ì¤‘ì¹˜ì˜ í•©ì´ 100%ê°€ ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.")
        
        # ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰
        request_dict = {
            "strategies": [s.dict() for s in request.strategies],
            "year": request.year,
            "outputCount": request.outputCount
        }
        
        result_data = backtest_manager.execute_backtest(request_dict)
        
        return {
            "success": True,
            "data": result_data
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì˜¤ë¥˜: {str(e)}")
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {str(e)}")

@app.get("/api/validate-data")
async def validate_stock_data(year: int):
    """ì£¼ì‹ ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬"""
    try:
        if not backtest_manager:
            return {"isValid": False, "message": "ë°±í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."}
        
        # ì‹¤ì œë¡œëŠ” í•´ë‹¹ ì—°ë„ ë°ì´í„° ì¡´ì¬ ì—¬ë¶€ í™•ì¸
        # yearly_data = filter_data_by_year(year)
        
        return {
            "isValid": True,
            "message": f"{year}ë…„ ë°ì´í„°: 2,847ê°œ ì¢…ëª© ë³´ìœ "
        }
        
    except Exception as e:
        return {"isValid": False, "message": f"ë°ì´í„° ê²€ì¦ ì˜¤ë¥˜: {str(e)}"}

@app.post("/api/portfolio")
async def save_portfolio(portfolio: PortfolioRequest):
    """í¬íŠ¸í´ë¦¬ì˜¤ ì €ì¥"""
    try:
        import json
        import uuid
        
        portfolio_id = str(uuid.uuid4())
        portfolio_data = {
            "id": portfolio_id,
            "name": portfolio.name,
            "stocks": portfolio.stocks,
            "strategies": portfolio.strategies,
            "createdAt": portfolio.createdAt,
            "savedAt": datetime.now().isoformat()
        }
        
        # portfolios ë””ë ‰í† ë¦¬ ìƒì„±
        portfolios_dir = Path("./portfolios")
        portfolios_dir.mkdir(exist_ok=True)
        
        # JSON íŒŒì¼ë¡œ ì €ì¥
        portfolio_file = portfolios_dir / f"{portfolio_id}.json"
        with open(portfolio_file, "w", encoding="utf-8") as f:
            json.dump(portfolio_data, f, ensure_ascii=False, indent=2)
        
        print(f"âœ“ í¬íŠ¸í´ë¦¬ì˜¤ ì €ì¥ ì™„ë£Œ: {portfolio.name}")
        
        return {"success": True, "id": portfolio_id}
        
    except Exception as e:
        print(f"âœ— í¬íŠ¸í´ë¦¬ì˜¤ ì €ì¥ ì‹¤íŒ¨: {str(e)}")
        raise HTTPException(status_code=500, detail=f"í¬íŠ¸í´ë¦¬ì˜¤ ì €ì¥ ì‹¤íŒ¨: {str(e)}")

@app.get("/api/portfolios")
async def get_portfolios():
    """ì €ì¥ëœ í¬íŠ¸í´ë¦¬ì˜¤ ëª©ë¡ ì¡°íšŒ"""
    try:
        import json
        from pathlib import Path
        
        portfolios = []
        portfolios_dir = Path("./portfolios")
        
        if portfolios_dir.exists():
            for portfolio_file in portfolios_dir.glob("*.json"):
                try:
                    with open(portfolio_file, "r", encoding="utf-8") as f:
                        portfolio_data = json.load(f)
                        portfolios.append(portfolio_data)
                except Exception as e:
                    print(f"í¬íŠ¸í´ë¦¬ì˜¤ íŒŒì¼ ë¡œë”© ì‹¤íŒ¨: {portfolio_file} - {str(e)}")
        
        # ì €ì¥ ì‹œê°„ìˆœ ì •ë ¬
        portfolios.sort(key=lambda x: x.get('savedAt', ''), reverse=True)
        
        return {"portfolios": portfolios}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"í¬íŠ¸í´ë¦¬ì˜¤ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")

@app.get("/health")
async def health_check():
    """ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸"""
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "system_ready": backtest_manager is not None,
        "strategies_loaded": len(backtest_manager.strategies) if backtest_manager else 0,
        "modules_loaded": list(strategy_modules.keys()),
        "data_loaded": backtest_manager.stock_data is not None if backtest_manager else False
    }

@app.get("/")
async def root():
    """ë£¨íŠ¸ ì—”ë“œí¬ì¸íŠ¸"""
    return {
        "message": "í€€íŠ¸ ë°±í…ŒìŠ¤íŠ¸ API ì„œë²„",
        "version": "1.0.0",
        "endpoints": [
            "/api/strategies",
            "/api/backtest", 
            "/api/validate-data",
            "/api/portfolio",
            "/api/portfolios",
            "/health"
        ]
    }

if __name__ == "__main__":
    import uvicorn
    
    print("ğŸš€ í€€íŠ¸ ë°±í…ŒìŠ¤íŠ¸ API ì„œë²„ ì‹œì‘")
    print(f"ğŸ“ í˜„ì¬ ë””ë ‰í† ë¦¬: {Path.cwd()}")
    print(f"ğŸ“Š ë¡œë”©ëœ ëª¨ë“ˆ: {list(strategy_modules.keys())}")
    
    uvicorn.run(
        app, 
        host="0.0.0.0", 
        port=8000, 
        reload=True,
        reload_dirs=["./"]
    )



==================================================
File: C:\Aproject\quant_platform\backend\quant_engine\base_strategy.py
==================================================
"""
file: backend/quant_engine/base_strategy.py
Base Strategy Class and Common Interfaces
ì „ëµ ê¸°ë³¸ í´ë˜ìŠ¤ ë° ê³µí†µ ì¸í„°í˜ì´ìŠ¤
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple, Union
import pandas as pd
import numpy as np
from dataclasses import dataclass
from enum import Enum
import logging

# ì„¤ì • ë° ìƒìˆ˜
class RiskLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"

class Complexity(Enum):
    SIMPLE = "simple"
    MEDIUM = "medium"
    COMPLEX = "complex"

class StrategyCategory(Enum):
    BASIC = "basic"
    ADVANCED = "advanced"

@dataclass
class StrategyMetadata:
    """ì „ëµ ë©”íƒ€ë°ì´í„°"""
    name: str
    description: str
    category: StrategyCategory
    risk_level: RiskLevel
    complexity: Complexity
    expected_return: str
    volatility: str
    min_investment_period: str
    rebalancing_frequency: str

@dataclass
class Signal:
    """ë§¤ë§¤ ì‹ í˜¸"""
    symbol: str
    timestamp: pd.Timestamp
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    strength: float  # 0.0 ~ 1.0
    confidence: float  # 0.0 ~ 1.0
    metadata: Optional[Dict] = None

@dataclass
class PortfolioWeight:
    """í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¤‘ì¹˜"""
    symbol: str
    weight: float
    target_weight: float
    current_weight: float
    rebalance_needed: bool = False

class BaseStrategy(ABC):
    """ì „ëµ ê¸°ë³¸ í´ë˜ìŠ¤"""
    
    def __init__(self, name: str, **kwargs):
        self.name = name
        self.parameters = kwargs
        self.metadata = self._get_metadata()
        self.logger = logging.getLogger(f"Strategy.{name}")
        self._validate_parameters()
    
    @abstractmethod
    def _get_metadata(self) -> StrategyMetadata:
        """ì „ëµ ë©”íƒ€ë°ì´í„° ë°˜í™˜"""
        pass
    
    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        """ë§¤ë§¤ ì‹ í˜¸ ìƒì„±"""
        pass
    
    @abstractmethod
    def calculate_weights(self, signals: List[Signal], 
                        current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        """í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¤‘ì¹˜ ê³„ì‚°"""
        pass
    
    def _validate_parameters(self):
        """íŒŒë¼ë¯¸í„° ê²€ì¦"""
        required_params = self._get_required_parameters()
        for param in required_params:
            if param not in self.parameters:
                raise ValueError(f"Required parameter '{param}' is missing for strategy '{self.name}'")
    
    def _get_required_parameters(self) -> List[str]:
        """í•„ìˆ˜ íŒŒë¼ë¯¸í„° ëª©ë¡ ë°˜í™˜"""
        return []
    
    def preprocess_data(self, data: pd.DataFrame) -> pd.DataFrame:
        """ë°ì´í„° ì „ì²˜ë¦¬"""
        # ê¸°ë³¸ì ì¸ ë°ì´í„° ì •ë¦¬
        data = data.copy()
        
        # í•„ìˆ˜ ì»¬ëŸ¼ í™•ì¸
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        missing_columns = [col for col in required_columns if col not in data.columns]
        if missing_columns:
            raise ValueError(f"Missing required columns: {missing_columns}")
        
        # ê²°ì¸¡ì¹˜ ì²˜ë¦¬
        data = data.fillna(method='ffill').dropna()
        
        # ë‚ ì§œ ì¸ë±ìŠ¤ ì„¤ì •
        if not isinstance(data.index, pd.DatetimeIndex):
            if 'date' in data.columns:
                data['date'] = pd.to_datetime(data['date'])
                data.set_index('date', inplace=True)
            else:
                self.logger.warning("No date column found, using existing index")
        
        return data
    
    def filter_universe(self, data: pd.DataFrame) -> pd.DataFrame:
        """íˆ¬ì ìœ ë‹ˆë²„ìŠ¤ í•„í„°ë§"""
        # ê¸°ë³¸ í•„í„°ë§ ì¡°ê±´
        filtered_data = data.copy()
        
        # ê±°ë˜ëŸ‰ í•„í„° (ì¼í‰ê·  ê±°ë˜ëŸ‰ì´ ë„ˆë¬´ ì ì€ ì¢…ëª© ì œì™¸)
        min_volume = self.parameters.get('min_volume', 100000)
        if 'volume' in filtered_data.columns:
            avg_volume = filtered_data['volume'].rolling(20).mean()
            filtered_data = filtered_data[avg_volume > min_volume]
        
        # ê°€ê²© í•„í„° (ë„ˆë¬´ ì €ê°€ì£¼ ì œì™¸)
        min_price = self.parameters.get('min_price', 1.0)
        if 'close' in filtered_data.columns:
            filtered_data = filtered_data[filtered_data['close'] > min_price]
        
        # ì‹œê°€ì´ì•¡ í•„í„° (ì„¤ì •ëœ ê²½ìš°)
        min_market_cap = self.parameters.get('min_market_cap')
        if min_market_cap and 'market_cap' in filtered_data.columns:
            filtered_data = filtered_data[filtered_data['market_cap'] > min_market_cap]
        
        return filtered_data
    
    def calculate_risk_metrics(self, returns: pd.Series) -> Dict[str, float]:
        """ë¦¬ìŠ¤í¬ ì§€í‘œ ê³„ì‚°"""
        if len(returns) == 0:
            return {}
        
        # ê¸°ë³¸ ë¦¬ìŠ¤í¬ ì§€í‘œ
        volatility = returns.std() * np.sqrt(252)  # ì—°ìœ¨í™”
        max_drawdown = self._calculate_max_drawdown(returns)
        var_95 = returns.quantile(0.05)  # 5% VaR
        
        # í•˜ë°© ìœ„í—˜ ì§€í‘œ
        downside_returns = returns[returns < 0]
        downside_volatility = downside_returns.std() * np.sqrt(252) if len(downside_returns) > 0 else 0
        
        return {
            'volatility': volatility,
            'max_drawdown': max_drawdown,
            'var_95': var_95,
            'downside_volatility': downside_volatility,
            'skewness': returns.skew(),
            'kurtosis': returns.kurtosis()
        }
    
    def _calculate_max_drawdown(self, returns: pd.Series) -> float:
        """ìµœëŒ€ ë‚™í­ ê³„ì‚°"""
        cumulative = (1 + returns).cumprod()
        running_max = cumulative.expanding().max()
        drawdown = (cumulative - running_max) / running_max
        return drawdown.min()
    
    def get_strategy_info(self) -> Dict:
        """ì „ëµ ì •ë³´ ë°˜í™˜"""
        return {
            'name': self.name,
            'metadata': self.metadata,
            'parameters': self.parameters,
            'required_data': self._get_required_data_columns(),
            'rebalancing_frequency': self.metadata.rebalancing_frequency
        }
    
    def _get_required_data_columns(self) -> List[str]:
        """í•„ìš”í•œ ë°ì´í„° ì»¬ëŸ¼ ë°˜í™˜"""
        return ['open', 'high', 'low', 'close', 'volume']
    
    def validate_signals(self, signals: List[Signal]) -> List[Signal]:
        """ì‹ í˜¸ ê²€ì¦ ë° í•„í„°ë§"""
        valid_signals = []
        
        for signal in signals:
            # ì‹ í˜¸ ê°•ë„ ê²€ì¦
            if not 0 <= signal.strength <= 1:
                self.logger.warning(f"Invalid signal strength for {signal.symbol}: {signal.strength}")
                continue
            
            # ì‹ ë¢°ë„ ê²€ì¦
            if not 0 <= signal.confidence <= 1:
                self.logger.warning(f"Invalid signal confidence for {signal.symbol}: {signal.confidence}")
                continue
            
            # ì‹ í˜¸ íƒ€ì… ê²€ì¦
            if signal.signal_type not in ['BUY', 'SELL', 'HOLD']:
                self.logger.warning(f"Invalid signal type for {signal.symbol}: {signal.signal_type}")
                continue
            
            valid_signals.append(signal)
        
        return valid_signals
    
    def apply_position_sizing(self, weights: List[PortfolioWeight]) -> List[PortfolioWeight]:
        """í¬ì§€ì…˜ ì‚¬ì´ì§• ì ìš©"""
        # ìµœëŒ€ ë‹¨ì¼ ì¢…ëª© ë¹„ì¤‘ ì œí•œ
        max_single_weight = self.parameters.get('max_single_weight', 0.1)  # 10%
        
        adjusted_weights = []
        for weight in weights:
            adjusted_weight = min(weight.target_weight, max_single_weight)
            
            adjusted_weights.append(PortfolioWeight(
                symbol=weight.symbol,
                weight=adjusted_weight,
                target_weight=adjusted_weight,
                current_weight=weight.current_weight,
                rebalance_needed=abs(adjusted_weight - weight.current_weight) > 0.01
            ))
        
        # ê°€ì¤‘ì¹˜ ì •ê·œí™” (í•©ê³„ê°€ 1.0ì´ ë˜ë„ë¡)
        total_weight = sum(w.weight for w in adjusted_weights)
        if total_weight > 0:
            for weight in adjusted_weights:
                weight.weight /= total_weight
                weight.target_weight /= total_weight
        
        return adjusted_weights
    
    def log_strategy_performance(self, signals: List[Signal], weights: List[PortfolioWeight]):
        """ì „ëµ ì„±ê³¼ ë¡œê¹…"""
        buy_signals = len([s for s in signals if s.signal_type == 'BUY'])
        sell_signals = len([s for s in signals if s.signal_type == 'SELL'])
        total_positions = len([w for w in weights if w.weight > 0])
        
        self.logger.info(f"Strategy {self.name} - Buy: {buy_signals}, Sell: {sell_signals}, Positions: {total_positions}")

class StrategyFactory:
    """ì „ëµ íŒ©í† ë¦¬ í´ë˜ìŠ¤"""
    
    _strategies = {}
    
    @classmethod
    def register_strategy(cls, strategy_name: str, strategy_class):
        """ì „ëµ ë“±ë¡"""
        cls._strategies[strategy_name] = strategy_class
    
    @classmethod
    def create_strategy(cls, strategy_name: str, **kwargs):
        """ì „ëµ ìƒì„±"""
        if strategy_name not in cls._strategies:
            raise ValueError(f"Unknown strategy: {strategy_name}")
        
        return cls._strategies[strategy_name](**kwargs)
    
    @classmethod
    def list_strategies(cls) -> List[str]:
        """ë“±ë¡ëœ ì „ëµ ëª©ë¡ ë°˜í™˜"""
        return list(cls._strategies.keys())

# ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
def calculate_sharpe_ratio(returns: pd.Series, risk_free_rate: float = 0.02) -> float:
    """ìƒ¤í”„ ë¹„ìœ¨ ê³„ì‚°"""
    if len(returns) == 0 or returns.std() == 0:
        return 0.0
    
    excess_returns = returns.mean() * 252 - risk_free_rate  # ì—°ìœ¨í™”
    volatility = returns.std() * np.sqrt(252)
    
    return excess_returns / volatility

def calculate_sortino_ratio(returns: pd.Series, risk_free_rate: float = 0.02) -> float:
    """ì†Œë¥´í‹°ë…¸ ë¹„ìœ¨ ê³„ì‚°"""
    if len(returns) == 0:
        return 0.0
    
    excess_returns = returns.mean() * 252 - risk_free_rate
    downside_returns = returns[returns < 0]
    
    if len(downside_returns) == 0:
        return float('inf')
    
    downside_volatility = downside_returns.std() * np.sqrt(252)
    
    if downside_volatility == 0:
        return float('inf')
    
    return excess_returns / downside_volatility


==================================================
File: C:\Aproject\quant_platform\backend\quant_engine\basic_strategies.py
==================================================
"""
file: strategy_engine/basic_strategies.py
Basic Investment Strategies - 10ê°€ì§€
ê°œì¸íˆ¬ìììš© ê¸°ë³¸ ì „ëµë“¤
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional
from base_strategy import BaseStrategy, StrategyMetadata, Signal, PortfolioWeight
from base_strategy import RiskLevel, Complexity, StrategyCategory, StrategyFactory
import technical_indicators as ti
import fundamental_metrics as fm

# 1. ì €PER ì „ëµ
class LowPEStrategy(BaseStrategy):
    """ì €PER ì „ëµ - PER 15ë°° ì´í•˜ ì¢…ëª© ì„ ë³„"""
    
    def __init__(self, **kwargs):
        super().__init__("Low_PE_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ì €PER ì „ëµ",
            description="PER 15ë°° ì´í•˜ ì¢…ëª© ì„ ë³„í•˜ëŠ” ê°€ì¹˜íˆ¬ì ì „ëµ",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.SIMPLE,
            expected_return="8-12%",
            volatility="12-18%",
            min_investment_period="1ë…„ ì´ìƒ",
            rebalancing_frequency="ë¶„ê¸°ë³„"
        )
    
    def _get_required_parameters(self) -> List[str]:
        return ['max_pe_ratio']
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + ['pe_ratio', 'market_cap']
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        max_pe = self.parameters.get('max_pe_ratio', 15)
        signals = []
        
        # PE ë°ì´í„°ê°€ ìˆëŠ” ì¢…ëª©ë“¤ë§Œ ì²˜ë¦¬
        pe_data = data.dropna(subset=['pe_ratio'])
        
        for symbol in pe_data.index:
            pe_ratio = pe_data.loc[symbol, 'pe_ratio']
            
            # ì €PER ì¡°ê±´ í™•ì¸
            if 0 < pe_ratio <= max_pe:
                # ì¶”ê°€ í•„í„°ë§: ì ì ê¸°ì—… ì œì™¸, ìµœì†Œ ì‹œê°€ì´ì•¡
                market_cap = pe_data.loc[symbol, 'market_cap']
                if market_cap > 1000:  # 10ì–µ ë‹¬ëŸ¬ ì´ìƒ
                    signal_strength = min(1.0, (max_pe - pe_ratio) / max_pe)
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=signal_strength,
                        confidence=0.7,
                        metadata={'pe_ratio': pe_ratio}
                    ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # ë™ì¼ ê°€ì¤‘ì¹˜ ë°©ì‹
        target_weight = 1.0 / len(signals)
        weights = []
        
        for signal in signals:
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight,
                rebalance_needed=abs(target_weight - current_weight) > 0.01
            ))
        
        return self.apply_position_sizing(weights)

# 2. ë°°ë‹¹ ê·€ì¡±ì£¼ ì „ëµ
class DividendAristocratsStrategy(BaseStrategy):
    """ë°°ë‹¹ ê·€ì¡±ì£¼ ì „ëµ - 20ë…„ ì´ìƒ ì—°ì† ë°°ë‹¹ ì¦ê°€ ê¸°ì—…"""
    
    def __init__(self, **kwargs):
        super().__init__("Dividend_Aristocrats_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ë°°ë‹¹ ê·€ì¡±ì£¼ ì „ëµ",
            description="20ë…„ ì´ìƒ ì—°ì† ë°°ë‹¹ ì¦ê°€ ê¸°ì—… íˆ¬ì",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.SIMPLE,
            expected_return="7-10%",
            volatility="10-15%",
            min_investment_period="3ë…„ ì´ìƒ",
            rebalancing_frequency="ì—° 1íšŒ"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + ['dividend_yield', 'dividend_growth_years']
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        min_dividend_years = self.parameters.get('min_dividend_years', 20)
        min_yield = self.parameters.get('min_dividend_yield', 0.02)
        
        signals = []
        dividend_data = data.dropna(subset=['dividend_yield', 'dividend_growth_years'])
        
        for symbol in dividend_data.index:
            dividend_years = dividend_data.loc[symbol, 'dividend_growth_years']
            dividend_yield = dividend_data.loc[symbol, 'dividend_yield']
            
            if dividend_years >= min_dividend_years and dividend_yield >= min_yield:
                # ì‹ í˜¸ ê°•ë„: ë°°ë‹¹ ê¸°ê°„ê³¼ ìˆ˜ìµë¥  ê¸°ì¤€
                strength = min(1.0, (dividend_years / 30) * 0.7 + (dividend_yield / 0.06) * 0.3)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=0.8,
                    metadata={
                        'dividend_years': dividend_years,
                        'dividend_yield': dividend_yield
                    }
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # ë°°ë‹¹ìˆ˜ìµë¥  ê¸°ì¤€ ê°€ì¤‘ì¹˜
        total_strength = sum(signal.strength for signal in signals)
        weights = []
        
        for signal in signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 3. ë‹¨ìˆœ ëª¨ë©˜í…€ ì „ëµ
class SimpleMomentumStrategy(BaseStrategy):
    """ë‹¨ìˆœ ëª¨ë©˜í…€ ì „ëµ - ìµœê·¼ 3-12ê°œì›” ìˆ˜ìµë¥  ìƒìœ„ ì¢…ëª©"""
    
    def __init__(self, **kwargs):
        super().__init__("Simple_Momentum_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ë‹¨ìˆœ ëª¨ë©˜í…€ ì „ëµ",
            description="ìµœê·¼ ì„±ê³¼ ìƒìœ„ ì¢…ëª© íˆ¬ì, ìƒìŠ¹ ì¶”ì„¸ ì¶”ì¢…",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.SIMPLE,
            expected_return="10-15%",
            volatility="16-22%",
            min_investment_period="6ê°œì›” ì´ìƒ",
            rebalancing_frequency="ì›”ë³„"
        )
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        lookback_months = self.parameters.get('lookback_months', 6)
        top_percentile = self.parameters.get('top_percentile', 0.2)  # ìƒìœ„ 20%
        
        signals = []
        
        # ê°€ê²© ë°ì´í„°ì—ì„œ ìˆ˜ìµë¥  ê³„ì‚°
        returns = data['close'].pct_change(lookback_months * 21)  # ì•½ ì›”ë³„ ê±°ë˜ì¼
        
        # ìƒìœ„ percentile ê³„ì‚°
        threshold = returns.quantile(1 - top_percentile)
        
        for symbol in returns.index:
            if pd.isna(returns[symbol]):
                continue
                
            if returns[symbol] >= threshold:
                # ì¶”ê°€ í•„í„°: ìµœê·¼ ë³€ë™ì„± í™•ì¸
                recent_returns = data.loc[symbol, 'close'].pct_change().tail(21)
                volatility = recent_returns.std()
                
                # ê³¼ë„í•œ ë³€ë™ì„± ì¢…ëª© ì œì™¸
                max_volatility = self.parameters.get('max_volatility', 0.05)
                if volatility <= max_volatility:
                    strength = min(1.0, returns[symbol] / (threshold * 2))
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=strength,
                        confidence=0.6,
                        metadata={
                            'momentum_return': returns[symbol],
                            'volatility': volatility
                        }
                    ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # ëª¨ë©˜í…€ ê°•ë„ ê¸°ì¤€ ê°€ì¤‘ì¹˜
        total_strength = sum(signal.strength for signal in signals)
        weights = []
        
        for signal in signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 4. ì´ë™í‰ê·  êµì°¨ ì „ëµ
class MovingAverageCrossStrategy(BaseStrategy):
    """ì´ë™í‰ê·  êµì°¨ ì „ëµ - 20ì¼ì„ ì´ 60ì¼ì„  ëŒíŒŒ"""
    
    def __init__(self, **kwargs):
        super().__init__("Moving_Average_Cross_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ì´ë™í‰ê·  êµì°¨ ì „ëµ",
            description="ë‹¨ê¸° ì´ë™í‰ê· ì´ ì¥ê¸° ì´ë™í‰ê·  ìƒí–¥ ëŒíŒŒì‹œ ë§¤ìˆ˜",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.SIMPLE,
            expected_return="8-12%",
            volatility="14-20%",
            min_investment_period="6ê°œì›” ì´ìƒ",
            rebalancing_frequency="ì£¼ë³„"
        )
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        short_period = self.parameters.get('short_ma', 20)
        long_period = self.parameters.get('long_ma', 60)
        
        signals = []
        
        for symbol in data.index:
            prices = data.loc[symbol, 'close']
            if len(prices) < long_period:
                continue
            
            # ì´ë™í‰ê·  ê³„ì‚°
            short_ma = ti.simple_moving_average(prices, short_period)
            long_ma = ti.simple_moving_average(prices, long_period)
            
            if len(short_ma) < 2 or len(long_ma) < 2:
                continue
            
            # ê³¨ë“  í¬ë¡œìŠ¤ í™•ì¸ (ë‹¨ê¸°ì„ ì´ ì¥ê¸°ì„ ì„ ìƒí–¥ ëŒíŒŒ)
            current_cross = short_ma.iloc[-1] > long_ma.iloc[-1]
            previous_cross = short_ma.iloc[-2] > long_ma.iloc[-2]
            
            if current_cross and not previous_cross:
                # êµì°¨ ê°•ë„ ê³„ì‚°
                cross_strength = (short_ma.iloc[-1] - long_ma.iloc[-1]) / long_ma.iloc[-1]
                strength = min(1.0, abs(cross_strength) * 10)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=0.65,
                    metadata={
                        'short_ma': short_ma.iloc[-1],
                        'long_ma': long_ma.iloc[-1],
                        'cross_strength': cross_strength
                    }
                ))
            
            # ë°ë“œ í¬ë¡œìŠ¤ í™•ì¸ (ë§¤ë„ ì‹ í˜¸)
            elif not current_cross and previous_cross:
                cross_strength = (long_ma.iloc[-1] - short_ma.iloc[-1]) / long_ma.iloc[-1]
                strength = min(1.0, abs(cross_strength) * 10)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='SELL',
                    strength=strength,
                    confidence=0.65,
                    metadata={
                        'short_ma': short_ma.iloc[-1],
                        'long_ma': long_ma.iloc[-1],
                        'cross_strength': cross_strength
                    }
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        buy_signals = [s for s in signals if s.signal_type == 'BUY']
        if not buy_signals:
            return []
        
        # ë™ì¼ ê°€ì¤‘ì¹˜
        target_weight = 1.0 / len(buy_signals)
        weights = []
        
        for signal in buy_signals:
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 5. RSI ê³¼ë§¤ìˆ˜/ê³¼ë§¤ë„ ì „ëµ
class RSIMeanReversionStrategy(BaseStrategy):
    """RSI ê³¼ë§¤ìˆ˜/ê³¼ë§¤ë„ ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("RSI_Mean_Reversion_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="RSI í‰ê· íšŒê·€ ì „ëµ",
            description="RSI 30 ì´í•˜ ë§¤ìˆ˜, 70 ì´ìƒ ë§¤ë„",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.SIMPLE,
            expected_return="10-13%",
            volatility="12-18%",
            min_investment_period="3ê°œì›” ì´ìƒ",
            rebalancing_frequency="ì£¼ë³„"
        )
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        rsi_period = self.parameters.get('rsi_period', 14)
        oversold_threshold = self.parameters.get('oversold', 30)
        overbought_threshold = self.parameters.get('overbought', 70)
        
        signals = []
        
        for symbol in data.index:
            prices = data.loc[symbol, 'close']
            if len(prices) < rsi_period + 1:
                continue
            
            rsi = ti.rsi(prices, rsi_period)
            if len(rsi) == 0:
                continue
            
            current_rsi = rsi.iloc[-1]
            
            # ê³¼ë§¤ë„ êµ¬ê°„ (ë§¤ìˆ˜ ì‹ í˜¸)
            if current_rsi <= oversold_threshold:
                strength = (oversold_threshold - current_rsi) / oversold_threshold
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=0.7,
                    metadata={'rsi': current_rsi}
                ))
            
            # ê³¼ë§¤ìˆ˜ êµ¬ê°„ (ë§¤ë„ ì‹ í˜¸)
            elif current_rsi >= overbought_threshold:
                strength = (current_rsi - overbought_threshold) / (100 - overbought_threshold)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='SELL',
                    strength=strength,
                    confidence=0.7,
                    metadata={'rsi': current_rsi}
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        buy_signals = [s for s in signals if s.signal_type == 'BUY']
        if not buy_signals:
            return []
        
        # RSI ì‹ í˜¸ ê°•ë„ ê¸°ë°˜ ê°€ì¤‘ì¹˜
        total_strength = sum(signal.strength for signal in buy_signals)
        weights = []
        
        for signal in buy_signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 6. ë³¼ë¦°ì € ë°´ë“œ ì—­ë°œìƒ ì „ëµ
class BollingerBandStrategy(BaseStrategy):
    """ë³¼ë¦°ì € ë°´ë“œ ì—­ë°œìƒ ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("Bollinger_Band_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ë³¼ë¦°ì € ë°´ë“œ ì—­ë°œìƒ ì „ëµ",
            description="í•˜ë‹¨ì„  í„°ì¹˜ì‹œ ë§¤ìˆ˜, ìƒë‹¨ì„  í„°ì¹˜ì‹œ ë§¤ë„",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.SIMPLE,
            expected_return="9-12%",
            volatility="13-19%",
            min_investment_period="6ê°œì›” ì´ìƒ",
            rebalancing_frequency="ì£¼ë³„"
        )
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        bb_period = self.parameters.get('bb_period', 20)
        bb_std = self.parameters.get('bb_std', 2)
        
        signals = []
        
        for symbol in data.index:
            prices = data.loc[symbol, 'close']
            if len(prices) < bb_period:
                continue
            
            bb_upper, bb_middle, bb_lower = ti.bollinger_bands(prices, bb_period, bb_std)
            
            if len(bb_upper) == 0:
                continue
            
            current_price = prices.iloc[-1]
            current_upper = bb_upper.iloc[-1]
            current_lower = bb_lower.iloc[-1]
            current_middle = bb_middle.iloc[-1]
            
            # í•˜ë‹¨ì„  ê·¼ì²˜ (ë§¤ìˆ˜ ì‹ í˜¸)
            if current_price <= current_lower * 1.02:  # 2% ë²„í¼
                distance_ratio = (current_lower - current_price) / (current_middle - current_lower)
                strength = min(1.0, max(0, distance_ratio))
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=0.65,
                    metadata={
                        'price': current_price,
                        'bb_lower': current_lower,
                        'bb_middle': current_middle
                    }
                ))
            
            # ìƒë‹¨ì„  ê·¼ì²˜ (ë§¤ë„ ì‹ í˜¸)
            elif current_price >= current_upper * 0.98:  # 2% ë²„í¼
                distance_ratio = (current_price - current_upper) / (current_upper - current_middle)
                strength = min(1.0, max(0, distance_ratio))
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='SELL',
                    strength=strength,
                    confidence=0.65,
                    metadata={
                        'price': current_price,
                        'bb_upper': current_upper,
                        'bb_middle': current_middle
                    }
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        buy_signals = [s for s in signals if s.signal_type == 'BUY']
        if not buy_signals:
            return []
        
        # ë™ì¼ ê°€ì¤‘ì¹˜
        target_weight = 1.0 / len(buy_signals)
        weights = []
        
        for signal in buy_signals:
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 7. ì†Œí˜•ì£¼ í”„ë¦¬ë¯¸ì—„ ì „ëµ
class SmallCapStrategy(BaseStrategy):
    """ì†Œí˜•ì£¼ í”„ë¦¬ë¯¸ì—„ ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("Small_Cap_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ì†Œí˜•ì£¼ í”„ë¦¬ë¯¸ì—„ ì „ëµ",
            description="ì‹œê°€ì´ì•¡ í•˜ìœ„ ì¢…ëª© íˆ¬ìë¡œ ì´ˆê³¼ìˆ˜ìµ ì¶”êµ¬",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.HIGH,
            complexity=Complexity.SIMPLE,
            expected_return="12-18%",
            volatility="20-30%",
            min_investment_period="2ë…„ ì´ìƒ",
            rebalancing_frequency="ë¶„ê¸°ë³„"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + ['market_cap']
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        small_cap_percentile = self.parameters.get('small_cap_percentile', 0.2)  # í•˜ìœ„ 20%
        
        signals = []
        market_cap_data = data.dropna(subset=['market_cap'])
        
        # ì‹œê°€ì´ì•¡ í•˜ìœ„ percentile ê³„ì‚°
        threshold = market_cap_data['market_cap'].quantile(small_cap_percentile)
        
        for symbol in market_cap_data.index:
            market_cap = market_cap_data.loc[symbol, 'market_cap']
            
            if market_cap <= threshold:
                # ìµœì†Œ ìœ ë™ì„± í™•ì¸
                min_market_cap = self.parameters.get('min_market_cap', 100)  # 1ì–µ ë‹¬ëŸ¬
                if market_cap >= min_market_cap:
                    # ì‹ í˜¸ ê°•ë„ëŠ” ì‹œê°€ì´ì•¡ì´ ì‘ì„ìˆ˜ë¡ ë†’ìŒ
                    strength = 1.0 - (market_cap / threshold)
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=strength,
                        confidence=0.6,
                        metadata={'market_cap': market_cap}
                    ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # ë™ì¼ ê°€ì¤‘ì¹˜ (ì†Œí˜•ì£¼ëŠ” ì§‘ì¤‘ ìœ„í—˜ ë°©ì§€)
        target_weight = 1.0 / len(signals)
        weights = []
        
        for signal in signals:
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 8. ì €ë³€ë™ì„± ì „ëµ
class LowVolatilityStrategy(BaseStrategy):
    """ì €ë³€ë™ì„± ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("Low_Volatility_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ì €ë³€ë™ì„± ì „ëµ",
            description="ë³€ë™ì„±ì´ ë‚®ì€ ì¢…ëª©ìœ¼ë¡œ ì•ˆì •ì  ìˆ˜ìµ ì¶”êµ¬",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.SIMPLE,
            expected_return="8-11%",
            volatility="8-12%",
            min_investment_period="1ë…„ ì´ìƒ",
            rebalancing_frequency="ë¶„ê¸°ë³„"
        )
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        volatility_period = self.parameters.get('volatility_period', 60)
        low_vol_percentile = self.parameters.get('low_vol_percentile', 0.3)  # í•˜ìœ„ 30%
        
        signals = []
        volatilities = {}
        
        # ê° ì¢…ëª©ì˜ ë³€ë™ì„± ê³„ì‚°
        for symbol in data.index:
            prices = data.loc[symbol, 'close']
            if len(prices) < volatility_period:
                continue
            
            returns = prices.pct_change().dropna()
            volatility = returns.tail(volatility_period).std() * np.sqrt(252)  # ì—°ìœ¨í™”
            volatilities[symbol] = volatility
        
        if not volatilities:
            return []
        
        # ì €ë³€ë™ì„± ê¸°ì¤€ì„  ê³„ì‚°
        vol_values = list(volatilities.values())
        threshold = np.percentile(vol_values, low_vol_percentile * 100)
        
        for symbol, volatility in volatilities.items():
            if volatility <= threshold:
                # ë³€ë™ì„±ì´ ë‚®ì„ìˆ˜ë¡ ë†’ì€ ê°•ë„
                strength = 1.0 - (volatility / threshold)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=0.75,
                    metadata={'volatility': volatility}
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # ì—­ë³€ë™ì„± ê°€ì¤‘ì¹˜ (ë³€ë™ì„±ì´ ë‚®ì„ìˆ˜ë¡ ë†’ì€ ê°€ì¤‘ì¹˜)
        total_inv_strength = sum(1/signal.strength if signal.strength > 0 else 1 for signal in signals)
        weights = []
        
        for signal in signals:
            inv_strength = 1/signal.strength if signal.strength > 0 else 1
            weight = inv_strength / total_inv_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 9. í’ˆì§ˆ íŒ©í„° ì „ëµ
class QualityFactorStrategy(BaseStrategy):
    """í’ˆì§ˆ íŒ©í„° ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("Quality_Factor_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="í’ˆì§ˆ íŒ©í„° ì „ëµ",
            description="ROE, ë¶€ì±„ë¹„ìœ¨ ë“± ì¬ë¬´ ê±´ì „ì„± ìš°ìˆ˜ ê¸°ì—…",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.SIMPLE,
            expected_return="9-13%",
            volatility="12-16%",
            min_investment_period="2ë…„ ì´ìƒ",
            rebalancing_frequency="ë¶„ê¸°ë³„"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + ['roe', 'debt_ratio', 'current_ratio']
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        min_roe = self.parameters.get('min_roe', 0.15)
        max_debt_ratio = self.parameters.get('max_debt_ratio', 0.5)
        min_current_ratio = self.parameters.get('min_current_ratio', 1.2)
        
        signals = []
        quality_data = data.dropna(subset=['roe', 'debt_ratio', 'current_ratio'])
        
        for symbol in quality_data.index:
            roe = quality_data.loc[symbol, 'roe']
            debt_ratio = quality_data.loc[symbol, 'debt_ratio']
            current_ratio = quality_data.loc[symbol, 'current_ratio']
            
            # í’ˆì§ˆ ê¸°ì¤€ ì¶©ì¡± í™•ì¸
            if roe >= min_roe and debt_ratio <= max_debt_ratio and current_ratio >= min_current_ratio:
                # í’ˆì§ˆ ì ìˆ˜ ê³„ì‚° (ê° ì§€í‘œì˜ ìš°ìˆ˜ì„± ê¸°ì¤€)
                roe_score = min(1.0, roe / 0.3)  # ROE 30%ë¥¼ ë§Œì ìœ¼ë¡œ
                debt_score = max(0.0, (max_debt_ratio - debt_ratio) / max_debt_ratio)
                current_score = min(1.0, (current_ratio - 1.0) / 2.0)  # ìœ ë™ë¹„ìœ¨ 3.0ì„ ë§Œì ìœ¼ë¡œ
                
                quality_score = (roe_score + debt_score + current_score) / 3
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=quality_score,
                    confidence=0.8,
                    metadata={
                        'roe': roe,
                        'debt_ratio': debt_ratio,
                        'current_ratio': current_ratio,
                        'quality_score': quality_score
                    }
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # í’ˆì§ˆ ì ìˆ˜ ê¸°ë°˜ ê°€ì¤‘ì¹˜
        total_strength = sum(signal.strength for signal in signals)
        weights = []
        
        for signal in signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 10. ì •ê¸° ë¦¬ë°¸ëŸ°ì‹± ì „ëµ
class RegularRebalancingStrategy(BaseStrategy):
    """ì •ê¸° ë¦¬ë°¸ëŸ°ì‹± ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("Regular_Rebalancing_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ì •ê¸° ë¦¬ë°¸ëŸ°ì‹± ì „ëµ",
            description="ì •í•´ì§„ ë¹„ìœ¨ë¡œ ì •ê¸°ì  ë¦¬ë°¸ëŸ°ì‹±í•˜ì—¬ ìœ„í—˜ ê´€ë¦¬",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.SIMPLE,
            expected_return="8-12%",
            volatility="10-16%",
            min_investment_period="1ë…„ ì´ìƒ",
            rebalancing_frequency="ì›”ë³„"
        )
    
    def _get_required_parameters(self) -> List[str]:
        return ['target_allocation']
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        target_allocation = self.parameters.get('target_allocation', {})
        rebalance_threshold = self.parameters.get('rebalance_threshold', 0.05)  # 5% í¸ì°¨
        
        signals = []
        
        if not target_allocation:
            # ê¸°ë³¸ ë™ì¼ ê°€ì¤‘ì¹˜
            symbols = data.index.tolist()
            equal_weight = 1.0 / len(symbols)
            target_allocation = {symbol: equal_weight for symbol in symbols}
        
        current_portfolio = self.parameters.get('current_portfolio', {})
        
        for symbol, target_weight in target_allocation.items():
            current_weight = current_portfolio.get(symbol, 0.0)
            weight_diff = abs(target_weight - current_weight)
            
            if weight_diff > rebalance_threshold:
                if target_weight > current_weight:
                    signal_type = 'BUY'
                    strength = min(1.0, weight_diff / rebalance_threshold)
                else:
                    signal_type = 'SELL'
                    strength = min(1.0, weight_diff / rebalance_threshold)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type=signal_type,
                    strength=strength,
                    confidence=0.9,
                    metadata={
                        'target_weight': target_weight,
                        'current_weight': current_weight,
                        'weight_diff': weight_diff
                    }
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        target_allocation = self.parameters.get('target_allocation', {})
        
        if not target_allocation:
            return []
        
        weights = []
        
        for symbol, target_weight in target_allocation.items():
            current_weight = current_portfolio.get(symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight,
                rebalance_needed=abs(target_weight - current_weight) > 0.01
            ))
        
        return weights

# ì „ëµ íŒ©í† ë¦¬ì— ë“±ë¡
def register_basic_strategies():
    """ê¸°ë³¸ ì „ëµë“¤ì„ íŒ©í† ë¦¬ì— ë“±ë¡"""
    StrategyFactory.register_strategy("low_pe", LowPEStrategy)
    StrategyFactory.register_strategy("dividend_aristocrats", DividendAristocratsStrategy)
    StrategyFactory.register_strategy("simple_momentum", SimpleMomentumStrategy)
    StrategyFactory.register_strategy("moving_average_cross", MovingAverageCrossStrategy)
    StrategyFactory.register_strategy("rsi_mean_reversion", RSIMeanReversionStrategy)
    StrategyFactory.register_strategy("bollinger_band", BollingerBandStrategy)
    StrategyFactory.register_strategy("small_cap", SmallCapStrategy)
    StrategyFactory.register_strategy("low_volatility", LowVolatilityStrategy)
    StrategyFactory.register_strategy("quality_factor", QualityFactorStrategy)
    StrategyFactory.register_strategy("regular_rebalancing", RegularRebalancingStrategy)

# ëª¨ë“ˆ ë¡œë“œ ì‹œ ìë™ ë“±ë¡
register_basic_strategies()


==================================================
File: C:\Aproject\quant_platform\backend\quant_engine\cycle_contrarian_strategies.py
==================================================
"""
file: strategy_engine/cycle_contrarian_strategies.py
Cycle & Contrarian Strategies - ì‚¬ì´í´/ì—­ë°œìƒ ê´€ë ¨ ê³ ê¸‰ ì „ëµ 3ê°€ì§€
ë ˆì´ ë‹¬ë¦¬ì˜¤ì˜ ì˜¬ì›¨ë”, ë°ì´ë¹„ë“œ ë“œë ˆë¨¼ì˜ ì—­ë°œìƒ, ì¡´ ë„¤í”„ì˜ ì €PER+ë°°ë‹¹ ì „ëµ
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple
from base_strategy import BaseStrategy, StrategyMetadata, Signal, PortfolioWeight
from base_strategy import RiskLevel, Complexity, StrategyCategory, StrategyFactory
import technical_indicators as ti
import fundamental_metrics as fm

# 18. ë ˆì´ ë‹¬ë¦¬ì˜¤ì˜ ì˜¬ì›¨ë” í¬íŠ¸í´ë¦¬ì˜¤
class RayDalioAllWeatherStrategy(BaseStrategy):
    """ë ˆì´ ë‹¬ë¦¬ì˜¤ì˜ ì˜¬ì›¨ë” í¬íŠ¸í´ë¦¬ì˜¤ ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("Ray_Dalio_All_Weather_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ë ˆì´ ë‹¬ë¦¬ì˜¤ì˜ ì˜¬ì›¨ë” í¬íŠ¸í´ë¦¬ì˜¤",
            description="ê²½ì œ í™˜ê²½ ë³€í™”ì— ê´€ê³„ì—†ì´ ì•ˆì •ì  ìˆ˜ìµ ì¶”êµ¬",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.MEDIUM,
            expected_return="8-12%",
            volatility="8-12%",
            min_investment_period="5ë…„ ì´ìƒ",
            rebalancing_frequency="ë¶„ê¸°ë³„"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'asset_class', 'duration', 'correlation_matrix', 'volatility', 
            'inflation_sensitivity', 'growth_sensitivity'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        """ì˜¬ì›¨ë”ëŠ” ê³ ì • ë°°ë¶„ì´ë¯€ë¡œ ë¦¬ë°¸ëŸ°ì‹± ì‹ í˜¸ë§Œ ìƒì„±"""
        signals = []
        
        # ê¸°ë³¸ ì˜¬ì›¨ë” ë°°ë¶„
        target_allocation = self.parameters.get('target_allocation', {
            'stocks': 0.30,
            'long_term_bonds': 0.40,
            'intermediate_bonds': 0.15,
            'commodities': 0.075,
            'tips': 0.075  # Treasury Inflation-Protected Securities
        })
        
        current_allocation = self.parameters.get('current_allocation', {})
        rebalance_threshold = self.parameters.get('rebalance_threshold', 0.05)
        
        # ê° ìì‚°êµ°ë³„ ë¦¬ë°¸ëŸ°ì‹± í•„ìš”ì„± í™•ì¸
        for asset_class, target_weight in target_allocation.items():
            current_weight = current_allocation.get(asset_class, 0.0)
            weight_diff = target_weight - current_weight
            
            if abs(weight_diff) > rebalance_threshold:
                # ë¦¬ë°¸ëŸ°ì‹± ê°•ë„ëŠ” í¸ì°¨ í¬ê¸°ì— ë¹„ë¡€
                strength = min(1.0, abs(weight_diff) / rebalance_threshold)
                
                signal_type = 'BUY' if weight_diff > 0 else 'SELL'
                
                # ìì‚°êµ°ë³„ ëŒ€í‘œ ì¢…ëª©ë“¤ ì°¾ê¸°
                asset_symbols = self._get_asset_class_symbols(data, asset_class)
                
                for symbol in asset_symbols:
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type=signal_type,
                        strength=strength,
                        confidence=0.95,  # ì˜¬ì›¨ë”ëŠ” í™•ì‹ ë„ ë†’ìŒ
                        metadata={
                            'asset_class': asset_class,
                            'target_weight': target_weight,
                            'current_weight': current_weight,
                            'weight_diff': weight_diff,
                            'rebalancing_reason': 'all_weather_allocation'
                        }
                    ))
        
        return self.validate_signals(signals)
    
    def _get_asset_class_symbols(self, data: pd.DataFrame, asset_class: str) -> List[str]:
        """ìì‚°êµ°ë³„ í•´ë‹¹ ì¢…ëª©ë“¤ ë°˜í™˜"""
        if 'asset_class' not in data.columns:
            # ê¸°ë³¸ ë§¤í•‘ ì‚¬ìš©
            asset_mapping = {
                'stocks': ['SPY', 'VTI', 'ITOT'],
                'long_term_bonds': ['TLT', 'VGLT'],
                'intermediate_bonds': ['IEF', 'VGIT'],
                'commodities': ['DJP', 'PDBC', 'BCI'],
                'tips': ['TIPS', 'VTIP', 'SCHP']
            }
            return asset_mapping.get(asset_class, [])
        
        # ë°ì´í„°ì—ì„œ í•´ë‹¹ ìì‚°êµ° ì¢…ëª©ë“¤ ì°¾ê¸°
        asset_symbols = data[data['asset_class'] == asset_class].index.tolist()
        return asset_symbols[:3]  # ìµœëŒ€ 3ê°œê¹Œì§€
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        
        target_allocation = self.parameters.get('target_allocation', {
            'stocks': 0.30,
            'long_term_bonds': 0.40,
            'intermediate_bonds': 0.15,
            'commodities': 0.075,
            'tips': 0.075
        })
        
        weights = []
        
        # ê° ìì‚°êµ° ë‚´ì—ì„œ ë™ì¼ ê°€ì¤‘ì¹˜ ë°°ë¶„
        asset_weights = {}
        for signal in signals:
            asset_class = signal.metadata.get('asset_class')
            if asset_class not in asset_weights:
                asset_weights[asset_class] = []
            asset_weights[asset_class].append(signal.symbol)
        
        for asset_class, symbols in asset_weights.items():
            target_asset_weight = target_allocation.get(asset_class, 0.0)
            weight_per_symbol = target_asset_weight / len(symbols)
            
            for symbol in symbols:
                current_weight = current_portfolio.get(symbol, 0.0) if current_portfolio else 0.0
                
                weights.append(PortfolioWeight(
                    symbol=symbol,
                    weight=weight_per_symbol,
                    target_weight=weight_per_symbol,
                    current_weight=current_weight,
                    rebalance_needed=abs(weight_per_symbol - current_weight) > 0.01
                ))
        
        return weights

# 19. ë°ì´ë¹„ë“œ ë“œë ˆë¨¼ì˜ ì—­ë°œìƒ íˆ¬ì
class DavidDremanContrarianStrategy(BaseStrategy):
    """ë°ì´ë¹„ë“œ ë“œë ˆë¨¼ì˜ ì—­ë°œìƒ íˆ¬ì ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("David_Dreman_Contrarian_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ë°ì´ë¹„ë“œ ë“œë ˆë¨¼ì˜ ì—­ë°œìƒ íˆ¬ì",
            description="ì‹œì¥ ê³µí¬ì™€ ë¹„ê´€ë¡  ì†ì—ì„œ ì €í‰ê°€ ê¸°íšŒ ë°œêµ´",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.MEDIUM,
            expected_return="12-16%",
            volatility="16-22%",
            min_investment_period="2ë…„ ì´ìƒ",
            rebalancing_frequency="ë¶„ê¸°ë³„"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'pe_ratio', 'pb_ratio', 'sentiment_score', 'analyst_coverage',
            'news_sentiment', 'price_momentum_3m', 'earnings_surprise',
            'analyst_revisions', 'short_interest'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # ë“œë ˆë¨¼ì˜ ì—­ë°œìƒ ê¸°ì¤€
        max_pe_percentile = self.parameters.get('max_pe_percentile', 0.2)  # í•˜ìœ„ 20%
        fear_threshold = self.parameters.get('fear_threshold', -0.6)  # ë¶€ì •ì  ê°ì •
        min_market_cap = self.parameters.get('min_market_cap', 1000)  # 10ì–µ ë‹¬ëŸ¬
        
        contrarian_data = data.dropna(subset=['pe_ratio', 'pb_ratio'])
        
        # ì‹œì¥ ì „ì²´ ê³µí¬ ìˆ˜ì¤€ í™•ì¸
        market_fear_score = self._calculate_market_fear_level(contrarian_data)
        
        # ì‹œì¥ì´ ì¶©ë¶„íˆ ë¹„ê´€ì ì´ì§€ ì•Šìœ¼ë©´ ëŒ€ê¸°
        if market_fear_score > -0.5:
            return []
        
        # PE ê¸°ì¤€ì„  ê³„ì‚° (í•˜ìœ„ percentile)
        pe_threshold = contrarian_data['pe_ratio'].quantile(max_pe_percentile)
        
        for symbol in contrarian_data.index:
            company_data = contrarian_data.loc[symbol]
            
            # ê¸°ë³¸ ì €í‰ê°€ ì¡°ê±´
            pe_ratio = company_data['pe_ratio']
            pb_ratio = company_data['pb_ratio']
            market_cap = company_data.get('market_cap', 0)
            
            basic_value_conditions = [
                0 < pe_ratio <= pe_threshold,
                0 < pb_ratio <= 2.0,
                market_cap >= min_market_cap
            ]
            
            if not all(basic_value_conditions):
                continue
            
            # ì—­ë°œìƒ ì‹ í˜¸ í‰ê°€
            contrarian_score = self._evaluate_contrarian_signals(company_data)
            
            if contrarian_score >= 0.6:  # ì¶©ë¶„í•œ ì—­ë°œìƒ ì‹ í˜¸
                # ê°€ì¹˜ + ì—­ë°œìƒ ì¢…í•© ì ìˆ˜
                value_score = self._calculate_value_score(company_data, contrarian_data)
                final_strength = min(1.0, contrarian_score * value_score * 1.2)
                
                confidence = min(0.9, 0.6 + abs(market_fear_score) * 0.3)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=final_strength,
                    confidence=confidence,
                    metadata={
                        'contrarian_score': contrarian_score,
                        'value_score': value_score,
                        'market_fear_score': market_fear_score,
                        'pe_ratio': pe_ratio,
                        'pb_ratio': pb_ratio
                    }
                ))
        
        return self.validate_signals(signals)
    
    def _calculate_market_fear_level(self, data: pd.DataFrame) -> float:
        """ì‹œì¥ ì „ì²´ ê³µí¬ ìˆ˜ì¤€ ê³„ì‚°"""
        fear_indicators = []
        
        # VIX ìˆ˜ì¤€ (ìˆë‹¤ë©´)
        if 'vix' in data.columns:
            avg_vix = data['vix'].mean()
            if avg_vix > 30:
                fear_indicators.append(-0.8)
            elif avg_vix > 25:
                fear_indicators.append(-0.5)
            else:
                fear_indicators.append(0.2)
        
        # ì „ì²´ ì‹œì¥ ì‹¬ë¦¬
        if 'sentiment_score' in data.columns:
            avg_sentiment = data['sentiment_score'].mean()
            fear_indicators.append(avg_sentiment)
        
        # ë‰´ìŠ¤ ì‹¬ë¦¬
        if 'news_sentiment' in data.columns:
            avg_news_sentiment = data['news_sentiment'].mean()
            fear_indicators.append(avg_news_sentiment)
        
        # ë‹¨ê¸° ëª¨ë©˜í…€ (í•˜ë½ì´ í´ìˆ˜ë¡ ê³µí¬)
        if 'price_momentum_3m' in data.columns:
            avg_momentum = data['price_momentum_3m'].mean()
            if avg_momentum < -0.2:  # 20% í•˜ë½
                fear_indicators.append(-0.9)
            elif avg_momentum < -0.1:  # 10% í•˜ë½
                fear_indicators.append(-0.6)
            else:
                fear_indicators.append(0.0)
        
        return np.mean(fear_indicators) if fear_indicators else 0.0
    
    def _evaluate_contrarian_signals(self, company_data: pd.Series) -> float:
        """ê°œë³„ ì¢…ëª©ì˜ ì—­ë°œìƒ ì‹ í˜¸ í‰ê°€"""
        contrarian_score = 0.0
        
        # ë¶€ì •ì  ê°ì •
        sentiment = company_data.get('sentiment_score', 0.0)
        if sentiment <= -0.7:
            contrarian_score += 0.3
        elif sentiment <= -0.4:
            contrarian_score += 0.2
        
        # ì• ë„ë¦¬ìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ê°ì†Œ (ê´€ì‹¬ ì €í•˜)
        analyst_coverage = company_data.get('analyst_coverage', 10)
        if analyst_coverage <= 5:
            contrarian_score += 0.2
        
        # ì• ë„ë¦¬ìŠ¤íŠ¸ í•˜í–¥ ì¡°ì •
        analyst_revisions = company_data.get('analyst_revisions', 0.0)
        if analyst_revisions < -0.3:  # 30% í•˜í–¥
            contrarian_score += 0.25
        
        # ê³µë§¤ë„ ë¹„ìœ¨ ë†’ìŒ (ë¹„ê´€ë¡ )
        short_interest = company_data.get('short_interest', 0.05)
        if short_interest > 0.15:  # 15% ì´ìƒ
            contrarian_score += 0.25
        
        return min(1.0, contrarian_score)
    
    def _calculate_value_score(self, company_data: pd.Series, universe_data: pd.DataFrame) -> float:
        """ê°€ì¹˜ í‰ê°€ ì ìˆ˜"""
        value_score = 0.0
        
        # PE ìƒëŒ€ ìˆœìœ„ (ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)
        pe_ratio = company_data['pe_ratio']
        pe_rank = 1 - (universe_data['pe_ratio'] <= pe_ratio).mean()
        value_score += pe_rank * 0.5
        
        # PB ìƒëŒ€ ìˆœìœ„
        pb_ratio = company_data['pb_ratio']
        pb_rank = 1 - (universe_data['pb_ratio'] <= pb_ratio).mean()
        value_score += pb_rank * 0.3
        
        # ì–´ë‹ ì„œí”„ë¼ì´ì¦ˆ ë³´ë„ˆìŠ¤
        earnings_surprise = company_data.get('earnings_surprise', 0.0)
        if earnings_surprise > 0.1:  # 10% ì„œí”„ë¼ì´ì¦ˆ
            value_score += 0.2
        
        return min(1.0, value_score)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # ì—­ë°œìƒ ê°•ë„ ê¸°ë°˜ ê°€ì¤‘ì¹˜
        weights = []
        total_strength = sum(signal.strength for signal in signals)
        
        for signal in signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 20. ì¡´ ë„¤í”„ì˜ ì €PER + ë°°ë‹¹ ì „ëµ
class JohnNeffLowPEDividendStrategy(BaseStrategy):
    """ì¡´ ë„¤í”„ì˜ ì €PER + ë°°ë‹¹ ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("John_Neff_Low_PE_Dividend_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ì¡´ ë„¤í”„ì˜ ì €PER + ë°°ë‹¹ ì „ëµ",
            description="ì†Œì™¸ë°›ëŠ” ì—…ì¢…ì—ì„œ ì €PER + ê³ ë°°ë‹¹ ë³´ì„ ë°œêµ´",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.MEDIUM,
            expected_return="11-15%",
            volatility="14-18%",
            min_investment_period="3ë…„ ì´ìƒ",
            rebalancing_frequency="ë°˜ê¸°ë³„"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'pe_ratio', 'dividend_yield', 'earnings_growth_rate', 
            'total_return_potential', 'industry_popularity', 'peg_ratio'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # ë„¤í”„ì˜ ê¸°ë³¸ ê¸°ì¤€
        market_pe_discount = self.parameters.get('market_pe_discount', 0.6)  # ì‹œì¥ PEì˜ 60%
        min_dividend_yield = self.parameters.get('min_dividend_yield', 0.03)  # 3%
        target_total_return = self.parameters.get('target_total_return', 0.12)  # 12%
        max_peg = self.parameters.get('max_peg', 0.5)  # PEG 0.5 ì´í•˜
        
        neff_data = data.dropna(subset=['pe_ratio', 'dividend_yield'])
        
        if len(neff_data) == 0:
            return []
        
        # ì‹œì¥ í‰ê·  PE ê³„ì‚°
        market_pe = neff_data['pe_ratio'].median()
        target_pe_threshold = market_pe * market_pe_discount
        
        for symbol in neff_data.index:
            company_data = neff_data.loc[symbol]
            
            pe_ratio = company_data['pe_ratio']
            dividend_yield = company_data['dividend_yield']
            
            # ê¸°ë³¸ ì¡°ê±´ í™•ì¸
            basic_conditions = [
                0 < pe_ratio <= target_pe_threshold,
                dividend_yield >= min_dividend_yield
            ]
            
            if not all(basic_conditions):
                continue
            
            # ë„¤í”„ì˜ ì´ìˆ˜ìµë¥  ê³µì‹ í‰ê°€
            total_return_score = self._calculate_neff_total_return(company_data)
            
            if total_return_score >= target_total_return:
                # ì†Œì™¸ ì—…ì¢… ë³´ë„ˆìŠ¤
                neglected_bonus = self._evaluate_neglected_sector(company_data)
                
                # PEG ë¹„ìœ¨ í™•ì¸
                peg_ratio = company_data.get('peg_ratio', 1.0)
                peg_bonus = 1.0 if peg_ratio <= max_peg else 0.7
                
                # ìµœì¢… ê°•ë„ ê³„ì‚°
                base_strength = min(1.0, total_return_score / target_total_return)
                final_strength = base_strength * neglected_bonus * peg_bonus
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=final_strength,
                    confidence=0.8,
                    metadata={
                        'total_return_score': total_return_score,
                        'neglected_bonus': neglected_bonus,
                        'peg_bonus': peg_bonus,
                        'pe_ratio': pe_ratio,
                        'dividend_yield': dividend_yield,
                        'peg_ratio': peg_ratio,
                        'market_pe': market_pe
                    }
                ))
        
        return self.validate_signals(signals)
    
    def _calculate_neff_total_return(self, company_data: pd.Series) -> float:
        """ë„¤í”„ì˜ ì´ìˆ˜ìµë¥  ê³„ì‚°ë²•"""
        # ì´ìˆ˜ìµë¥  = ë°°ë‹¹ìˆ˜ìµë¥  + ì˜ˆìƒ ì£¼ê°€ìƒìŠ¹ë¥ 
        dividend_yield = company_data['dividend_yield']
        
        # ì˜ˆìƒ ì£¼ê°€ìƒìŠ¹ë¥  ì¶”ì •
        earnings_growth = company_data.get('earnings_growth_rate', 0.05)
        pe_ratio = company_data['pe_ratio']
        
        # ê°„ë‹¨í•œ ì£¼ê°€ìƒìŠ¹ë¥  ì¶”ì •: ìˆ˜ìµ ì„±ì¥ë¥  + PE ì •ìƒí™” ê¸°ëŒ€
        # PEê°€ ë‚®ìœ¼ë©´ PE í™•ì¥ ê°€ëŠ¥ì„±
        normal_pe = 15  # ì •ìƒ PE ê°€ì •
        pe_expansion_potential = max(0, (normal_pe - pe_ratio) / pe_ratio * 0.3)  # 30% ë°˜ì˜
        
        expected_price_appreciation = earnings_growth + pe_expansion_potential
        total_return = dividend_yield + expected_price_appreciation
        
        return total_return
    
    def _evaluate_neglected_sector(self, company_data: pd.Series) -> float:
        """ì†Œì™¸ë°›ëŠ” ì—…ì¢…/ì¢…ëª© í‰ê°€"""
        neglected_score = 1.0  # ê¸°ë³¸ê°’
        
        # ì—…ì¢… ì¸ê¸°ë„ (ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)
        industry_popularity = company_data.get('industry_popularity', 0.5)
        if industry_popularity <= 0.3:  # í•˜ìœ„ 30%
            neglected_score *= 1.2
        elif industry_popularity <= 0.5:  # í•˜ìœ„ 50%
            neglected_score *= 1.1
        
        return min(1.3, neglected_score)  # ìµœëŒ€ 30% ë³´ë„ˆìŠ¤
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # ì´ìˆ˜ìµë¥  ê¸°ëŒ€ì¹˜ ê¸°ë°˜ ê°€ì¤‘ì¹˜
        weights = []
        total_return_sum = sum(signal.metadata.get('total_return_score', 0.12) for signal in signals)
        
        for signal in signals:
            expected_return = signal.metadata.get('total_return_score', 0.12)
            weight = expected_return / total_return_sum
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# ì „ëµ íŒ©í† ë¦¬ì— ë“±ë¡
def register_cycle_contrarian_strategies():
    """ì‚¬ì´í´/ì—­ë°œìƒ ì „ëµë“¤ì„ íŒ©í† ë¦¬ì— ë“±ë¡"""
    StrategyFactory.register_strategy("ray_dalio_all_weather", RayDalioAllWeatherStrategy)
    StrategyFactory.register_strategy("david_dreman_contrarian", DavidDremanContrarianStrategy)
    StrategyFactory.register_strategy("john_neff_low_pe_dividend", JohnNeffLowPEDividendStrategy)

# ëª¨ë“ˆ ë¡œë“œ ì‹œ ìë™ ë“±ë¡
register_cycle_contrarian_strategies()



==================================================
File: C:\Aproject\quant_platform\backend\quant_engine\fundamental_metrics.py
==================================================
"""
file: strategy_engine/fundamental_metrics.py
Fundamental Metrics Module - ì¬ë¬´ë¹„ìœ¨ ê³„ì‚° í•¨ìˆ˜ë“¤
PER, PBR, ROE, ë¶€ì±„ë¹„ìœ¨ ë“± í€ë”ë©˜í„¸ ì§€í‘œë“¤ 200ì—¬ ë¼ì¸
"""

import pandas as pd
import numpy as np
from typing import Dict, Optional, Union, Tuple
import warnings

# ë°¸ë¥˜ì—ì´ì…˜ ì§€í‘œë“¤
def price_to_earnings_ratio(price: float, earnings_per_share: float) -> Optional[float]:
    """ì£¼ê°€ìˆ˜ìµë¹„ìœ¨ (PER)"""
    if earnings_per_share <= 0:
        return None
    return price / earnings_per_share

def price_to_book_ratio(price: float, book_value_per_share: float) -> Optional[float]:
    """ì£¼ê°€ìˆœìì‚°ë¹„ìœ¨ (PBR)"""
    if book_value_per_share <= 0:
        return None
    return price / book_value_per_share

def price_to_sales_ratio(market_cap: float, revenue: float) -> Optional[float]:
    """ì£¼ê°€ë§¤ì¶œë¹„ìœ¨ (PSR)"""
    if revenue <= 0:
        return None
    return market_cap / revenue

def price_earnings_growth_ratio(pe_ratio: float, earnings_growth_rate: float) -> Optional[float]:
    """PEG ë¹„ìœ¨"""
    if earnings_growth_rate <= 0:
        return None
    return pe_ratio / (earnings_growth_rate * 100)

def enterprise_value_to_ebitda(enterprise_value: float, ebitda: float) -> Optional[float]:
    """EV/EBITDA"""
    if ebitda <= 0:
        return None
    return enterprise_value / ebitda

def enterprise_value_to_sales(enterprise_value: float, revenue: float) -> Optional[float]:
    """EV/Sales"""
    if revenue <= 0:
        return None
    return enterprise_value / revenue

# ìˆ˜ìµì„± ì§€í‘œë“¤
def return_on_equity(net_income: float, shareholders_equity: float) -> Optional[float]:
    """ìê¸°ìë³¸ìˆ˜ìµë¥  (ROE)"""
    if shareholders_equity <= 0:
        return None
    return net_income / shareholders_equity

def return_on_assets(net_income: float, total_assets: float) -> Optional[float]:
    """ì´ìì‚°ìˆ˜ìµë¥  (ROA)"""
    if total_assets <= 0:
        return None
    return net_income / total_assets

def return_on_invested_capital(nopat: float, invested_capital: float) -> Optional[float]:
    """íˆ¬í•˜ìë³¸ìˆ˜ìµë¥  (ROIC)"""
    if invested_capital <= 0:
        return None
    return nopat / invested_capital

def gross_profit_margin(gross_profit: float, revenue: float) -> Optional[float]:
    """ë§¤ì¶œì´ì´ìµë¥ """
    if revenue <= 0:
        return None
    return gross_profit / revenue

def operating_profit_margin(operating_income: float, revenue: float) -> Optional[float]:
    """ì˜ì—…ì´ìµë¥ """
    if revenue <= 0:
        return None
    return operating_income / revenue

def net_profit_margin(net_income: float, revenue: float) -> Optional[float]:
    """ìˆœì´ìµë¥ """
    if revenue <= 0:
        return None
    return net_income / revenue

def ebitda_margin(ebitda: float, revenue: float) -> Optional[float]:
    """EBITDA ë§ˆì§„"""
    if revenue <= 0:
        return None
    return ebitda / revenue

# ì•ˆì •ì„±/ë ˆë²„ë¦¬ì§€ ì§€í‘œë“¤
def debt_to_equity_ratio(total_debt: float, shareholders_equity: float) -> Optional[float]:
    """ë¶€ì±„ë¹„ìœ¨"""
    if shareholders_equity <= 0:
        return None
    return total_debt / shareholders_equity

def debt_to_assets_ratio(total_debt: float, total_assets: float) -> Optional[float]:
    """ë¶€ì±„ìì‚°ë¹„ìœ¨"""
    if total_assets <= 0:
        return None
    return total_debt / total_assets

def current_ratio(current_assets: float, current_liabilities: float) -> Optional[float]:
    """ìœ ë™ë¹„ìœ¨"""
    if current_liabilities <= 0:
        return None
    return current_assets / current_liabilities

def quick_ratio(current_assets: float, inventory: float, current_liabilities: float) -> Optional[float]:
    """ë‹¹ì¢Œë¹„ìœ¨"""
    if current_liabilities <= 0:
        return None
    return (current_assets - inventory) / current_liabilities

def interest_coverage_ratio(ebit: float, interest_expense: float) -> Optional[float]:
    """ì´ìë³´ìƒë¹„ìœ¨"""
    if interest_expense <= 0:
        return None
    return ebit / interest_expense

def cash_ratio(cash_and_equivalents: float, current_liabilities: float) -> Optional[float]:
    """í˜„ê¸ˆë¹„ìœ¨"""
    if current_liabilities <= 0:
        return None
    return cash_and_equivalents / current_liabilities

# íš¨ìœ¨ì„± ì§€í‘œë“¤
def asset_turnover(revenue: float, total_assets: float) -> Optional[float]:
    """ìì‚°íšŒì „ìœ¨"""
    if total_assets <= 0:
        return None
    return revenue / total_assets

def inventory_turnover(cost_of_goods_sold: float, average_inventory: float) -> Optional[float]:
    """ì¬ê³ íšŒì „ìœ¨"""
    if average_inventory <= 0:
        return None
    return cost_of_goods_sold / average_inventory

def receivables_turnover(revenue: float, average_receivables: float) -> Optional[float]:
    """ë§¤ì¶œì±„ê¶ŒíšŒì „ìœ¨"""
    if average_receivables <= 0:
        return None
    return revenue / average_receivables

def days_sales_outstanding(average_receivables: float, revenue: float) -> Optional[float]:
    """ë§¤ì¶œì±„ê¶ŒíšŒìˆ˜ê¸°ê°„ (DSO)"""
    if revenue <= 0:
        return None
    return (average_receivables / revenue) * 365

def days_inventory_outstanding(average_inventory: float, cost_of_goods_sold: float) -> Optional[float]:
    """ì¬ê³ íšŒì „ê¸°ê°„ (DIO)"""
    if cost_of_goods_sold <= 0:
        return None
    return (average_inventory / cost_of_goods_sold) * 365

def cash_conversion_cycle(dso: float, dio: float, dpo: float) -> float:
    """í˜„ê¸ˆì „í™˜ì£¼ê¸° (CCC)"""
    return dso + dio - dpo

# ì„±ì¥ë¥  ì§€í‘œë“¤
def revenue_growth_rate(current_revenue: float, previous_revenue: float) -> Optional[float]:
    """ë§¤ì¶œ ì„±ì¥ë¥ """
    if previous_revenue <= 0:
        return None
    return (current_revenue - previous_revenue) / previous_revenue

def earnings_growth_rate(current_earnings: float, previous_earnings: float) -> Optional[float]:
    """ìˆœì´ìµ ì„±ì¥ë¥ """
    if previous_earnings <= 0:
        return None
    return (current_earnings - previous_earnings) / previous_earnings

def compound_annual_growth_rate(beginning_value: float, ending_value: float, periods: int) -> Optional[float]:
    """ì—°í‰ê· ì„±ì¥ë¥  (CAGR)"""
    if beginning_value <= 0 or periods <= 0:
        return None
    return (ending_value / beginning_value) ** (1/periods) - 1

def sustainable_growth_rate(roe: float, dividend_payout_ratio: float) -> float:
    """ì§€ì†ê°€ëŠ¥ì„±ì¥ë¥ """
    retention_ratio = 1 - dividend_payout_ratio
    return roe * retention_ratio

# ë°°ë‹¹ ê´€ë ¨ ì§€í‘œë“¤
def dividend_yield(annual_dividend: float, stock_price: float) -> Optional[float]:
    """ë°°ë‹¹ìˆ˜ìµë¥ """
    if stock_price <= 0:
        return None
    return annual_dividend / stock_price

def dividend_payout_ratio(dividend_per_share: float, earnings_per_share: float) -> Optional[float]:
    """ë°°ë‹¹ì„±í–¥"""
    if earnings_per_share <= 0:
        return None
    return dividend_per_share / earnings_per_share

def dividend_coverage_ratio(earnings_per_share: float, dividend_per_share: float) -> Optional[float]:
    """ë°°ë‹¹ì»¤ë²„ë¦¬ì§€"""
    if dividend_per_share <= 0:
        return None
    return earnings_per_share / dividend_per_share

# ì¢…í•© í‰ê°€ ì§€í‘œë“¤
def piotroski_f_score(financial_data: Dict[str, float]) -> int:
    """í”¼ì˜¤íŠ¸ë¡œìŠ¤í‚¤ F-Score (ì¬ë¬´ê±´ì „ì„± ì ìˆ˜)"""
    score = 0
    
    # ìˆ˜ìµì„± (4ì )
    if financial_data.get('net_income', 0) > 0:
        score += 1
    if financial_data.get('roa', 0) > 0:
        score += 1
    if financial_data.get('operating_cash_flow', 0) > 0:
        score += 1
    if financial_data.get('operating_cash_flow', 0) > financial_data.get('net_income', 0):
        score += 1
    
    # ë ˆë²„ë¦¬ì§€, ìœ ë™ì„±, ìê¸ˆ ì¡°ë‹¬ (3ì )
    if financial_data.get('debt_to_equity_current', 0) < financial_data.get('debt_to_equity_previous', 1):
        score += 1
    if financial_data.get('current_ratio_current', 0) > financial_data.get('current_ratio_previous', 0):
        score += 1
    if financial_data.get('shares_outstanding_current', 0) <= financial_data.get('shares_outstanding_previous', 1):
        score += 1
    
    # ìš´ì˜ íš¨ìœ¨ì„± (2ì )
    if financial_data.get('gross_margin_current', 0) > financial_data.get('gross_margin_previous', 0):
        score += 1
    if financial_data.get('asset_turnover_current', 0) > financial_data.get('asset_turnover_previous', 0):
        score += 1
    
    return score

def altman_z_score(financial_data: Dict[str, float]) -> Optional[float]:
    """ì•ŒíŠ¸ë§Œ Z-Score (íŒŒì‚° ìœ„í—˜ë„)"""
    try:
        working_capital = financial_data['current_assets'] - financial_data['current_liabilities']
        total_assets = financial_data['total_assets']
        market_value_equity = financial_data['market_cap']
        total_liabilities = financial_data['total_liabilities']
        revenue = financial_data['revenue']
        retained_earnings = financial_data['retained_earnings']
        ebit = financial_data['ebit']
        
        if total_assets <= 0:
            return None
        
        z1 = 1.2 * (working_capital / total_assets)
        z2 = 1.4 * (retained_earnings / total_assets)
        z3 = 3.3 * (ebit / total_assets)
        z4 = 0.6 * (market_value_equity / total_liabilities)
        z5 = 1.0 * (revenue / total_assets)
        
        z_score = z1 + z2 + z3 + z4 + z5
        return z_score
        
    except (KeyError, ZeroDivisionError):
        return None

def m_score(financial_data: Dict[str, float]) -> Optional[float]:
    """ë² ë‹ˆì‹œ M-Score (ë¶„ì‹íšŒê³„ íƒì§€)"""
    try:
        # ê°„ë‹¨í™”ëœ M-Score ê³„ì‚°
        score = 0.0
        
        # Days Sales Outstanding Index
        dso_current = financial_data.get('dso_current', 0)
        dso_previous = financial_data.get('dso_previous', 1)
        dsri = dso_current / dso_previous if dso_previous != 0 else 1
        
        # Gross Margin Index
        gm_current = financial_data.get('gross_margin_current', 0)
        gm_previous = financial_data.get('gross_margin_previous', 0)
        gmi = gm_previous / gm_current if gm_current != 0 else 1
        
        # Asset Quality Index
        total_assets = financial_data.get('total_assets', 1)
        ppe = financial_data.get('ppe', 0)
        current_assets = financial_data.get('current_assets', 0)
        aqi = (total_assets - current_assets - ppe) / total_assets
        
        # Sales Growth Index
        sales_current = financial_data.get('revenue_current', 1)
        sales_previous = financial_data.get('revenue_previous', 1)
        sgi = sales_current / sales_previous
        
        # Simplified M-Score
        m_score_value = -4.84 + 0.92*dsri + 0.528*gmi + 0.404*aqi + 0.892*sgi
        
        return m_score_value
        
    except (KeyError, ZeroDivisionError):
        return None

# ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
def calculate_enterprise_value(market_cap: float, total_debt: float, cash: float) -> float:
    """ê¸°ì—…ê°€ì¹˜ (EV) ê³„ì‚°"""
    return market_cap + total_debt - cash

def calculate_book_value_per_share(shareholders_equity: float, shares_outstanding: float) -> Optional[float]:
    """ì£¼ë‹¹ìˆœìì‚° (BPS)"""
    if shares_outstanding <= 0:
        return None
    return shareholders_equity / shares_outstanding

def calculate_earnings_per_share(net_income: float, shares_outstanding: float) -> Optional[float]:
    """ì£¼ë‹¹ìˆœì´ìµ (EPS)"""
    if shares_outstanding <= 0:
        return None
    return net_income / shares_outstanding

def calculate_free_cash_flow(operating_cash_flow: float, capex: float) -> float:
    """ì‰ì—¬í˜„ê¸ˆíë¦„ (FCF)"""
    return operating_cash_flow - capex

def calculate_fcf_per_share(free_cash_flow: float, shares_outstanding: float) -> Optional[float]:
    """ì£¼ë‹¹ì‰ì—¬í˜„ê¸ˆíë¦„"""
    if shares_outstanding <= 0:
        return None
    return free_cash_flow / shares_outstanding

def working_capital(current_assets: float, current_liabilities: float) -> float:
    """ìš´ì „ìë³¸"""
    return current_assets - current_liabilities

def normalize_ratio(ratio_value: Optional[float], industry_median: float) -> Optional[float]:
    """ì—…ì¢… ëŒ€ë¹„ ì •ê·œí™”"""
    if ratio_value is None or industry_median <= 0:
        return None
    return ratio_value / industry_median

def calculate_quality_score(financial_data: Dict[str, float]) -> float:
    """ì¢…í•© í’ˆì§ˆ ì ìˆ˜ (0-1)"""
    score = 0.0
    max_score = 0.0
    
    # ROE
    roe = financial_data.get('roe', 0)
    if roe > 0.15:
        score += 0.25
    elif roe > 0.10:
        score += 0.15
    max_score += 0.25
    
    # ë¶€ì±„ë¹„ìœ¨
    debt_ratio = financial_data.get('debt_to_equity', 1.0)
    if debt_ratio < 0.3:
        score += 0.2
    elif debt_ratio < 0.5:
        score += 0.15
    max_score += 0.2
    
    # ìœ ë™ë¹„ìœ¨
    current_ratio = financial_data.get('current_ratio', 1.0)
    if current_ratio > 2.0:
        score += 0.15
    elif current_ratio > 1.5:
        score += 0.1
    max_score += 0.15
    
    # ì´ìµ ì„±ì¥ë¥ 
    earnings_growth = financial_data.get('earnings_growth', 0)
    if earnings_growth > 0.1:
        score += 0.2
    elif earnings_growth > 0.05:
        score += 0.1
    max_score += 0.2
    
    # ë§¤ì¶œ ì„±ì¥ë¥ 
    revenue_growth = financial_data.get('revenue_growth', 0)
    if revenue_growth > 0.1:
        score += 0.2
    elif revenue_growth > 0.05:
        score += 0.1
    max_score += 0.2
    
    return score / max_score if max_score > 0 else 0.0

def calculate_financial_strength_rank(financial_data: Dict[str, float]) -> str:
    """ì¬ë¬´ ê±´ì „ì„± ë“±ê¸‰"""
    score = 0
    
    # ìˆ˜ìµì„±
    roe = financial_data.get('roe', 0)
    if roe > 0.2:
        score += 3
    elif roe > 0.15:
        score += 2
    elif roe > 0.1:
        score += 1
    
    # ì•ˆì •ì„±
    debt_ratio = financial_data.get('debt_to_equity', 1.0)
    if debt_ratio < 0.3:
        score += 3
    elif debt_ratio < 0.5:
        score += 2
    elif debt_ratio < 0.8:
        score += 1
    
    # ìœ ë™ì„±
    current_ratio = financial_data.get('current_ratio', 1.0)
    if current_ratio > 3.0:
        score += 3
    elif current_ratio > 2.0:
        score += 2
    elif current_ratio > 1.2:
        score += 1
    
    # ì„±ì¥ì„±
    revenue_growth = financial_data.get('revenue_growth', 0)
    if revenue_growth > 0.15:
        score += 3
    elif revenue_growth > 0.1:
        score += 2
    elif revenue_growth > 0.05:
        score += 1
    
    # ë“±ê¸‰ ë§¤í•‘
    if score >= 10:
        return 'A+'
    elif score >= 8:
        return 'A'
    elif score >= 6:
        return 'B+'
    elif score >= 4:
        return 'B'
    elif score >= 2:
        return 'C'
    else:
        return 'D'



==================================================
File: C:\Aproject\quant_platform\backend\quant_engine\growth_momentum_stratigies.py
==================================================
"""
file: strategy_engine/growth_momentum_stratigies.py
Growth & Momentum Strategies - ì„±ì¥/ëª¨ë©˜í…€ ê´€ë ¨ ê³ ê¸‰ ì „ëµ 3ê°€ì§€
ìœŒë¦¬ì—„ ì˜¤ë‹ì˜ CAN SLIM, ì œì„ìŠ¤ ì˜¤ì‡¼ë„¤ì‹œ ì „ëµ í¬í•¨
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple
from base_strategy import BaseStrategy, StrategyMetadata, Signal, PortfolioWeight
from base_strategy import RiskLevel, Complexity, StrategyCategory, StrategyFactory
import technical_indicators as ti
import fundamental_metrics as fm

# 15. ìœŒë¦¬ì—„ ì˜¤ë‹ì˜ CAN SLIM ì „ëµ
class WilliamONeilCANSLIMStrategy(BaseStrategy):
    """ìœŒë¦¬ì—„ ì˜¤ë‹ì˜ CAN SLIM ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("William_ONeil_CANSLIM_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ìœŒë¦¬ì—„ ì˜¤ë‹ì˜ CAN SLIM",
            description="7ê°€ì§€ ê¸°ì¤€ìœ¼ë¡œ ê³ ì„±ì¥ì£¼ ë°œêµ´, ëª¨ë©˜í…€ê³¼ í€ë”ë©˜í„¸ ê²°í•©",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.HIGH,
            complexity=Complexity.COMPLEX,
            expected_return="15-25%",
            volatility="20-30%",
            min_investment_period="6ê°œì›”-2ë…„",
            rebalancing_frequency="ì›”ë³„"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'eps_growth_current', 'eps_growth_annual', 'new_products', 'new_management',
            'supply_demand', 'leading_stock', 'institutional_ownership', 'market_direction',
            'price_52w_high', 'relative_strength', 'industry_rank'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # CAN SLIM ê° ìš”ì†Œë³„ ìµœì†Œ ê¸°ì¤€
        min_current_earnings = self.parameters.get('min_current_earnings', 0.25)  # 25%
        min_annual_earnings = self.parameters.get('min_annual_earnings', 0.25)   # 25%
        min_relative_strength = self.parameters.get('min_relative_strength', 80)  # 80 ì´ìƒ
        min_institutional_ownership = self.parameters.get('min_institutional_ownership', 0.1)
        price_near_high_threshold = self.parameters.get('price_near_high', 0.85)  # 52ì£¼ ê³ ì ì˜ 85%
        
        canslim_data = data.dropna(subset=['eps_growth_current', 'eps_growth_annual'])
        
        for symbol in canslim_data.index:
            company_data = canslim_data.loc[symbol]
            
            # CAN SLIM 7ê°€ì§€ ê¸°ì¤€ í‰ê°€
            canslim_scores = self._evaluate_canslim_criteria(company_data)
            
            # ê° ê¸°ì¤€ë³„ ì ìˆ˜
            c_score = canslim_scores['current_earnings']
            a_score = canslim_scores['annual_earnings']
            n_score = canslim_scores['new_factors']
            s_score = canslim_scores['supply_demand']
            l_score = canslim_scores['leader']
            i_score = canslim_scores['institutional']
            m_score = canslim_scores['market_direction']
            
            # ì¢…í•© CAN SLIM ì ìˆ˜
            total_score = (c_score + a_score + n_score + s_score + l_score + i_score + m_score) / 7
            
            # ìµœì†Œ ê¸°ì¤€ ì¶©ì¡± í™•ì¸
            basic_requirements = [
                c_score >= 0.6,  # C: í˜„ì¬ ë¶„ê¸° ìˆ˜ìµ 25% ì´ìƒ ì¦ê°€
                a_score >= 0.6,  # A: ì—°ê°„ ìˆ˜ìµ ì¦ê°€ ì§€ì†
                l_score >= 0.6,  # L: ì—…ì¢… ì„ ë„ì£¼
                m_score >= 0.5   # M: ì‹œì¥ ë°©í–¥ í™•ì¸
            ]
            
            if sum(basic_requirements) >= 3 and total_score >= 0.65:
                # ì¶”ê°€ ê¸°ìˆ ì  í™•ì¸
                technical_score = self._evaluate_technical_breakout(company_data)
                
                if technical_score >= 0.6:
                    final_strength = min(1.0, total_score * technical_score * 1.2)
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=final_strength,
                        confidence=0.75,
                        metadata={
                            'canslim_total_score': total_score,
                            'technical_score': technical_score,
                            'c_score': c_score,
                            'a_score': a_score,
                            'n_score': n_score,
                            's_score': s_score,
                            'l_score': l_score,
                            'i_score': i_score,
                            'm_score': m_score
                        }
                    ))
        
        return self.validate_signals(signals)
    
    def _evaluate_canslim_criteria(self, company_data: pd.Series) -> Dict[str, float]:
        """CAN SLIM 7ê°€ì§€ ê¸°ì¤€ í‰ê°€"""
        scores = {}
        
        # C - Current Earnings (í˜„ì¬ ë¶„ê¸° ìˆ˜ìµ)
        current_eps_growth = company_data.get('eps_growth_current', 0)
        if current_eps_growth >= 0.5:  # 50% ì´ìƒ
            scores['current_earnings'] = 1.0
        elif current_eps_growth >= 0.25:  # 25% ì´ìƒ
            scores['current_earnings'] = 0.8
        elif current_eps_growth >= 0.1:   # 10% ì´ìƒ
            scores['current_earnings'] = 0.6
        else:
            scores['current_earnings'] = 0.2
        
        # A - Annual Earnings (ì—°ê°„ ìˆ˜ìµ ì¦ê°€)
        annual_eps_growth = company_data.get('eps_growth_annual', 0)
        if annual_eps_growth >= 0.25:  # 25% ì´ìƒ
            scores['annual_earnings'] = 1.0
        elif annual_eps_growth >= 0.15:  # 15% ì´ìƒ
            scores['annual_earnings'] = 0.8
        else:
            scores['annual_earnings'] = 0.4
        
        # N - New (ì‹ ì œí’ˆ, ì‹ ê²½ì˜, ì‹ ê³ ì )
        new_score = 0
        if company_data.get('new_products', False):
            new_score += 0.4
        if company_data.get('new_management', False):
            new_score += 0.3
        # 52ì£¼ ì‹ ê³ ì  ê·¼ì²˜
        price_vs_high = company_data.get('price_52w_high', 0)
        if price_vs_high >= 0.85:  # 52ì£¼ ê³ ì ì˜ 85% ì´ìƒ
            new_score += 0.3
        scores['new_factors'] = min(1.0, new_score)
        
        # S - Supply and Demand (ìˆ˜ê¸‰)
        supply_demand = company_data.get('supply_demand', 0.5)
        scores['supply_demand'] = supply_demand
        
        # L - Leader (ì—…ì¢… ì„ ë„ì£¼)
        leading_stock = company_data.get('leading_stock', False)
        industry_rank = company_data.get('industry_rank', 50)
        if leading_stock and industry_rank <= 10:
            scores['leader'] = 1.0
        elif industry_rank <= 20:
            scores['leader'] = 0.8
        elif industry_rank <= 40:
            scores['leader'] = 0.6
        else:
            scores['leader'] = 0.3
        
        # I - Institutional Sponsorship (ê¸°ê´€ í›„ì›)
        institutional_ownership = company_data.get('institutional_ownership', 0)
        if institutional_ownership >= 0.2:  # 20% ì´ìƒ
            scores['institutional'] = 1.0
        elif institutional_ownership >= 0.1:  # 10% ì´ìƒ
            scores['institutional'] = 0.7
        else:
            scores['institutional'] = 0.4
        
        # M - Market Direction (ì‹œì¥ ë°©í–¥)
        market_direction = company_data.get('market_direction', 0.5)
        scores['market_direction'] = market_direction
        
        return scores
    
    def _evaluate_technical_breakout(self, company_data: pd.Series) -> float:
        """ê¸°ìˆ ì  ëŒíŒŒ íŒ¨í„´ í‰ê°€"""
        technical_score = 0.0
        
        # ìƒëŒ€ê°•ë„ (RS Rating)
        relative_strength = company_data.get('relative_strength', 50)
        if relative_strength >= 90:
            technical_score += 0.4
        elif relative_strength >= 80:
            technical_score += 0.3
        elif relative_strength >= 70:
            technical_score += 0.2
        
        # 52ì£¼ ê³ ì  ê·¼ì²˜
        price_vs_high = company_data.get('price_52w_high', 0)
        if price_vs_high >= 0.95:  # 95% ì´ìƒ
            technical_score += 0.3
        elif price_vs_high >= 0.85:  # 85% ì´ìƒ
            technical_score += 0.2
        
        # ê±°ë˜ëŸ‰ ì¦ê°€ (ê°„ì ‘ ì§€í‘œ)
        volume_score = company_data.get('volume_increase', 0.5)
        technical_score += volume_score * 0.3
        
        return min(1.0, technical_score)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # ì„±ì¥ì£¼ ì§‘ì¤‘ íˆ¬ì ìŠ¤íƒ€ì¼
        # ìƒìœ„ ì„±ê³¼ ì¢…ëª©ì— ë” ë†’ì€ ê°€ì¤‘ì¹˜
        signals_sorted = sorted(signals, key=lambda x: x.strength, reverse=True)
        top_signals = signals_sorted[:min(8, len(signals_sorted))]  # ìµœëŒ€ 8ê°œ ì¢…ëª© ì§‘ì¤‘
        
        weights = []
        total_strength = sum(signal.strength for signal in top_signals)
        
        for i, signal in enumerate(top_signals):
            # ìƒìœ„ ì¢…ëª©ì¼ìˆ˜ë¡ ë†’ì€ ê°€ì¤‘ì¹˜
            position_bonus = 1.3 if i < 3 else 1.0
            adjusted_strength = signal.strength * position_bonus
            weight = adjusted_strength / (total_strength * 1.1)
            
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 16. í•˜ì›Œë“œ ë§‰ìŠ¤ì˜ ì‚¬ì´í´ íˆ¬ì ì „ëµ (ì„±ì¥/ëª¨ë©˜í…€ ë²„ì „)
class HowardMarksCycleStrategy(BaseStrategy):
    """í•˜ì›Œë“œ ë§‰ìŠ¤ì˜ ì‚¬ì´í´ íˆ¬ì ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("Howard_Marks_Cycle_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="í•˜ì›Œë“œ ë§‰ìŠ¤ì˜ ì‚¬ì´í´ íˆ¬ì",
            description="ê²½ê¸°ì‚¬ì´í´ ê·¹ë‹¨ì ì—ì„œ ì—­ë°œìƒ ê¸°íšŒ í¬ì°©",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.COMPLEX,
            expected_return="13-18%",
            volatility="16-24%",
            min_investment_period="2ë…„ ì´ìƒ",
            rebalancing_frequency="ë¶„ê¸°ë³„"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'credit_spread', 'vix', 'yield_curve', 'sentiment_index', 
            'valuation_percentile', 'cycle_position', 'fear_greed_index'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # ì‹œì¥ ì‚¬ì´í´ ë¶„ì„
        market_cycle_score = self._analyze_market_cycle(data)
        
        # ê·¹ë‹¨ì  ìƒí™©ì—ì„œë§Œ ë§¤ë§¤ (ë§‰ìŠ¤ì˜ ì² í•™)
        if abs(market_cycle_score) < 0.7:  # ì¤‘ë¦½ êµ¬ê°„ì—ì„œëŠ” ê±°ë˜í•˜ì§€ ì•ŠìŒ
            return []
        
        cycle_data = data.dropna(subset=['valuation_percentile'])
        
        for symbol in cycle_data.index:
            company_data = cycle_data.loc[symbol]
            
            # ê°œë³„ ì¢…ëª©ì˜ ì‚¬ì´í´ ìœ„ì¹˜ ë¶„ì„
            stock_cycle_score = self._analyze_stock_cycle(company_data)
            
            # ì‹œì¥ ì‚¬ì´í´ê³¼ ê°œë³„ ì¢…ëª© ì‚¬ì´í´ì˜ ì¡°í•©
            combined_score = (market_cycle_score + stock_cycle_score) / 2
            
            # ê·¹ë‹¨ì  ì €í‰ê°€ ìƒí™© (ë§¤ìˆ˜ ê¸°íšŒ)
            if combined_score <= -0.7:
                strength = abs(combined_score)
                confidence = min(0.9, abs(combined_score) + 0.1)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=confidence,
                    metadata={
                        'market_cycle_score': market_cycle_score,
                        'stock_cycle_score': stock_cycle_score,
                        'combined_score': combined_score,
                        'valuation_percentile': company_data['valuation_percentile']
                    }
                ))
            
            # ê·¹ë‹¨ì  ê³ í‰ê°€ ìƒí™© (ë§¤ë„ ì‹ í˜¸)
            elif combined_score >= 0.7:
                strength = combined_score
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='SELL',
                    strength=strength,
                    confidence=0.8,
                    metadata={
                        'market_cycle_score': market_cycle_score,
                        'stock_cycle_score': stock_cycle_score,
                        'combined_score': combined_score
                    }
                ))
        
        return self.validate_signals(signals)
    
    def _analyze_market_cycle(self, data: pd.DataFrame) -> float:
        """ì „ì²´ ì‹œì¥ ì‚¬ì´í´ ë¶„ì„"""
        cycle_indicators = []
        
        # ì‹ ìš© ìŠ¤í”„ë ˆë“œ (ìœ„í—˜ ì§€í‘œ)
        avg_credit_spread = data['credit_spread'].mean()
        if avg_credit_spread > 300:  # 3% ì´ìƒ
            cycle_indicators.append(-0.8)  # ë§¤ìš° ë¶€ì •ì 
        elif avg_credit_spread > 200:  # 2% ì´ìƒ
            cycle_indicators.append(-0.5)
        elif avg_credit_spread < 100:  # 1% ì´í•˜
            cycle_indicators.append(0.6)   # ê³¼ë„í•œ ë‚™ê´€
        else:
            cycle_indicators.append(0.0)
        
        # VIX (ê³µí¬ ì§€ìˆ˜)
        avg_vix = data['vix'].mean()
        if avg_vix > 30:
            cycle_indicators.append(-0.7)  # ê·¹ë‹¨ì  ê³µí¬
        elif avg_vix > 20:
            cycle_indicators.append(-0.3)
        elif avg_vix < 15:
            cycle_indicators.append(0.5)   # ê³¼ë„í•œ ì•ˆì •ê°
        else:
            cycle_indicators.append(0.0)
        
        # íˆ¬ì ì‹¬ë¦¬
        avg_sentiment = data['sentiment_index'].mean()
        if avg_sentiment < 20:
            cycle_indicators.append(-0.8)  # ê·¹ë‹¨ì  ë¹„ê´€
        elif avg_sentiment < 40:
            cycle_indicators.append(-0.4)
        elif avg_sentiment > 80:
            cycle_indicators.append(0.7)   # ê·¹ë‹¨ì  ë‚™ê´€
        else:
            cycle_indicators.append(0.0)
        
        return np.mean(cycle_indicators)
    
    def _analyze_stock_cycle(self, company_data: pd.Series) -> float:
        """ê°œë³„ ì¢…ëª© ì‚¬ì´í´ ë¶„ì„"""
        stock_score = 0.0
        
        # ë°¸ë¥˜ì—ì´ì…˜ ë°±ë¶„ìœ„
        val_percentile = company_data['valuation_percentile']
        if val_percentile < 10:  # í•˜ìœ„ 10%
            stock_score -= 0.8
        elif val_percentile < 25:  # í•˜ìœ„ 25%
            stock_score -= 0.5
        elif val_percentile > 90:  # ìƒìœ„ 10%
            stock_score += 0.7
        elif val_percentile > 75:  # ìƒìœ„ 25%
            stock_score += 0.4
        
        # ì‚¬ì´í´ ìœ„ì¹˜
        cycle_position = company_data.get('cycle_position', 0.5)
        if cycle_position < 0.2:  # ì‚¬ì´í´ ë°”ë‹¥
            stock_score -= 0.6
        elif cycle_position > 0.8:  # ì‚¬ì´í´ ê³ ì 
            stock_score += 0.6
        
        return np.clip(stock_score, -1.0, 1.0)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        buy_signals = [s for s in signals if s.signal_type == 'BUY']
        if not buy_signals:
            return []
        
        # ì‚¬ì´í´ íˆ¬ìëŠ” ê¸°íšŒì£¼ì˜ì  ì§‘ì¤‘
        weights = []
        total_strength = sum(signal.strength for signal in buy_signals)
        
        for signal in buy_signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 17. ì œì„ìŠ¤ ì˜¤ì‡¼ë„¤ì‹œì˜ What Works on Wall Street ì „ëµ
class JamesOShaughnessyStrategy(BaseStrategy):
    """ì œì„ìŠ¤ ì˜¤ì‡¼ë„¤ì‹œì˜ What Works on Wall Street ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("James_OShaughnessy_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ì œì„ìŠ¤ ì˜¤ì‡¼ë„¤ì‹œì˜ What Works",
            description="50ë…„ ë°ì´í„° ê²€ì¦, ì‹œì´+PBR+ëª¨ë©˜í…€ ë©€í‹°íŒ©í„°",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.MEDIUM,
            expected_return="14-19%",
            volatility="17-23%",
            min_investment_period="1ë…„ ì´ìƒ",
            rebalancing_frequency="ì—° 1íšŒ"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'market_cap', 'pb_ratio', 'momentum_1year', 'price_sales', 
            'shareholder_yield', 'roe', 'earnings_quality'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # ì˜¤ì‡¼ë„¤ì‹œì˜ ìµœì  ì¡°í•©: ëŒ€í˜•ì£¼ + ì €PBR + ëª¨ë©˜í…€
        market_cap_threshold = self.parameters.get('market_cap_percentile', 0.5)  # ìƒìœ„ 50%
        pbr_threshold = self.parameters.get('pbr_percentile', 0.25)  # í•˜ìœ„ 25%
        momentum_threshold = self.parameters.get('momentum_percentile', 0.75)  # ìƒìœ„ 25%
        
        oshaughnessy_data = data.dropna(subset=['market_cap', 'pb_ratio', 'momentum_1year'])
        
        # ê° íŒ©í„°ë³„ ê¸°ì¤€ì„  ê³„ì‚°
        market_cap_cutoff = oshaughnessy_data['market_cap'].quantile(market_cap_threshold)
        pbr_cutoff = oshaughnessy_data['pb_ratio'].quantile(pbr_threshold)
        momentum_cutoff = oshaughnessy_data['momentum_1year'].quantile(momentum_threshold)
        
        for symbol in oshaughnessy_data.index:
            company_data = oshaughnessy_data.loc[symbol]
            
            # 3ê°€ì§€ í•µì‹¬ ì¡°ê±´
            large_cap = company_data['market_cap'] >= market_cap_cutoff
            low_pbr = company_data['pb_ratio'] <= pbr_cutoff
            high_momentum = company_data['momentum_1year'] >= momentum_cutoff
            
            # ëª¨ë“  ì¡°ê±´ ì¶©ì¡± ì‹œ ê¸°ë³¸ ì„ ë³„
            if large_cap and low_pbr and high_momentum:
                # ì¶”ê°€ í’ˆì§ˆ ì§€í‘œ í‰ê°€
                quality_score = self._evaluate_quality_factors(company_data)
                
                if quality_score >= 0.5:
                    # ê° íŒ©í„°ì˜ ìƒëŒ€ì  ìˆœìœ„ ê³„ì‚°
                    factor_scores = self._calculate_factor_scores(company_data, oshaughnessy_data)
                    
                    # ì¢…í•© ì ìˆ˜
                    composite_score = (
                        factor_scores['size_score'] * 0.3 +
                        factor_scores['value_score'] * 0.4 +
                        factor_scores['momentum_score'] * 0.3
                    )
                    
                    final_strength = min(1.0, composite_score * quality_score * 1.1)
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=final_strength,
                        confidence=0.8,
                        metadata={
                            'composite_score': composite_score,
                            'quality_score': quality_score,
                            'size_score': factor_scores['size_score'],
                            'value_score': factor_scores['value_score'],
                            'momentum_score': factor_scores['momentum_score'],
                            'market_cap': company_data['market_cap'],
                            'pb_ratio': company_data['pb_ratio'],
                            'momentum_1year': company_data['momentum_1year']
                        }
                    ))
        
        return self.validate_signals(signals)
    
    def _evaluate_quality_factors(self, company_data: pd.Series) -> float:
        """í’ˆì§ˆ íŒ©í„° í‰ê°€"""
        quality_score = 0.0
        
        # ROE
        roe = company_data.get('roe', 0.1)
        if roe > 0.15:
            quality_score += 0.3
        elif roe > 0.1:
            quality_score += 0.2
        
        # ì£¼ì£¼ìˆ˜ìµë¥  (ë°°ë‹¹ + ìì‚¬ì£¼ ë§¤ì…)
        shareholder_yield = company_data.get('shareholder_yield', 0.02)
        if shareholder_yield > 0.05:
            quality_score += 0.3
        elif shareholder_yield > 0.02:
            quality_score += 0.2
        
        # ìˆ˜ìµ í’ˆì§ˆ
        earnings_quality = company_data.get('earnings_quality', 0.7)
        quality_score += earnings_quality * 0.4
        
        return min(1.0, quality_score)
    
    def _calculate_factor_scores(self, company_data: pd.Series, universe_data: pd.DataFrame) -> Dict[str, float]:
        """íŒ©í„°ë³„ ìƒëŒ€ ì ìˆ˜ ê³„ì‚°"""
        scores = {}
        
        # ì‹œê°€ì´ì•¡ ì ìˆ˜ (í´ìˆ˜ë¡ ë†’ì€ ì ìˆ˜)
        market_cap = company_data['market_cap']
        market_cap_rank = (universe_data['market_cap'] <= market_cap).mean()
        scores['size_score'] = market_cap_rank
        
        # ê°€ì¹˜ ì ìˆ˜ (PBR ë‚®ì„ìˆ˜ë¡ ë†’ì€ ì ìˆ˜)
        pb_ratio = company_data['pb_ratio']
        pbr_rank = 1 - (universe_data['pb_ratio'] <= pb_ratio).mean()
        scores['value_score'] = pbr_rank
        
        # ëª¨ë©˜í…€ ì ìˆ˜ (ë†’ì„ìˆ˜ë¡ ë†’ì€ ì ìˆ˜)
        momentum = company_data['momentum_1year']
        momentum_rank = (universe_data['momentum_1year'] <= momentum).mean()
        scores['momentum_score'] = momentum_rank
        
        return scores
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # íŒ©í„° ì ìˆ˜ ê¸°ë°˜ ê°€ì¤‘ì¹˜
        weights = []
        total_strength = sum(signal.strength for signal in signals)
        
        for signal in signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# ì „ëµ íŒ©í† ë¦¬ì— ë“±ë¡
def register_growth_momentum_strategies():
    """ì„±ì¥/ëª¨ë©˜í…€ ì „ëµë“¤ì„ íŒ©í† ë¦¬ì— ë“±ë¡"""
    StrategyFactory.register_strategy("william_oneil_canslim", WilliamONeilCANSLIMStrategy)
    StrategyFactory.register_strategy("howard_marks_cycle", HowardMarksCycleStrategy)
    StrategyFactory.register_strategy("james_oshaughnessy", JamesOShaughnessyStrategy)

# ëª¨ë“ˆ ë¡œë“œ ì‹œ ìë™ ë“±ë¡
register_growth_momentum_strategies()


==================================================
File: C:\Aproject\quant_platform\backend\quant_engine\portfolio_utils.py
==================================================
"""
file: strategy_engine/portfolio_utils.py
Portfolio Utilities Module - í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬ ìœ í‹¸ë¦¬í‹°
ë¦¬ë°¸ëŸ°ì‹±, ê°€ì¤‘ì¹˜ ê³„ì‚°, í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™” ê´€ë ¨ í•¨ìˆ˜ë“¤ 250ì—¬ ë¼ì¸
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Optional, Union
import scipy.optimize as sco
from scipy import linalg
import warnings

# í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¤‘ì¹˜ ê³„ì‚°
def equal_weight_portfolio(symbols: List[str]) -> Dict[str, float]:
    """ë™ì¼ ê°€ì¤‘ì¹˜ í¬íŠ¸í´ë¦¬ì˜¤"""
    if not symbols:
        return {}
    
    weight = 1.0 / len(symbols)
    return {symbol: weight for symbol in symbols}

def market_cap_weighted_portfolio(symbols: List[str], market_caps: Dict[str, float]) -> Dict[str, float]:
    """ì‹œê°€ì´ì•¡ ê°€ì¤‘ í¬íŠ¸í´ë¦¬ì˜¤"""
    total_market_cap = sum(market_caps.get(symbol, 0) for symbol in symbols)
    
    if total_market_cap == 0:
        return equal_weight_portfolio(symbols)
    
    return {symbol: market_caps.get(symbol, 0) / total_market_cap for symbol in symbols}

def inverse_volatility_weighted_portfolio(returns: pd.DataFrame) -> Dict[str, float]:
    """ì—­ë³€ë™ì„± ê°€ì¤‘ í¬íŠ¸í´ë¦¬ì˜¤"""
    volatilities = returns.std()
    
    # 0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë°©ì§€
    volatilities = volatilities.replace(0, volatilities.mean())
    
    inverse_vol = 1 / volatilities
    total_inverse_vol = inverse_vol.sum()
    
    return (inverse_vol / total_inverse_vol).to_dict()

def risk_parity_portfolio(returns: pd.DataFrame, method: str = 'naive') -> Dict[str, float]:
    """ë¦¬ìŠ¤í¬ íŒ¨ë¦¬í‹° í¬íŠ¸í´ë¦¬ì˜¤"""
    if method == 'naive':
        return inverse_volatility_weighted_portfolio(returns)
    
    # ê³ ê¸‰ ë¦¬ìŠ¤í¬ íŒ¨ë¦¬í‹° (ê° ìì‚°ì˜ ë¦¬ìŠ¤í¬ ê¸°ì—¬ë„ ë™ì¼)
    cov_matrix = returns.cov().values
    n_assets = len(returns.columns)
    
    def risk_budget_objective(weights, cov_matrix):
        portfolio_vol = np.sqrt(np.dot(weights, np.dot(cov_matrix, weights)))
        marginal_contrib = np.dot(cov_matrix, weights) / portfolio_vol
        contrib = np.multiply(marginal_contrib, weights)
        
        # ê° ìì‚°ì˜ ë¦¬ìŠ¤í¬ ê¸°ì—¬ë„ê°€ ë™ì¼í•˜ë„ë¡
        target_contrib = portfolio_vol / n_assets
        return np.sum(np.square(contrib - target_contrib))
    
    # ì œì•½ì¡°ê±´
    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
    bounds = tuple((0.01, 0.5) for _ in range(n_assets))  # 1%-50% ì œí•œ
    
    # ì´ˆê¸°ê°’
    x0 = np.array([1/n_assets] * n_assets)
    
    try:
        result = sco.minimize(risk_budget_objective, x0, args=(cov_matrix,),
                             method='SLSQP', bounds=bounds, constraints=constraints)
        
        if result.success:
            return dict(zip(returns.columns, result.x))
        else:
            return inverse_volatility_weighted_portfolio(returns)
    except:
        return inverse_volatility_weighted_portfolio(returns)

def minimum_variance_portfolio(returns: pd.DataFrame) -> Dict[str, float]:
    """ìµœì†Œë¶„ì‚° í¬íŠ¸í´ë¦¬ì˜¤"""
    cov_matrix = returns.cov().values
    n_assets = len(returns.columns)
    
    # ëª©ì í•¨ìˆ˜: í¬íŠ¸í´ë¦¬ì˜¤ ë¶„ì‚° ìµœì†Œí™”
    def portfolio_variance(weights, cov_matrix):
        return np.dot(weights, np.dot(cov_matrix, weights))
    
    # ì œì•½ì¡°ê±´
    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
    bounds = tuple((0, 1) for _ in range(n_assets))
    
    # ì´ˆê¸°ê°’
    x0 = np.array([1/n_assets] * n_assets)
    
    try:
        result = sco.minimize(portfolio_variance, x0, args=(cov_matrix,),
                             method='SLSQP', bounds=bounds, constraints=constraints)
        
        if result.success:
            return dict(zip(returns.columns, result.x))
        else:
            return equal_weight_portfolio(returns.columns.tolist())
    except:
        return equal_weight_portfolio(returns.columns.tolist())

def maximum_diversification_portfolio(returns: pd.DataFrame) -> Dict[str, float]:
    """ìµœëŒ€ë¶„ì‚°íš¨ê³¼ í¬íŠ¸í´ë¦¬ì˜¤"""
    cov_matrix = returns.cov().values
    volatilities = returns.std().values
    n_assets = len(returns.columns)
    
    def diversification_ratio(weights, cov_matrix, volatilities):
        portfolio_vol = np.sqrt(np.dot(weights, np.dot(cov_matrix, weights)))
        weighted_avg_vol = np.dot(weights, volatilities)
        return -weighted_avg_vol / portfolio_vol  # ìŒìˆ˜ë¡œ ìµœëŒ€í™”ë¥¼ ìµœì†Œí™”ë¡œ ë³€í™˜
    
    # ì œì•½ì¡°ê±´
    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
    bounds = tuple((0, 1) for _ in range(n_assets))
    
    # ì´ˆê¸°ê°’
    x0 = np.array([1/n_assets] * n_assets)
    
    try:
        result = sco.minimize(diversification_ratio, x0, 
                             args=(cov_matrix, volatilities),
                             method='SLSQP', bounds=bounds, constraints=constraints)
        
        if result.success:
            return dict(zip(returns.columns, result.x))
        else:
            return equal_weight_portfolio(returns.columns.tolist())
    except:
        return equal_weight_portfolio(returns.columns.tolist())

# ë¦¬ë°¸ëŸ°ì‹± í•¨ìˆ˜ë“¤
def calculate_rebalancing_trades(current_weights: Dict[str, float], 
                                target_weights: Dict[str, float],
                                portfolio_value: float,
                                threshold: float = 0.05) -> Dict[str, Dict]:
    """ë¦¬ë°¸ëŸ°ì‹± ê±°ë˜ ê³„ì‚°"""
    trades = {}
    
    # ëª¨ë“  ì¢…ëª© ë¦¬ìŠ¤íŠ¸
    all_symbols = set(current_weights.keys()) | set(target_weights.keys())
    
    for symbol in all_symbols:
        current_weight = current_weights.get(symbol, 0.0)
        target_weight = target_weights.get(symbol, 0.0)
        weight_diff = target_weight - current_weight
        
        # ì„ê³„ê°’ ì´ìƒì˜ ì°¨ì´ë§Œ ê±°ë˜
        if abs(weight_diff) > threshold:
            current_value = current_weight * portfolio_value
            target_value = target_weight * portfolio_value
            trade_value = target_value - current_value
            
            trades[symbol] = {
                'current_weight': current_weight,
                'target_weight': target_weight,
                'weight_diff': weight_diff,
                'current_value': current_value,
                'target_value': target_value,
                'trade_value': trade_value,
                'trade_type': 'BUY' if trade_value > 0 else 'SELL'
            }
    
    return trades

def optimize_rebalancing_frequency(returns: pd.DataFrame, 
                                  target_weights: pd.Series,
                                  transaction_cost: float = 0.001) -> Dict:
    """ìµœì  ë¦¬ë°¸ëŸ°ì‹± ë¹ˆë„ ê³„ì‚°"""
    frequencies = [1, 5, 21, 63, 126, 252]  # ì¼, ì£¼, ì›”, ë¶„ê¸°, ë°˜ê¸°, ì—°
    results = {}
    
    for freq in frequencies:
        # í•´ë‹¹ ë¹ˆë„ë¡œ ë¦¬ë°¸ëŸ°ì‹±í–ˆì„ ë•Œì˜ ì„±ê³¼ ê³„ì‚°
        rebalanced_returns = simulate_rebalanced_returns(
            returns, target_weights, freq, transaction_cost
        )
        
        total_return = (1 + rebalanced_returns).prod() - 1
        volatility = rebalanced_returns.std() * np.sqrt(252)
        sharpe_ratio = (rebalanced_returns.mean() * 252) / (rebalanced_returns.std() * np.sqrt(252))
        
        results[freq] = {
            'frequency_days': freq,
            'total_return': total_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'total_transactions': len(returns) // freq
        }
    
    # ìƒ¤í”„ ë¹„ìœ¨ ê¸°ì¤€ ìµœì  ë¹ˆë„ ì„ íƒ
    optimal_freq = max(results.keys(), key=lambda x: results[x]['sharpe_ratio'])
    
    return {
        'optimal_frequency': optimal_freq,
        'results': results
    }

def simulate_rebalanced_returns(returns: pd.DataFrame, 
                               target_weights: pd.Series,
                               rebalance_frequency: int,
                               transaction_cost: float = 0.001) -> pd.Series:
    """ë¦¬ë°¸ëŸ°ì‹± ì‹œë®¬ë ˆì´ì…˜"""
    portfolio_returns = []
    current_weights = target_weights.copy()
    
    for i in range(len(returns)):
        # ì¼ì¼ ìˆ˜ìµë¥  ê³„ì‚°
        daily_return = (returns.iloc[i] * current_weights).sum()
        portfolio_returns.append(daily_return)
        
        # ê°€ì¤‘ì¹˜ ì—…ë°ì´íŠ¸ (ìˆ˜ìµë¥ ì— ë”°ë¥¸ ìì—°ì  ë³€í™”)
        current_weights = current_weights * (1 + returns.iloc[i])
        current_weights = current_weights / current_weights.sum()
        
        # ë¦¬ë°¸ëŸ°ì‹± ì‹œì 
        if (i + 1) % rebalance_frequency == 0:
            # ê±°ë˜ë¹„ìš© ì°¨ê°
            rebalancing_cost = transaction_cost * np.sum(np.abs(current_weights - target_weights))
            portfolio_returns[-1] -= rebalancing_cost
            
            # ëª©í‘œ ê°€ì¤‘ì¹˜ë¡œ ë¦¬ë°¸ëŸ°ì‹±
            current_weights = target_weights.copy()
    
    return pd.Series(portfolio_returns, index=returns.index)

# í¬íŠ¸í´ë¦¬ì˜¤ ì„±ê³¼ ì¸¡ì •
def calculate_portfolio_metrics(returns: pd.Series, 
                               benchmark_returns: Optional[pd.Series] = None,
                               risk_free_rate: float = 0.02) -> Dict[str, float]:
    """í¬íŠ¸í´ë¦¬ì˜¤ ì„±ê³¼ ì§€í‘œ ê³„ì‚°"""
    metrics = {}
    
    if len(returns) == 0:
        return metrics
    
    # ê¸°ë³¸ ì§€í‘œ
    metrics['total_return'] = (1 + returns).prod() - 1
    metrics['annualized_return'] = (1 + returns.mean()) ** 252 - 1
    metrics['volatility'] = returns.std() * np.sqrt(252)
    metrics['sharpe_ratio'] = (metrics['annualized_return'] - risk_free_rate) / metrics['volatility']
    
    # í•˜ë°© ìœ„í—˜ ì§€í‘œ
    downside_returns = returns[returns < 0]
    if len(downside_returns) > 0:
        metrics['downside_volatility'] = downside_returns.std() * np.sqrt(252)
        metrics['sortino_ratio'] = (metrics['annualized_return'] - risk_free_rate) / metrics['downside_volatility']
    else:
        metrics['downside_volatility'] = 0
        metrics['sortino_ratio'] = float('inf')
    
    # ìµœëŒ€ ë‚™í­
    cumulative_returns = (1 + returns).cumprod()
    running_max = cumulative_returns.expanding().max()
    drawdown = (cumulative_returns - running_max) / running_max
    metrics['max_drawdown'] = drawdown.min()
    
    # VaR
    metrics['var_95'] = returns.quantile(0.05)
    metrics['cvar_95'] = returns[returns <= metrics['var_95']].mean()
    
    # ìŠ¹ë¥ 
    metrics['win_rate'] = (returns > 0).mean()
    
    # ë²¤ì¹˜ë§ˆí¬ ëŒ€ë¹„ ì§€í‘œ
    if benchmark_returns is not None and len(benchmark_returns) == len(returns):
        excess_returns = returns - benchmark_returns
        metrics['alpha'] = excess_returns.mean() * 252
        
        # ë² íƒ€ ê³„ì‚°
        covariance = np.cov(returns, benchmark_returns)[0, 1]
        benchmark_variance = benchmark_returns.var()
        metrics['beta'] = covariance / benchmark_variance if benchmark_variance != 0 else 0
        
        # ì •ë³´ë¹„ìœ¨
        tracking_error = excess_returns.std() * np.sqrt(252)
        metrics['information_ratio'] = metrics['alpha'] / tracking_error if tracking_error != 0 else 0
    
    return metrics

def calculate_risk_attribution(returns: pd.DataFrame, weights: pd.Series) -> Dict[str, float]:
    """ë¦¬ìŠ¤í¬ ê¸°ì—¬ë„ ë¶„ì„"""
    cov_matrix = returns.cov()
    portfolio_variance = np.dot(weights, np.dot(cov_matrix, weights))
    portfolio_volatility = np.sqrt(portfolio_variance)
    
    # í•œê³„ ê¸°ì—¬ë„
    marginal_contrib = np.dot(cov_matrix, weights) / portfolio_volatility
    
    # ê°œë³„ ê¸°ì—¬ë„
    contrib = weights * marginal_contrib
    
    # ë°±ë¶„ìœ¨ë¡œ ë³€í™˜
    risk_attribution = (contrib / portfolio_variance).to_dict()
    
    return risk_attribution

def calculate_performance_attribution(returns: pd.DataFrame, 
                                    weights: pd.Series,
                                    benchmark_returns: pd.Series) -> Dict[str, Dict[str, float]]:
    """ì„±ê³¼ ê¸°ì—¬ë„ ë¶„ì„"""
    attribution = {}
    
    # í¬íŠ¸í´ë¦¬ì˜¤ ìˆ˜ìµë¥ 
    portfolio_returns = (returns * weights).sum(axis=1)
    
    for asset in returns.columns:
        asset_return = returns[asset].mean() * 252
        benchmark_return = benchmark_returns.mean() * 252
        weight = weights[asset]
        
        # ìì‚° ì„ íƒ íš¨ê³¼
        selection_effect = (asset_return - benchmark_return) * weight
        
        # ê°€ì¤‘ì¹˜ íš¨ê³¼ (ë²¤ì¹˜ë§ˆí¬ ê°€ì¤‘ì¹˜ê°€ ìˆë‹¤ë©´)
        # ì—¬ê¸°ì„œëŠ” ë™ì¼ê°€ì¤‘ì¹˜ë¥¼ ë²¤ì¹˜ë§ˆí¬ë¡œ ê°€ì •
        benchmark_weight = 1 / len(returns.columns)
        allocation_effect = (weight - benchmark_weight) * benchmark_return
        
        attribution[asset] = {
            'selection_effect': selection_effect,
            'allocation_effect': allocation_effect,
            'total_contribution': selection_effect + allocation_effect
        }
    
    return attribution

# í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™” ìœ í‹¸ë¦¬í‹°
def efficient_frontier(returns: pd.DataFrame, 
                      n_portfolios: int = 100) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """íš¨ìœ¨ì  í”„ë¡ í‹°ì–´ ê³„ì‚°"""
    n_assets = len(returns.columns)
    mean_returns = returns.mean() * 252
    cov_matrix = returns.cov() * 252
    
    # ëª©í‘œ ìˆ˜ìµë¥  ë²”ìœ„
    min_ret = mean_returns.min()
    max_ret = mean_returns.max()
    target_returns = np.linspace(min_ret, max_ret, n_portfolios)
    
    efficient_portfolios = []
    
    for target_return in target_returns:
        # ëª©ì í•¨ìˆ˜: ë¶„ì‚° ìµœì†Œí™”
        def portfolio_variance(weights):
            return np.dot(weights, np.dot(cov_matrix, weights))
        
        # ì œì•½ì¡°ê±´
        constraints = [
            {'type': 'eq', 'fun': lambda x: np.sum(x) - 1},  # ê°€ì¤‘ì¹˜ í•© = 1
            {'type': 'eq', 'fun': lambda x: np.dot(x, mean_returns) - target_return}  # ëª©í‘œ ìˆ˜ìµë¥ 
        ]
        bounds = tuple((0, 1) for _ in range(n_assets))
        
        # ìµœì í™”
        result = sco.minimize(portfolio_variance, 
                             np.array([1/n_assets] * n_assets),
                             method='SLSQP', 
                             bounds=bounds, 
                             constraints=constraints)
        
        if result.success:
            efficient_portfolios.append(result.x)
        else:
            efficient_portfolios.append(np.array([1/n_assets] * n_assets))
    
    efficient_portfolios = np.array(efficient_portfolios)
    
    # íš¨ìœ¨ì  í”„ë¡ í‹°ì–´ì˜ ìˆ˜ìµë¥ ê³¼ ìœ„í—˜
    frontier_returns = np.array([np.dot(weights, mean_returns) 
                                for weights in efficient_portfolios])
    frontier_volatility = np.array([np.sqrt(np.dot(weights, np.dot(cov_matrix, weights))) 
                                   for weights in efficient_portfolios])
    
    return efficient_portfolios, frontier_returns, frontier_volatility

def black_litterman_optimization(returns: pd.DataFrame,
                                 market_caps: pd.Series,
                                 views: Dict[str, float] = None,
                                 view_confidence: float = 0.25) -> Dict[str, float]:
    """ë¸”ë™-ë¦¬í„°ë§Œ ëª¨ë¸"""
    # ì‹œì¥ ê· í˜• ìˆ˜ìµë¥  (CAPM ê¸°ë°˜)
    market_weights = market_caps / market_caps.sum()
    cov_matrix = returns.cov() * 252
    risk_aversion = 3.0  # ì¼ë°˜ì ì¸ ìœ„í—˜íšŒí”¼ê³„ìˆ˜
    
    # ì•”ì‹œ ìˆ˜ìµë¥ 
    implied_returns = risk_aversion * np.dot(cov_matrix, market_weights)
    
    if views is None:
        # ë·°ê°€ ì—†ìœ¼ë©´ ì‹œì¥ í¬íŠ¸í´ë¦¬ì˜¤ ë°˜í™˜
        return market_weights.to_dict()
    
    # ë·° í–‰ë ¬ êµ¬ì„±
    P = np.zeros((len(views), len(returns.columns)))
    Q = np.zeros(len(views))
    
    for i, (asset, view_return) in enumerate(views.items()):
        if asset in returns.columns:
            asset_idx = returns.columns.get_loc(asset)
            P[i, asset_idx] = 1
            Q[i] = view_return
    
    # ë·°ì˜ ë¶ˆí™•ì‹¤ì„± í–‰ë ¬
    omega = view_confidence * np.dot(P, np.dot(cov_matrix, P.T))
    
    # ì‚¬ì „ ë¶ˆí™•ì‹¤ì„±
    tau = 1 / len(returns)
    
    try:
        # ë¸”ë™-ë¦¬í„°ë§Œ ìˆ˜ìµë¥ 
        M1 = linalg.inv(tau * cov_matrix)
        M2 = np.dot(P.T, np.dot(linalg.inv(omega), P))
        M3 = np.dot(linalg.inv(tau * cov_matrix), implied_returns)
        M4 = np.dot(P.T, np.dot(linalg.inv(omega), Q))
        
        mu_bl = np.dot(linalg.inv(M1 + M2), M3 + M4)
        cov_bl = linalg.inv(M1 + M2)
        
        # ìµœì  ê°€ì¤‘ì¹˜
        optimal_weights = np.dot(linalg.inv(risk_aversion * cov_bl), mu_bl)
        
        # ì •ê·œí™”
        optimal_weights = optimal_weights / optimal_weights.sum()
        
        return dict(zip(returns.columns, optimal_weights))
    
    except:
        # ê³„ì‚° ì‹¤íŒ¨ì‹œ ì‹œì¥ í¬íŠ¸í´ë¦¬ì˜¤ ë°˜í™˜
        return market_weights.to_dict()

def kelly_criterion_weights(expected_returns: pd.Series, 
                           covariance_matrix: pd.DataFrame,
                           max_leverage: float = 1.0) -> Dict[str, float]:
    """ì¼ˆë¦¬ ê¸°ì¤€ í¬ì§€ì…˜ ì‚¬ì´ì§•"""
    try:
        # ì¼ˆë¦¬ ê³µì‹: f = (Î¼ - r) / ÏƒÂ²
        # ë‹¤ìì‚°ì˜ ê²½ìš°: f = Î£^(-1) * (Î¼ - r)
        risk_free_rate = 0.02 / 252  # ì¼ì¼ ë¬´ìœ„í—˜ìˆ˜ìµë¥ 
        excess_returns = expected_returns - risk_free_rate
        
        # ê³µë¶„ì‚° í–‰ë ¬ì˜ ì—­í–‰ë ¬
        inv_cov = linalg.inv(covariance_matrix.values)
        
        # ì¼ˆë¦¬ ê°€ì¤‘ì¹˜
        kelly_weights = np.dot(inv_cov, excess_returns.values)
        
        # ë ˆë²„ë¦¬ì§€ ì œí•œ
        total_leverage = np.abs(kelly_weights).sum()
        if total_leverage > max_leverage:
            kelly_weights = kelly_weights * (max_leverage / total_leverage)
        
        # ìŒìˆ˜ ê°€ì¤‘ì¹˜ë¥¼ 0ìœ¼ë¡œ ì„¤ì • (ë¡±ì˜¨ë¦¬)
        kelly_weights = np.maximum(kelly_weights, 0)
        
        # ì •ê·œí™”
        if kelly_weights.sum() > 0:
            kelly_weights = kelly_weights / kelly_weights.sum()
        else:
            kelly_weights = np.ones(len(expected_returns)) / len(expected_returns)
        
        return dict(zip(expected_returns.index, kelly_weights))
    
    except:
        # ê³„ì‚° ì‹¤íŒ¨ì‹œ ë™ì¼ê°€ì¤‘ì¹˜ ë°˜í™˜
        return equal_weight_portfolio(expected_returns.index.tolist()) 



==================================================
File: C:\Aproject\quant_platform\backend\quant_engine\strategy_factory.py
==================================================
"""
file: strategy_engine/strategy_factory.py
Strategy Factory Module - ì „ëµ ê°ì²´ ìƒì„± íŒ©í† ë¦¬ íŒ¨í„´
ì „ëµ ì´ë¦„ìœ¼ë¡œ í•´ë‹¹ í´ë˜ìŠ¤ ë°˜í™˜, ì „ëµ ê´€ë¦¬ ë° ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Type, Any, Callable
import logging
import importlib
from base_strategy import BaseStrategy, StrategyCategory
from collections import defaultdict

class StrategyRegistry:
    """ì „ëµ ë ˆì§€ìŠ¤íŠ¸ë¦¬ - ëª¨ë“  ì „ëµì„ ì¤‘ì•™ ê´€ë¦¬"""
    
    def __init__(self):
        self._strategies: Dict[str, Type[BaseStrategy]] = {}
        self._strategy_metadata: Dict[str, Dict] = {}
        self._categories: Dict[StrategyCategory, List[str]] = defaultdict(list)
        self.logger = logging.getLogger("StrategyRegistry")
    
    def register(self, strategy_name: str, strategy_class: Type[BaseStrategy]):
        """ì „ëµ ë“±ë¡"""
        if not issubclass(strategy_class, BaseStrategy):
            raise ValueError(f"Strategy class must inherit from BaseStrategy")
        
        self._strategies[strategy_name] = strategy_class
        
        # ë©”íƒ€ë°ì´í„° ì €ì¥ (ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì—†ì´)
        try:
            temp_instance = strategy_class()
            metadata = temp_instance.get_strategy_info()
            self._strategy_metadata[strategy_name] = metadata
            
            # ì¹´í…Œê³ ë¦¬ë³„ ë¶„ë¥˜
            category = metadata['metadata'].category
            if strategy_name not in self._categories[category]:
                self._categories[category].append(strategy_name)
            
        except Exception as e:
            self.logger.warning(f"Could not get metadata for {strategy_name}: {e}")
    
    def get_strategy_class(self, strategy_name: str) -> Type[BaseStrategy]:
        """ì „ëµ í´ë˜ìŠ¤ ë°˜í™˜"""
        if strategy_name not in self._strategies:
            raise ValueError(f"Strategy '{strategy_name}' not found. Available strategies: {list(self._strategies.keys())}")
        
        return self._strategies[strategy_name]
    
    def create_strategy(self, strategy_name: str, **kwargs) -> BaseStrategy:
        """ì „ëµ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±"""
        strategy_class = self.get_strategy_class(strategy_name)
        return strategy_class(**kwargs)
    
    def list_strategies(self) -> List[str]:
        """ë“±ë¡ëœ ì „ëµ ëª©ë¡"""
        return list(self._strategies.keys())
    
    def list_strategies_by_category(self, category: StrategyCategory) -> List[str]:
        """ì¹´í…Œê³ ë¦¬ë³„ ì „ëµ ëª©ë¡"""
        return self._categories.get(category, [])
    
    def get_strategy_metadata(self, strategy_name: str) -> Dict:
        """ì „ëµ ë©”íƒ€ë°ì´í„° ë°˜í™˜"""
        if strategy_name not in self._strategy_metadata:
            # ë©”íƒ€ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì‹¤ì‹œê°„ ìƒì„±
            try:
                strategy = self.create_strategy(strategy_name)
                return strategy.get_strategy_info()
            except Exception as e:
                return {"error": str(e)}
        
        return self._strategy_metadata[strategy_name]
    
    def search_strategies(self, 
                         risk_level: Optional[str] = None,
                         complexity: Optional[str] = None,
                         category: Optional[StrategyCategory] = None,
                         min_expected_return: Optional[float] = None) -> List[str]:
        """ì¡°ê±´ë³„ ì „ëµ ê²€ìƒ‰"""
        matching_strategies = []
        
        for strategy_name, metadata in self._strategy_metadata.items():
            strategy_meta = metadata.get('metadata')
            if not strategy_meta:
                continue
            
            # ì¡°ê±´ í™•ì¸
            if risk_level and strategy_meta.risk_level.value != risk_level:
                continue
            
            if complexity and strategy_meta.complexity.value != complexity:
                continue
            
            if category and strategy_meta.category != category:
                continue
            
            # ì˜ˆìƒ ìˆ˜ìµë¥  íŒŒì‹± ë° ë¹„êµ (ê°„ë‹¨í•œ êµ¬í˜„)
            if min_expected_return:
                expected_return_str = strategy_meta.expected_return
                try:
                    # "10-12%" í˜•íƒœì—ì„œ í•˜í•œê°’ ì¶”ì¶œ
                    return_value = float(expected_return_str.split('-')[0].rstrip('%'))
                    if return_value < min_expected_return:
                        continue
                except:
                    continue
            
            matching_strategies.append(strategy_name)
        
        return matching_strategies

# ê¸€ë¡œë²Œ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì¸ìŠ¤í„´ìŠ¤
strategy_registry = StrategyRegistry()

class StrategyFactory:
    """ì „ëµ íŒ©í† ë¦¬ - ë°±ì›Œë“œ í˜¸í™˜ì„±ì„ ìœ„í•œ ë˜í¼"""
    
    @staticmethod
    def register_strategy(strategy_name: str, strategy_class: Type[BaseStrategy]):
        """ì „ëµ ë“±ë¡"""
        strategy_registry.register(strategy_name, strategy_class)
    
    @staticmethod
    def create_strategy(strategy_name: str, **kwargs) -> BaseStrategy:
        """ì „ëµ ìƒì„±"""
        return strategy_registry.create_strategy(strategy_name, **kwargs)
    
    @staticmethod
    def list_strategies() -> List[str]:
        """ì „ëµ ëª©ë¡"""
        return strategy_registry.list_strategies()

class StrategyManager:
    """ì „ëµ ë§¤ë‹ˆì € - ë³µìˆ˜ ì „ëµ ê´€ë¦¬ ë° í¬íŠ¸í´ë¦¬ì˜¤ ìš´ì˜"""
    
    def __init__(self):
        self.strategies: Dict[str, BaseStrategy] = {}
        self.strategy_weights: Dict[str, float] = {}
        self.logger = logging.getLogger("StrategyManager")
    
    def add_strategy(self, name: str, strategy: BaseStrategy, weight: float = 1.0):
        """ì „ëµ ì¶”ê°€"""
        if not isinstance(strategy, BaseStrategy):
            raise ValueError("Strategy must be an instance of BaseStrategy")
        
        self.strategies[name] = strategy
        self.strategy_weights[name] = weight
        
        # ê°€ì¤‘ì¹˜ ì •ê·œí™”
        self._normalize_weights()
    
    def remove_strategy(self, name: str):
        """ì „ëµ ì œê±°"""
        if name in self.strategies:
            del self.strategies[name]
            del self.strategy_weights[name]
            self._normalize_weights()
    
    def _normalize_weights(self):
        """ê°€ì¤‘ì¹˜ ì •ê·œí™”"""
        total_weight = sum(self.strategy_weights.values())
        if total_weight > 0:
            for name in self.strategy_weights:
                self.strategy_weights[name] /= total_weight
    
    def generate_combined_signals(self, data: pd.DataFrame) -> List:
        """ë³µìˆ˜ ì „ëµì˜ ì‹ í˜¸ ê²°í•©"""
        all_signals = []
        
        for name, strategy in self.strategies.items():
            try:
                signals = strategy.generate_signals(data)
                weight = self.strategy_weights[name]
                
                # ì‹ í˜¸ì— ì „ëµ ê°€ì¤‘ì¹˜ ì ìš©
                for signal in signals:
                    signal.strength *= weight
                    signal.metadata = signal.metadata or {}
                    signal.metadata['strategy_name'] = name
                    signal.metadata['strategy_weight'] = weight
                
                all_signals.extend(signals)
                
            except Exception as e:
                self.logger.error(f"Error generating signals for strategy {name}: {e}")
        
        return all_signals
    
    def calculate_ensemble_weights(self, signals: List, 
                                  current_portfolio: Optional[Dict[str, float]] = None) -> List:
        """ì•™ìƒë¸” ê°€ì¤‘ì¹˜ ê³„ì‚°"""
        # ì¢…ëª©ë³„ë¡œ ì‹ í˜¸ ê·¸ë£¹í™”
        symbol_signals = defaultdict(list)
        for signal in signals:
            symbol_signals[signal.symbol].append(signal)
        
        ensemble_weights = []
        
        for symbol, symbol_signal_list in symbol_signals.items():
            # ë™ì¼ ì¢…ëª©ì— ëŒ€í•œ ì—¬ëŸ¬ ì „ëµ ì‹ í˜¸ ê²°í•©
            combined_strength = sum(s.strength for s in symbol_signal_list)
            combined_confidence = np.mean([s.confidence for s in symbol_signal_list])
            
            # ê°€ì¥ ê°•í•œ ì‹ í˜¸ì˜ íƒ€ì… ì‚¬ìš©
            signal_type = max(symbol_signal_list, key=lambda x: x.strength).signal_type
            
            if combined_strength > 0:
                from base_strategy import PortfolioWeight
                current_weight = current_portfolio.get(symbol, 0.0) if current_portfolio else 0.0
                
                ensemble_weights.append(PortfolioWeight(
                    symbol=symbol,
                    weight=combined_strength,  # ì„ì‹œê°’, ë‚˜ì¤‘ì— ì •ê·œí™”
                    target_weight=combined_strength,
                    current_weight=current_weight
                ))
        
        # ê°€ì¤‘ì¹˜ ì •ê·œí™”
        total_weight = sum(w.weight for w in ensemble_weights)
        if total_weight > 0:
            for weight in ensemble_weights:
                weight.weight /= total_weight
                weight.target_weight /= total_weight
        
        return ensemble_weights
    
    def get_strategy_performance(self, returns: pd.DataFrame) -> Dict[str, Dict]:
        """ê° ì „ëµë³„ ì„±ê³¼ í‰ê°€"""
        performance = {}
        
        for name, strategy in self.strategies.items():
            try:
                signals = strategy.generate_signals(returns)
                weights = strategy.calculate_weights(signals)
                
                if weights:
                    # ê°„ë‹¨í•œ ë°±í…ŒìŠ¤íŠ¸
                    strategy_returns = self._calculate_strategy_returns(returns, weights)
                    
                    from portfolio_utils import calculate_portfolio_metrics
                    metrics = calculate_portfolio_metrics(strategy_returns)
                    
                    performance[name] = {
                        'metrics': metrics,
                        'weight': self.strategy_weights[name],
                        'signal_count': len(signals),
                        'position_count': len(weights)
                    }
                    
            except Exception as e:
                self.logger.error(f"Error evaluating strategy {name}: {e}")
                performance[name] = {'error': str(e)}
        
        return performance
    
    def _calculate_strategy_returns(self, returns: pd.DataFrame, weights: List) -> pd.Series:
        """ì „ëµë³„ ìˆ˜ìµë¥  ê³„ì‚° (ê°„ë‹¨ ë²„ì „)"""
        if not weights:
            return pd.Series(dtype=float)
        
        # ê°€ì¤‘ì¹˜ë¥¼ ì‹œë¦¬ì¦ˆë¡œ ë³€í™˜
        weight_dict = {w.symbol: w.weight for w in weights if w.symbol in returns.columns}
        weight_series = pd.Series(weight_dict)
        
        # í¬íŠ¸í´ë¦¬ì˜¤ ìˆ˜ìµë¥ 
        strategy_returns = (returns[weight_series.index] * weight_series).sum(axis=1)
        
        return strategy_returns

class StrategyLoader:
    """ì „ëµ ë™ì  ë¡œë”©"""
    
    @staticmethod
    def load_strategies_from_modules():
        """ëª¨ë“  ì „ëµ ëª¨ë“ˆì—ì„œ ì „ëµë“¤ì„ ìë™ ë¡œë“œ"""
        strategy_modules = [
            'basic_strategies',
            'value_strategies', 
            'growth_momentum_strategies',
            'cycle_contrarian_strategies'
        ]
        
        for module_name in strategy_modules:
            try:
                module = importlib.import_module(module_name)
                # ê° ëª¨ë“ˆì˜ register í•¨ìˆ˜ í˜¸ì¶œ (ìˆë‹¤ë©´)
                if hasattr(module, f'register_{module_name}'):
                    register_func = getattr(module, f'register_{module_name}')
                    register_func()
                    logging.info(f"Loaded strategies from {module_name}")
            except ImportError as e:
                logging.warning(f"Could not load strategy module {module_name}: {e}")
    
    @staticmethod
    def get_all_available_strategies() -> Dict[str, Dict]:
        """ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  ì „ëµ ì •ë³´"""
        strategies_info = {}
        
        for strategy_name in strategy_registry.list_strategies():
            metadata = strategy_registry.get_strategy_metadata(strategy_name)
            strategies_info[strategy_name] = metadata
        
        return strategies_info

def create_strategy_combination(strategy_configs: List[Dict[str, Any]]) -> StrategyManager:
    """ì „ëµ ì¡°í•© ìƒì„± í—¬í¼ í•¨ìˆ˜"""
    manager = StrategyManager()
    
    for config in strategy_configs:
        strategy_name = config['strategy']
        weight = config.get('weight', 1.0)
        params = config.get('parameters', {})
        
        try:
            strategy = strategy_registry.create_strategy(strategy_name, **params)
            manager.add_strategy(f"{strategy_name}_{len(manager.strategies)}", strategy, weight)
        except Exception as e:
            logging.error(f"Failed to create strategy {strategy_name}: {e}")
    
    return manager

def get_recommended_strategies(user_profile: Dict[str, Any]) -> List[str]:
    """ì‚¬ìš©ì í”„ë¡œí•„ ê¸°ë°˜ ì¶”ì²œ ì „ëµ"""
    risk_tolerance = user_profile.get('risk_tolerance', 'medium')  # low, medium, high
    experience_level = user_profile.get('experience_level', 'beginner')  # beginner, intermediate, advanced
    investment_horizon = user_profile.get('investment_horizon', 'medium')  # short, medium, long
    
    recommended = []
    
    # ì´ˆë³´ììš© ì „ëµ
    if experience_level == 'beginner':
        recommended.extend([
            'low_pe', 'dividend_aristocrats', 'regular_rebalancing',
            'benjamin_graham_defensive'
        ])
    
    # ì¤‘ê¸‰ììš© ì „ëµ  
    elif experience_level == 'intermediate':
        recommended.extend([
            'rsi_mean_reversion', 'moving_average_cross', 'quality_factor',
            'joel_greenblatt_magic', 'john_neff_low_pe_dividend'
        ])
    
    # ê³ ê¸‰ììš© ì „ëµ
    else:
        recommended.extend([
            'william_oneil_canslim', 'howard_marks_cycle', 'james_oshaughnessy',
            'buffett_moat', 'peter_lynch_peg'
        ])
    
    # ìœ„í—˜ ì„ í˜¸ë„ì— ë”°ë¥¸ í•„í„°ë§
    if risk_tolerance == 'low':
        safe_strategies = strategy_registry.search_strategies(risk_level='low')
        recommended = [s for s in recommended if s in safe_strategies]
    elif risk_tolerance == 'high':
        aggressive_strategies = strategy_registry.search_strategies(risk_level='high')
        recommended.extend(aggressive_strategies)
    
    # ì¤‘ë³µ ì œê±° ë° ì¡´ì¬í•˜ëŠ” ì „ëµë§Œ ë°˜í™˜
    available_strategies = strategy_registry.list_strategies()
    recommended = list(set(recommended))
    recommended = [s for s in recommended if s in available_strategies]
    
    return recommended[:5]  # ìµœëŒ€ 5ê°œ ì „ëµ ì¶”ì²œ

# ëª¨ë“ˆ ë¡œë“œì‹œ ìë™ ì‹¤í–‰
def initialize_strategy_system():
    """ì „ëµ ì‹œìŠ¤í…œ ì´ˆê¸°í™”"""
    StrategyLoader.load_strategies_from_modules()
    logging.info(f"Strategy system initialized with {len(strategy_registry.list_strategies())} strategies")

# ë°±ì›Œë“œ í˜¸í™˜ì„±ì„ ìœ„í•œ ë³„ì¹­
register_strategy = StrategyFactory.register_strategy
create_strategy = StrategyFactory.create_strategy
list_strategies = StrategyFactory.list_strategies 



==================================================
File: C:\Aproject\quant_platform\backend\quant_engine\technical_indicators.py
==================================================
"""
file: strategy_engine/technical_indicators.py
Technical Indicators Module - ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚° í•¨ìˆ˜ë“¤
RSI, MACD, ë³¼ë¦°ì €ë°´ë“œ, ì´ë™í‰ê·  ë“± 200ì—¬ ë¼ì¸
"""

import pandas as pd
import numpy as np
from typing import Tuple, Optional, Union
import warnings

# ì´ë™í‰ê·  ê´€ë ¨ í•¨ìˆ˜ë“¤
def simple_moving_average(prices: pd.Series, window: int) -> pd.Series:
    """ë‹¨ìˆœ ì´ë™í‰ê·  (SMA)"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    return prices.rolling(window=window).mean()

def exponential_moving_average(prices: pd.Series, window: int) -> pd.Series:
    """ì§€ìˆ˜ ì´ë™í‰ê·  (EMA)"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    return prices.ewm(span=window).mean()

def weighted_moving_average(prices: pd.Series, window: int) -> pd.Series:
    """ê°€ì¤‘ ì´ë™í‰ê·  (WMA)"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    
    weights = np.arange(1, window + 1)
    wma_values = []
    
    for i in range(window - 1, len(prices)):
        period_prices = prices.iloc[i - window + 1:i + 1]
        wma_value = np.dot(period_prices, weights) / weights.sum()
        wma_values.append(wma_value)
    
    # ì¸ë±ìŠ¤ ë§ì¶”ê¸°
    wma_series = pd.Series(index=prices.index[window-1:], data=wma_values)
    return wma_series

def volume_weighted_average_price(prices: pd.Series, volumes: pd.Series, window: int) -> pd.Series:
    """ê±°ë˜ëŸ‰ ê°€ì¤‘ í‰ê· ê°€ê²© (VWAP)"""
    if len(prices) != len(volumes) or len(prices) < window:
        return pd.Series(dtype=float)
    
    typical_price = prices
    pv = typical_price * volumes
    
    vwap = pv.rolling(window=window).sum() / volumes.rolling(window=window).sum()
    return vwap

# RSI ê´€ë ¨ í•¨ìˆ˜ë“¤
def rsi(prices: pd.Series, window: int = 14) -> pd.Series:
    """ìƒëŒ€ê°•ë„ì§€ìˆ˜ (RSI)"""
    if len(prices) < window + 1:
        return pd.Series(dtype=float)
    
    delta = prices.diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)
    
    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()
    
    rs = avg_gain / avg_loss
    rsi_values = 100 - (100 / (1 + rs))
    
    return rsi_values

def stochastic_rsi(prices: pd.Series, window: int = 14, k_period: int = 3, d_period: int = 3) -> Tuple[pd.Series, pd.Series]:
    """ìŠ¤í† ìºìŠ¤í‹± RSI"""
    rsi_values = rsi(prices, window)
    
    if len(rsi_values) < window:
        return pd.Series(dtype=float), pd.Series(dtype=float)
    
    rsi_low = rsi_values.rolling(window=window).min()
    rsi_high = rsi_values.rolling(window=window).max()
    
    stoch_rsi = (rsi_values - rsi_low) / (rsi_high - rsi_low) * 100
    k_percent = stoch_rsi.rolling(window=k_period).mean()
    d_percent = k_percent.rolling(window=d_period).mean()
    
    return k_percent, d_percent

# MACD ê´€ë ¨ í•¨ìˆ˜ë“¤
def macd(prices: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """MACD (Moving Average Convergence Divergence)"""
    if len(prices) < slow:
        return pd.Series(dtype=float), pd.Series(dtype=float), pd.Series(dtype=float)
    
    ema_fast = exponential_moving_average(prices, fast)
    ema_slow = exponential_moving_average(prices, slow)
    
    macd_line = ema_fast - ema_slow
    signal_line = exponential_moving_average(macd_line, signal)
    histogram = macd_line - signal_line
    
    return macd_line, signal_line, histogram

def ppo(prices: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> Tuple[pd.Series, pd.Series]:
    """Percentage Price Oscillator"""
    if len(prices) < slow:
        return pd.Series(dtype=float), pd.Series(dtype=float)
    
    ema_fast = exponential_moving_average(prices, fast)
    ema_slow = exponential_moving_average(prices, slow)
    
    ppo_line = ((ema_fast - ema_slow) / ema_slow) * 100
    signal_line = exponential_moving_average(ppo_line, signal)
    
    return ppo_line, signal_line

# ë³¼ë¦°ì € ë°´ë“œ
def bollinger_bands(prices: pd.Series, window: int = 20, num_std: float = 2) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """ë³¼ë¦°ì € ë°´ë“œ"""
    if len(prices) < window:
        return pd.Series(dtype=float), pd.Series(dtype=float), pd.Series(dtype=float)
    
    sma = simple_moving_average(prices, window)
    std = prices.rolling(window=window).std()
    
    upper_band = sma + (std * num_std)
    lower_band = sma - (std * num_std)
    
    return upper_band, sma, lower_band

def bollinger_bands_percent_b(prices: pd.Series, window: int = 20, num_std: float = 2) -> pd.Series:
    """ë³¼ë¦°ì € ë°´ë“œ %B"""
    upper, middle, lower = bollinger_bands(prices, window, num_std)
    
    if len(upper) == 0:
        return pd.Series(dtype=float)
    
    percent_b = (prices - lower) / (upper - lower)
    return percent_b

def bollinger_bands_width(prices: pd.Series, window: int = 20, num_std: float = 2) -> pd.Series:
    """ë³¼ë¦°ì € ë°´ë“œ í­"""
    upper, middle, lower = bollinger_bands(prices, window, num_std)
    
    if len(upper) == 0:
        return pd.Series(dtype=float)
    
    band_width = (upper - lower) / middle
    return band_width

# ìŠ¤í† ìºìŠ¤í‹±
def stochastic(high: pd.Series, low: pd.Series, close: pd.Series, 
               k_period: int = 14, k_smooth: int = 3, d_period: int = 3) -> Tuple[pd.Series, pd.Series]:
    """ìŠ¤í† ìºìŠ¤í‹± ì˜¤ì‹¤ë ˆì´í„°"""
    if len(high) < k_period:
        return pd.Series(dtype=float), pd.Series(dtype=float)
    
    lowest_low = low.rolling(window=k_period).min()
    highest_high = high.rolling(window=k_period).max()
    
    k_percent_raw = (close - lowest_low) / (highest_high - lowest_low) * 100
    k_percent = k_percent_raw.rolling(window=k_smooth).mean()
    d_percent = k_percent.rolling(window=d_period).mean()
    
    return k_percent, d_percent

# ìœŒë¦¬ì—„ìŠ¤ %R
def williams_r(high: pd.Series, low: pd.Series, close: pd.Series, window: int = 14) -> pd.Series:
    """ìœŒë¦¬ì—„ìŠ¤ %R"""
    if len(high) < window:
        return pd.Series(dtype=float)
    
    highest_high = high.rolling(window=window).max()
    lowest_low = low.rolling(window=window).min()
    
    williams_r_values = (highest_high - close) / (highest_high - lowest_low) * -100
    return williams_r_values

# CCI (Commodity Channel Index)
def cci(high: pd.Series, low: pd.Series, close: pd.Series, window: int = 20) -> pd.Series:
    """Commodity Channel Index"""
    if len(high) < window:
        return pd.Series(dtype=float)
    
    typical_price = (high + low + close) / 3
    sma_tp = typical_price.rolling(window=window).mean()
    
    # Mean Absolute Deviation ê³„ì‚°
    mad = typical_price.rolling(window=window).apply(lambda x: np.mean(np.abs(x - x.mean())))
    
    cci_values = (typical_price - sma_tp) / (0.015 * mad)
    return cci_values

# ATR (Average True Range)
def average_true_range(high: pd.Series, low: pd.Series, close: pd.Series, window: int = 14) -> pd.Series:
    """í‰ê·  ì‹¤ì œ ë²”ìœ„ (ATR)"""
    if len(high) < 2:
        return pd.Series(dtype=float)
    
    # True Range ê³„ì‚°
    tr1 = high - low
    tr2 = np.abs(high - close.shift(1))
    tr3 = np.abs(low - close.shift(1))
    
    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    atr = true_range.rolling(window=window).mean()
    
    return atr

# ADX (Average Directional Index)
def adx(high: pd.Series, low: pd.Series, close: pd.Series, window: int = 14) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """Average Directional Index"""
    if len(high) < window + 1:
        return pd.Series(dtype=float), pd.Series(dtype=float), pd.Series(dtype=float)
    
    # Calculate True Range and Directional Movement
    tr = average_true_range(high, low, close, 1)
    
    high_diff = high.diff()
    low_diff = low.diff()
    
    plus_dm = np.where((high_diff > low_diff) & (high_diff > 0), high_diff, 0)
    minus_dm = np.where((low_diff > high_diff) & (low_diff > 0), low_diff, 0)
    
    plus_dm = pd.Series(plus_dm, index=high.index)
    minus_dm = pd.Series(minus_dm, index=low.index)
    
    # Smooth the values
    plus_di = 100 * (plus_dm.rolling(window=window).mean() / tr.rolling(window=window).mean())
    minus_di = 100 * (minus_dm.rolling(window=window).mean() / tr.rolling(window=window).mean())
    
    # Calculate ADX
    dx = 100 * np.abs(plus_di - minus_di) / (plus_di + minus_di)
    adx_values = dx.rolling(window=window).mean()
    
    return adx_values, plus_di, minus_di

# ê±°ë˜ëŸ‰ ì§€í‘œë“¤
def on_balance_volume(close: pd.Series, volume: pd.Series) -> pd.Series:
    """On-Balance Volume"""
    if len(close) != len(volume) or len(close) < 2:
        return pd.Series(dtype=float)
    
    price_change = close.diff()
    obv = np.where(price_change > 0, volume, 
                   np.where(price_change < 0, -volume, 0)).cumsum()
    
    return pd.Series(obv, index=close.index)

def accumulation_distribution_line(high: pd.Series, low: pd.Series, close: pd.Series, volume: pd.Series) -> pd.Series:
    """Accumulation/Distribution Line"""
    if len(high) != len(volume):
        return pd.Series(dtype=float)
    
    clv = ((close - low) - (high - close)) / (high - low)
    clv = clv.fillna(0)  # high == lowì¸ ê²½ìš° ì²˜ë¦¬
    
    money_flow_volume = clv * volume
    ad_line = money_flow_volume.cumsum()
    
    return ad_line

def money_flow_index(high: pd.Series, low: pd.Series, close: pd.Series, volume: pd.Series, window: int = 14) -> pd.Series:
    """Money Flow Index"""
    if len(high) != len(volume) or len(high) < window + 1:
        return pd.Series(dtype=float)
    
    typical_price = (high + low + close) / 3
    money_flow = typical_price * volume
    
    price_change = typical_price.diff()
    
    positive_flow = np.where(price_change > 0, money_flow, 0)
    negative_flow = np.where(price_change < 0, money_flow, 0)
    
    positive_flow_sum = pd.Series(positive_flow, index=high.index).rolling(window=window).sum()
    negative_flow_sum = pd.Series(negative_flow, index=high.index).rolling(window=window).sum()
    
    money_ratio = positive_flow_sum / negative_flow_sum
    mfi = 100 - (100 / (1 + money_ratio))
    
    return mfi

# ëª¨ë©˜í…€ ì§€í‘œë“¤
def momentum(prices: pd.Series, window: int = 10) -> pd.Series:
    """ëª¨ë©˜í…€ ì§€í‘œ"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    
    return prices - prices.shift(window)

def rate_of_change(prices: pd.Series, window: int = 10) -> pd.Series:
    """ë³€í™”ìœ¨ (ROC)"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    
    return ((prices - prices.shift(window)) / prices.shift(window)) * 100

def relative_strength(prices: pd.Series, benchmark: pd.Series, window: int = 252) -> pd.Series:
    """ìƒëŒ€ê°•ë„ (vs ë²¤ì¹˜ë§ˆí¬)"""
    if len(prices) != len(benchmark) or len(prices) < window:
        return pd.Series(dtype=float)
    
    stock_return = prices.pct_change(window)
    benchmark_return = benchmark.pct_change(window)
    
    relative_strength_values = (1 + stock_return) / (1 + benchmark_return) - 1
    return relative_strength_values * 100

# ë³€ë™ì„± ì§€í‘œë“¤
def standard_deviation(prices: pd.Series, window: int = 20) -> pd.Series:
    """í‘œì¤€í¸ì°¨"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    
    return prices.rolling(window=window).std()

def historical_volatility(prices: pd.Series, window: int = 30) -> pd.Series:
    """ì—­ì‚¬ì  ë³€ë™ì„± (ì—°ìœ¨í™”)"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    
    returns = prices.pct_change()
    volatility = returns.rolling(window=window).std() * np.sqrt(252)
    return volatility * 100

# ì¶”ì„¸ ì§€í‘œë“¤
def parabolic_sar(high: pd.Series, low: pd.Series, af_start: float = 0.02, af_increment: float = 0.02, af_max: float = 0.2) -> pd.Series:
    """Parabolic SAR"""
    if len(high) < 2:
        return pd.Series(dtype=float)
    
    sar = np.zeros(len(high))
    trend = np.zeros(len(high))  # 1 for uptrend, -1 for downtrend
    af = np.zeros(len(high))
    ep = np.zeros(len(high))  # Extreme Point
    
    # ì´ˆê¸°ê°’ ì„¤ì •
    sar[0] = low.iloc[0]
    trend[0] = 1
    af[0] = af_start
    ep[0] = high.iloc[0]
    
    for i in range(1, len(high)):
        if trend[i-1] == 1:  # Uptrend
            sar[i] = sar[i-1] + af[i-1] * (ep[i-1] - sar[i-1])
            
            if low.iloc[i] <= sar[i]:  # Trend reversal
                trend[i] = -1
                sar[i] = ep[i-1]
                af[i] = af_start
                ep[i] = low.iloc[i]
            else:
                trend[i] = 1
                if high.iloc[i] > ep[i-1]:
                    ep[i] = high.iloc[i]
                    af[i] = min(af_max, af[i-1] + af_increment)
                else:
                    ep[i] = ep[i-1]
                    af[i] = af[i-1]
        else:  # Downtrend
            sar[i] = sar[i-1] + af[i-1] * (ep[i-1] - sar[i-1])
            
            if high.iloc[i] >= sar[i]:  # Trend reversal
                trend[i] = 1
                sar[i] = ep[i-1]
                af[i] = af_start
                ep[i] = high.iloc[i]
            else:
                trend[i] = -1
                if low.iloc[i] < ep[i-1]:
                    ep[i] = low.iloc[i]
                    af[i] = min(af_max, af[i-1] + af_increment)
                else:
                    ep[i] = ep[i-1]
                    af[i] = af[i-1]
    
    return pd.Series(sar, index=high.index)

# ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
def crossover(series1: pd.Series, series2: pd.Series) -> pd.Series:
    """ìƒí–¥ êµì°¨ í™•ì¸"""
    return (series1 > series2) & (series1.shift(1) <= series2.shift(1))

def crossunder(series1: pd.Series, series2: pd.Series) -> pd.Series:
    """í•˜í–¥ êµì°¨ í™•ì¸"""
    return (series1 < series2) & (series1.shift(1) >= series2.shift(1))

def highest(series: pd.Series, window: int) -> pd.Series:
    """ì§€ì • ê¸°ê°„ ë‚´ ìµœê³ ê°’"""
    return series.rolling(window=window).max()

def lowest(series: pd.Series, window: int) -> pd.Series:
    """ì§€ì • ê¸°ê°„ ë‚´ ìµœì €ê°’"""
    return series.rolling(window=window).min()

def normalize_indicator(indicator: pd.Series, window: int = 252) -> pd.Series:
    """ì§€í‘œ ì •ê·œí™” (0-1 ë²”ìœ„)"""
    if len(indicator) < window:
        return pd.Series(dtype=float)
    
    rolling_min = indicator.rolling(window=window).min()
    rolling_max = indicator.rolling(window=window).max()
    
    normalized = (indicator - rolling_min) / (rolling_max - rolling_min)
    return normalized




==================================================
File: C:\Aproject\quant_platform\backend\quant_engine\value_strategies.py
==================================================
"""
file: strategy_engine/value_strategies.py
Value Investment Strategies - ê°€ì¹˜íˆ¬ì ê´€ë ¨ ê³ ê¸‰ ì „ëµ 4ê°€ì§€
ì›Œë Œ ë²„í•, ë²¤ì €ë¯¼ ê·¸ë ˆì´ì—„, ì¡´ ë„¤í”„, ì¡°ì—˜ ê·¸ë¦°ë¸”ë¼íŠ¸ì˜ ì „ëµë“¤
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional
from base_strategy import BaseStrategy, StrategyMetadata, Signal, PortfolioWeight
from base_strategy import RiskLevel, Complexity, StrategyCategory, StrategyFactory
import fundamental_metrics as fm

# 11. ì›Œë Œ ë²„í•ì˜ í•´ì ì „ëµ
class BuffettMoatStrategy(BaseStrategy):
    """ì›Œë Œ ë²„í•ì˜ ê²½ì œì  í•´ì ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("Buffett_Moat_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ì›Œë Œ ë²„í•ì˜ í•´ì ì „ëµ",
            description="ê²½ìŸìš°ìœ„ê°€ ìˆëŠ” ê¸°ì—…ì„ í•©ë¦¬ì  ê°€ê²©ì— ì¥ê¸° ë³´ìœ ",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.MEDIUM,
            expected_return="12-16%",
            volatility="10-15%",
            min_investment_period="10ë…„ ì´ìƒ",
            rebalancing_frequency="ì—° 1íšŒ"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'pe_ratio', 'roe', 'roic', 'debt_to_equity', 'profit_margin', 
            'revenue_growth_5y', 'earnings_growth_5y', 'brand_strength', 
            'market_share', 'switching_cost'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # ë²„í• ê¸°ì¤€ íŒŒë¼ë¯¸í„°
        max_pe = self.parameters.get('max_pe', 20)
        min_roe = self.parameters.get('min_roe', 0.15)
        min_roic = self.parameters.get('min_roic', 0.12)
        max_debt_equity = self.parameters.get('max_debt_equity', 0.5)
        min_profit_margin = self.parameters.get('min_profit_margin', 0.1)
        min_revenue_growth = self.parameters.get('min_revenue_growth', 0.05)
        
        moat_data = data.dropna(subset=['pe_ratio', 'roe', 'roic'])
        
        for symbol in moat_data.index:
            # ê¸°ë³¸ ì¬ë¬´ ì§€í‘œ í™•ì¸
            pe_ratio = moat_data.loc[symbol, 'pe_ratio']
            roe = moat_data.loc[symbol, 'roe']
            roic = moat_data.loc[symbol, 'roic']
            debt_equity = moat_data.loc[symbol, 'debt_to_equity']
            profit_margin = moat_data.loc[symbol, 'profit_margin']
            
            # ë²„í•ì˜ ê¸°ë³¸ ì¡°ê±´ ê²€ì¦
            basic_conditions = [
                0 < pe_ratio <= max_pe,
                roe >= min_roe,
                roic >= min_roic,
                debt_equity <= max_debt_equity,
                profit_margin >= min_profit_margin
            ]
            
            if not all(basic_conditions):
                continue
            
            # ê²½ì œì  í•´ì í‰ê°€
            moat_score = self._evaluate_economic_moat(moat_data.loc[symbol])
            
            if moat_score >= 0.6:  # í•´ì ì ìˆ˜ 60% ì´ìƒ
                # ë‚´ì¬ê°€ì¹˜ ëŒ€ë¹„ í• ì¸ ì •ë„ ê³„ì‚°
                intrinsic_value = self._calculate_intrinsic_value(moat_data.loc[symbol])
                current_price = moat_data.loc[symbol, 'close']
                discount = (intrinsic_value - current_price) / intrinsic_value
                
                # ì•ˆì „ë§ˆì§„ 20% ì´ìƒì¼ ë•Œë§Œ ë§¤ìˆ˜
                if discount >= 0.2:
                    strength = min(1.0, moat_score * discount * 2)
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=strength,
                        confidence=0.85,
                        metadata={
                            'moat_score': moat_score,
                            'intrinsic_value': intrinsic_value,
                            'current_price': current_price,
                            'discount': discount,
                            'pe_ratio': pe_ratio,
                            'roe': roe,
                            'roic': roic
                        }
                    ))
        
        return self.validate_signals(signals)
    
    def _evaluate_economic_moat(self, company_data: pd.Series) -> float:
        """ê²½ì œì  í•´ì í‰ê°€"""
        moat_score = 0.0
        
        # ë¸Œëœë“œ íŒŒì›Œ (25%)
        brand_strength = company_data.get('brand_strength', 0.5)
        moat_score += brand_strength * 0.25
        
        # ì‹œì¥ ì§€ë°°ë ¥ (25%)
        market_share = company_data.get('market_share', 0.3)
        if market_share > 0.3:  # ì‹œì¥ ì ìœ ìœ¨ 30% ì´ìƒ
            moat_score += min(1.0, market_share) * 0.25
        
        # ì „í™˜ ë¹„ìš© (20%)
        switching_cost = company_data.get('switching_cost', 0.5)
        moat_score += switching_cost * 0.2
        
        # ì§€ì†ì  ìˆ˜ìµì„± (15%)
        roe_consistency = self._calculate_roe_consistency(company_data)
        moat_score += roe_consistency * 0.15
        
        # ì¬íˆ¬ì íš¨ìœ¨ì„± (15%)
        roic = company_data.get('roic', 0.1)
        if roic > 0.15:
            reinvestment_score = min(1.0, roic / 0.3)
            moat_score += reinvestment_score * 0.15
        
        return min(1.0, moat_score)
    
    def _calculate_roe_consistency(self, company_data: pd.Series) -> float:
        """ROE ì¼ê´€ì„± í‰ê°€"""
        # ê°„ë‹¨í™”: ROEê°€ 15% ì´ìƒì´ê³  ì•ˆì •ì ì´ë©´ ë†’ì€ ì ìˆ˜
        roe = company_data.get('roe', 0)
        if roe >= 0.15:
            return 1.0
        elif roe >= 0.1:
            return 0.6
        else:
            return 0.2
    
    def _calculate_intrinsic_value(self, company_data: pd.Series) -> float:
        """ê°„ë‹¨í•œ ë‚´ì¬ê°€ì¹˜ ê³„ì‚° (DCF ëª¨í˜• ë‹¨ìˆœí™”)"""
        # í˜„ì¬ ìˆ˜ìµì„ ê¸°ë°˜ìœ¼ë¡œ í•œ ì¶”ì •
        current_price = company_data.get('close', 100)
        pe_ratio = company_data.get('pe_ratio', 15)
        earnings_per_share = current_price / pe_ratio
        
        # ì„±ì¥ë¥  ì¶”ì •
        earnings_growth = company_data.get('earnings_growth_5y', 0.08)
        discount_rate = 0.1  # 10% í• ì¸ìœ¨
        
        # 10ë…„ DCF ë‹¨ìˆœ ê³„ì‚°
        intrinsic_value = 0
        for year in range(1, 11):
            future_earnings = earnings_per_share * (1 + earnings_growth) ** year
            present_value = future_earnings / (1 + discount_rate) ** year
            intrinsic_value += present_value
        
        # í„°ë¯¸ë„ ê°€ì¹˜ (ë‹¨ìˆœí™”)
        terminal_value = (earnings_per_share * (1 + earnings_growth) ** 10 * 15) / (1 + discount_rate) ** 10
        intrinsic_value += terminal_value
        
        return intrinsic_value
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # ì§‘ì¤‘ íˆ¬ì (ë²„í• ìŠ¤íƒ€ì¼)
        # ìƒìœ„ ì¢…ëª©ì— ë” ë†’ì€ ê°€ì¤‘ì¹˜
        signals_sorted = sorted(signals, key=lambda x: x.strength, reverse=True)
        top_signals = signals_sorted[:min(10, len(signals_sorted))]  # ìµœëŒ€ 10ê°œ ì¢…ëª©
        
        weights = []
        total_strength = sum(signal.strength for signal in top_signals)
        
        for i, signal in enumerate(top_signals):
            # ìƒìœ„ ì¢…ëª©ì¼ìˆ˜ë¡ ë” ë†’ì€ ê°€ì¤‘ì¹˜ (ì§‘ì¤‘ë„ ì¦ê°€)
            position_multiplier = 1.5 if i < 3 else 1.0  # ìƒìœ„ 3ê°œ ì¢…ëª© ê°€ì¤‘ì¹˜ ì¦ê°€
            adjusted_strength = signal.strength * position_multiplier
            weight = adjusted_strength / (total_strength * 1.2)  # ì¡°ì •ëœ ì´í•©ìœ¼ë¡œ ë‚˜ëˆ”
            
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 12. í”¼í„° ë¦°ì¹˜ì˜ PEG ì „ëµ
class PeterLynchPEGStrategy(BaseStrategy):
    """í”¼í„° ë¦°ì¹˜ì˜ PEG ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("Peter_Lynch_PEG_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="í”¼í„° ë¦°ì¹˜ì˜ PEG ì „ëµ",
            description="PEG ë¹„ìœ¨ 1.0 ì´í•˜ ì„±ì¥ì£¼ ë°œêµ´, 10ë°° ì£¼ì‹ ì¶”êµ¬",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.MEDIUM,
            expected_return="13-18%",
            volatility="16-22%",
            min_investment_period="2ë…„ ì´ìƒ",
            rebalancing_frequency="ë¶„ê¸°ë³„"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'pe_ratio', 'earnings_growth_rate', 'revenue_growth_rate', 
            'market_cap', 'industry_type', 'consumer_exposure'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        max_peg = self.parameters.get('max_peg', 1.0)
        min_growth_rate = self.parameters.get('min_growth_rate', 0.1)  # 10%
        max_pe = self.parameters.get('max_pe', 30)
        
        peg_data = data.dropna(subset=['pe_ratio', 'earnings_growth_rate'])
        
        for symbol in peg_data.index:
            pe_ratio = peg_data.loc[symbol, 'pe_ratio']
            growth_rate = peg_data.loc[symbol, 'earnings_growth_rate']
            
            # PEG ê³„ì‚°
            if growth_rate <= 0:
                continue
            
            peg_ratio = pe_ratio / (growth_rate * 100)
            
            # ë¦°ì¹˜ì˜ ê¸°ë³¸ ì¡°ê±´
            conditions = [
                peg_ratio <= max_peg,
                growth_rate >= min_growth_rate,
                pe_ratio <= max_pe,
                pe_ratio > 0
            ]
            
            if not all(conditions):
                continue
            
            # ì¶”ê°€ ë¦°ì¹˜ ìŠ¤íƒ€ì¼ í‰ê°€
            lynch_score = self._evaluate_lynch_criteria(peg_data.loc[symbol], peg_ratio)
            
            if lynch_score >= 0.5:
                # PEGê°€ ë‚®ì„ìˆ˜ë¡, ì„±ì¥ë¥ ì´ ë†’ì„ìˆ˜ë¡ ë†’ì€ ê°•ë„
                growth_bonus = min(1.0, growth_rate / 0.3)  # 30% ì„±ì¥ì„ ìµœëŒ€ë¡œ
                peg_bonus = max(0.1, (1.0 - peg_ratio))  # PEGê°€ ë‚®ì„ìˆ˜ë¡ ë†’ì€ ì ìˆ˜
                strength = min(1.0, lynch_score * growth_bonus * peg_bonus)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=0.75,
                    metadata={
                        'peg_ratio': peg_ratio,
                        'growth_rate': growth_rate,
                        'pe_ratio': pe_ratio,
                        'lynch_score': lynch_score
                    }
                ))
        
        return self.validate_signals(signals)
    
    def _evaluate_lynch_criteria(self, company_data: pd.Series, peg_ratio: float) -> float:
        """ë¦°ì¹˜ì˜ ì¶”ê°€ í‰ê°€ ê¸°ì¤€"""
        score = 0.0
        
        # 1. ì´í•´í•˜ê¸° ì‰¬ìš´ ì‚¬ì—… (ì†Œë¹„ì ë…¸ì¶œë„)
        consumer_exposure = company_data.get('consumer_exposure', 0.5)
        score += consumer_exposure * 0.3
        
        # 2. ì ë‹¹í•œ í¬ê¸° (ë„ˆë¬´ í¬ì§€ ì•Šì€ ê¸°ì—… ì„ í˜¸)
        market_cap = company_data.get('market_cap', 5000)
        if 1000 <= market_cap <= 50000:  # 10ì–µ-500ì–µ ë‹¬ëŸ¬
            size_score = 1.0
        elif market_cap <= 100000:  # 1000ì–µ ë‹¬ëŸ¬ ì´í•˜
            size_score = 0.7
        else:
            size_score = 0.3
        score += size_score * 0.2
        
        # 3. ë§¤ì¶œ ì„±ì¥ë¥  ì¼ê´€ì„±
        revenue_growth = company_data.get('revenue_growth_rate', 0.05)
        if revenue_growth > 0.1:  # 10% ì´ìƒ
            score += 0.3
        elif revenue_growth > 0.05:  # 5% ì´ìƒ
            score += 0.2
        
        # 4. PEG ìš°ìˆ˜ì„± (0.5 ì´í•˜ë©´ ë³´ë„ˆìŠ¤)
        if peg_ratio <= 0.5:
            score += 0.2
        
        return min(1.0, score)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # PEGì™€ ì„±ì¥ë¥  ê¸°ë°˜ ê°€ì¤‘ì¹˜ (ì„±ì¥ì£¼ ìŠ¤íƒ€ì¼)
        weights = []
        total_strength = sum(signal.strength for signal in signals)
        
        for signal in signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 13. ë²¤ì €ë¯¼ ê·¸ë ˆì´ì—„ì˜ ë°©ì–´ì  íˆ¬ì
class BenjaminGrahamDefensiveStrategy(BaseStrategy):
    """ë²¤ì €ë¯¼ ê·¸ë ˆì´ì—„ì˜ ë°©ì–´ì  íˆ¬ìì ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("Benjamin_Graham_Defensive_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ë²¤ì €ë¯¼ ê·¸ë ˆì´ì—„ì˜ ë°©ì–´ì  íˆ¬ì",
            description="ì•ˆì „ì„±ê³¼ ìˆ˜ìµì„±ì„ ê²¸ë¹„í•œ ë³´ìˆ˜ì  ê°€ì¹˜íˆ¬ì",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.MEDIUM,
            expected_return="9-13%",
            volatility="10-16%",
            min_investment_period="3ë…„ ì´ìƒ",
            rebalancing_frequency="ì—° 1íšŒ"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'pe_ratio', 'pb_ratio', 'current_ratio', 'debt_to_equity', 
            'dividend_yield', 'earnings_stability', 'dividend_years', 'market_cap'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # ê·¸ë ˆì´ì—„ì˜ ë°©ì–´ì  íˆ¬ìì ê¸°ì¤€
        max_pe = self.parameters.get('max_pe', 15)
        max_pb = self.parameters.get('max_pb', 1.5)
        min_current_ratio = self.parameters.get('min_current_ratio', 2.0)
        max_debt_equity = self.parameters.get('max_debt_equity', 0.5)
        min_dividend_years = self.parameters.get('min_dividend_years', 3)
        min_market_cap_rank = self.parameters.get('min_market_cap_percentile', 0.7)  # ìƒìœ„ 30%
        
        graham_data = data.dropna(subset=['pe_ratio', 'pb_ratio', 'current_ratio'])
        
        # ì‹œê°€ì´ì•¡ ê¸°ì¤€ì„  ê³„ì‚°
        market_cap_threshold = graham_data['market_cap'].quantile(min_market_cap_rank)
        
        for symbol in graham_data.index:
            company_data = graham_data.loc[symbol]
            
            # ê·¸ë ˆì´ì—„ì˜ 7ê°€ì§€ ê¸°ì¤€ ê²€ì¦
            graham_criteria = [
                0 < company_data['pe_ratio'] <= max_pe,
                0 < company_data['pb_ratio'] <= max_pb,
                company_data['current_ratio'] >= min_current_ratio,
                company_data['debt_to_equity'] <= max_debt_equity,
                company_data.get('dividend_years', 0) >= min_dividend_years,
                company_data['market_cap'] >= market_cap_threshold,
                company_data.get('earnings_stability', 0) >= 0.7  # ìˆ˜ìµ ì•ˆì •ì„±
            ]
            
            passed_criteria = sum(graham_criteria)
            
            # ìµœì†Œ 5ê°œ ê¸°ì¤€ ì´ìƒ ì¶©ì¡±
            if passed_criteria >= 5:
                # ì¶”ê°€ ì•ˆì „ì„± ê²€ì¦
                safety_score = self._calculate_safety_margin(company_data)
                
                if safety_score >= 0.6:
                    # ì¶©ì¡± ê¸°ì¤€ ìˆ˜ì™€ ì•ˆì „ì„±ì„ ê¸°ë°˜ìœ¼ë¡œ ê°•ë„ ê³„ì‚°
                    criteria_score = passed_criteria / 7
                    strength = min(1.0, criteria_score * safety_score * 1.2)
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=strength,
                        confidence=0.9,
                        metadata={
                            'passed_criteria': passed_criteria,
                            'safety_score': safety_score,
                            'pe_ratio': company_data['pe_ratio'],
                            'pb_ratio': company_data['pb_ratio'],
                            'current_ratio': company_data['current_ratio']
                        }
                    ))
        
        return self.validate_signals(signals)
    
    def _calculate_safety_margin(self, company_data: pd.Series) -> float:
        """ì•ˆì „ë§ˆì§„ ê³„ì‚°"""
        safety_score = 0.0
        
        # ìœ ë™ì„± ì•ˆì „ì„± (30%)
        current_ratio = company_data['current_ratio']
        if current_ratio >= 3.0:
            liquidity_score = 1.0
        elif current_ratio >= 2.0:
            liquidity_score = 0.8
        else:
            liquidity_score = max(0, (current_ratio - 1.0) / 1.0)
        safety_score += liquidity_score * 0.3
        
        # ë¶€ì±„ ì•ˆì „ì„± (25%)
        debt_equity = company_data['debt_to_equity']
        debt_score = max(0, (0.5 - debt_equity) / 0.5)
        safety_score += debt_score * 0.25
        
        # ë°¸ë¥˜ì—ì´ì…˜ ì•ˆì „ì„± (25%)
        pe_ratio = company_data['pe_ratio']
        pb_ratio = company_data['pb_ratio']
        if pe_ratio > 0 and pb_ratio > 0:
            pe_score = max(0, (15 - pe_ratio) / 15)
            pb_score = max(0, (1.5 - pb_ratio) / 1.5)
            valuation_score = (pe_score + pb_score) / 2
            safety_score += valuation_score * 0.25
        
        # ë°°ë‹¹ ì•ˆì „ì„± (20%)
        dividend_yield = company_data.get('dividend_yield', 0)
        dividend_years = company_data.get('dividend_years', 0)
        if dividend_yield > 0.02 and dividend_years >= 5:
            dividend_score = min(1.0, (dividend_yield / 0.06) * 0.5 + (dividend_years / 20) * 0.5)
            safety_score += dividend_score * 0.2
        
        return min(1.0, safety_score)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # ë³´ìˆ˜ì  ê· ë“± ë¶„ì‚° (ê·¸ë ˆì´ì—„ ìŠ¤íƒ€ì¼)
        target_weight = 1.0 / len(signals)
        weights = []
        
        for signal in signals:
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 14. ì¡°ì—˜ ê·¸ë¦°ë¸”ë¼íŠ¸ì˜ ë§ˆë²•ê³µì‹
class JoelGreenblattMagicFormulaStrategy(BaseStrategy):
    """ì¡°ì—˜ ê·¸ë¦°ë¸”ë¼íŠ¸ì˜ ë§ˆë²•ê³µì‹ ì „ëµ"""
    
    def __init__(self, **kwargs):
        super().__init__("Joel_Greenblatt_Magic_Formula_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="ì¡°ì—˜ ê·¸ë¦°ë¸”ë¼íŠ¸ì˜ ë§ˆë²•ê³µì‹",
            description="ROE + ìˆ˜ìµìˆ˜ìµë¥ (E/P) ê²°í•©í•œ ì²´ê³„ì  ê°€ì¹˜íˆ¬ì",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.MEDIUM,
            expected_return="12-17%",
            volatility="14-20%",
            min_investment_period="3ë…„ ì´ìƒ",
            rebalancing_frequency="ì—° 1íšŒ"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'roe', 'pe_ratio', 'roic', 'market_cap'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        min_market_cap = self.parameters.get('min_market_cap', 1000)  # 10ì–µ ë‹¬ëŸ¬
        top_stocks = self.parameters.get('top_stocks', 30)
        
        magic_data = data.dropna(subset=['roe', 'pe_ratio'])
        
        # ì‹œê°€ì´ì•¡ í•„í„°ë§
        magic_data = magic_data[magic_data['market_cap'] >= min_market_cap]
        
        if len(magic_data) == 0:
            return []
        
        # ë§ˆë²•ê³µì‹ ë­í‚¹ ê³„ì‚°
        magic_scores = []
        
        for symbol in magic_data.index:
            company_data = magic_data.loc[symbol]
            
            # ìˆ˜ìµìˆ˜ìµë¥  ê³„ì‚° (E/P = 1/PE)
            pe_ratio = company_data['pe_ratio']
            if pe_ratio <= 0:
                continue
            
            earnings_yield = 1 / pe_ratio
            roe = company_data['roe']
            
            # ROIC ì‚¬ìš© ê°€ëŠ¥í•˜ë©´ ROE ëŒ€ì‹  ì‚¬ìš©
            if 'roic' in company_data and pd.notna(company_data['roic']):
                return_on_capital = company_data['roic']
            else:
                return_on_capital = roe
            
            magic_scores.append({
                'symbol': symbol,
                'earnings_yield': earnings_yield,
                'return_on_capital': return_on_capital,
                'company_data': company_data
            })
        
        if not magic_scores:
            return []
        
        # ê° ì§€í‘œë³„ ìˆœìœ„ ê³„ì‚°
        df_scores = pd.DataFrame(magic_scores)
        df_scores['ey_rank'] = df_scores['earnings_yield'].rank(ascending=False)
        df_scores['roc_rank'] = df_scores['return_on_capital'].rank(ascending=False)
        df_scores['combined_rank'] = df_scores['ey_rank'] + df_scores['roc_rank']
        
        # ìƒìœ„ ì¢…ëª© ì„ ë³„
        df_scores = df_scores.sort_values('combined_rank')
        top_selections = df_scores.head(top_stocks)
        
        for _, row in top_selections.iterrows():
            # ìˆœìœ„ê°€ ë†’ì„ìˆ˜ë¡ ë†’ì€ ê°•ë„
            max_rank = len(df_scores) * 2  # ë‘ ìˆœìœ„ í•©ì˜ ìµœëŒ€ê°’
            strength = 1.0 - (row['combined_rank'] / max_rank)
            
            signals.append(Signal(
                symbol=row['symbol'],
                timestamp=pd.Timestamp.now(),
                signal_type='BUY',
                strength=strength,
                confidence=0.8,
                metadata={
                    'earnings_yield': row['earnings_yield'],
                    'return_on_capital': row['return_on_capital'],
                    'ey_rank': row['ey_rank'],
                    'roc_rank': row['roc_rank'],
                    'combined_rank': row['combined_rank']
                }
            ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # ë§ˆë²•ê³µì‹ì€ ë™ì¼ ê°€ì¤‘ì¹˜ ê¶Œì¥
        target_weight = 1.0 / len(signals)
        weights = []
        
        for signal in signals:
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# ì „ëµ íŒ©í† ë¦¬ì— ë“±ë¡
def register_value_strategies():
    """ê°€ì¹˜íˆ¬ì ì „ëµë“¤ì„ íŒ©í† ë¦¬ì— ë“±ë¡"""
    StrategyFactory.register_strategy("buffett_moat", BuffettMoatStrategy)
    StrategyFactory.register_strategy("peter_lynch_peg", PeterLynchPEGStrategy)
    StrategyFactory.register_strategy("benjamin_graham_defensive", BenjaminGrahamDefensiveStrategy)
    StrategyFactory.register_strategy("joel_greenblatt_magic", JoelGreenblattMagicFormulaStrategy)

# ëª¨ë“ˆ ë¡œë“œ ì‹œ ìë™ ë“±ë¡
register_value_strategies()


==================================================
File: C:\Aproject\quant_platform\backend\quant_engine\__init__.py
==================================================
"""
Investment Strategies Package - ê°œì¸íˆ¬ìììš© íˆ¬ìì „ëµ 20ê°€ì§€
íŒ¨í‚¤ì§€ ì´ˆê¸°í™” ë° ì£¼ìš” í´ë˜ìŠ¤/í•¨ìˆ˜ export
"""

import logging
from typing import Dict, List, Optional, Any

# íŒ¨í‚¤ì§€ ì •ë³´
__version__ = "1.0.0"
__author__ = "Investment Strategy Engine"
__description__ = "20ê°€ì§€ ê°œì¸íˆ¬ìììš© íˆ¬ìì „ëµ ë°±í…ŒìŠ¤íŒ… ì—”ì§„"

# ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# ì½”ì–´ ëª¨ë“ˆë“¤ import
try:
    # ê¸°ë³¸ ì „ëµ í´ë˜ìŠ¤
    from .base_strategy import (
        BaseStrategy, 
        StrategyMetadata, 
        Signal, 
        PortfolioWeight,
        RiskLevel,
        Complexity,
        StrategyCategory,
        calculate_sharpe_ratio,
        calculate_sortino_ratio
    )
    
    # íŒ©í† ë¦¬ ë° ë§¤ë‹ˆì €
    from .strategy_factory import (
        StrategyFactory,
        StrategyRegistry,
        StrategyManager,
        StrategyLoader,
        strategy_registry,
        create_strategy_combination,
        get_recommended_strategies,
        initialize_strategy_system
    )
    
    # ê¸°ìˆ ì  ì§€í‘œ
    from .technical_indicators import (
        simple_moving_average,
        exponential_moving_average,
        rsi,
        macd,
        bollinger_bands,
        stochastic,
        atr as average_true_range,
        on_balance_volume,
        momentum,
        relative_strength
    )
    
    # í€ë”ë©˜í„¸ ì§€í‘œ
    from .fundamental_metrics import (
        price_to_earnings_ratio,
        price_to_book_ratio,
        return_on_equity,
        debt_to_equity_ratio,
        current_ratio,
        dividend_yield,
        piotroski_f_score,
        altman_z_score,
        calculate_quality_score
    )
    
    # í¬íŠ¸í´ë¦¬ì˜¤ ìœ í‹¸ë¦¬í‹°
    from .portfolio_utils import (
        equal_weight_portfolio,
        market_cap_weighted_portfolio,
        risk_parity_portfolio,
        minimum_variance_portfolio,
        calculate_rebalancing_trades,
        calculate_portfolio_metrics,
        efficient_frontier,
        kelly_criterion_weights
    )

except ImportError as e:
    logging.warning(f"Some modules could not be imported: {e}")

# ì „ëµ ëª¨ë“ˆë“¤ import (ì„ íƒì )
try:
    from . import basic_strategies
    from . import value_strategies  
    from . import growth_momentum_strategies
    from . import cycle_contrarian_strategies
    
    # ì „ëµ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    initialize_strategy_system()
    
except ImportError as e:
    logging.warning(f"Strategy modules could not be loaded: {e}")

# ê³µê°œ API ì •ì˜
__all__ = [
    # ë²„ì „ ì •ë³´
    "__version__",
    "__author__", 
    "__description__",
    
    # ì½”ì–´ í´ë˜ìŠ¤ë“¤
    "BaseStrategy",
    "StrategyMetadata", 
    "Signal",
    "PortfolioWeight",
    "RiskLevel",
    "Complexity", 
    "StrategyCategory",
    
    # íŒ©í† ë¦¬ ë° ë§¤ë‹ˆì €
    "StrategyFactory",
    "StrategyRegistry",
    "StrategyManager", 
    "StrategyLoader",
    "strategy_registry",
    
    # í—¬í¼ í•¨ìˆ˜ë“¤
    "create_strategy_combination",
    "get_recommended_strategies",
    "initialize_strategy_system",
    
    # ê¸°ìˆ ì  ì§€í‘œ (ì£¼ìš”)
    "simple_moving_average",
    "exponential_moving_average", 
    "rsi",
    "macd",
    "bollinger_bands",
    
    # í€ë”ë©˜í„¸ ì§€í‘œ (ì£¼ìš”)
    "price_to_earnings_ratio",
    "return_on_equity",
    "debt_to_equity_ratio",
    "calculate_quality_score",
    
    # í¬íŠ¸í´ë¦¬ì˜¤ í•¨ìˆ˜ (ì£¼ìš”)
    "equal_weight_portfolio",
    "risk_parity_portfolio",
    "calculate_portfolio_metrics",
    "kelly_criterion_weights",
    
    # ì„±ê³¼ ì¸¡ì • í•¨ìˆ˜ë“¤
    "calculate_sharpe_ratio",
    "calculate_sortino_ratio"
]

# íŒ¨í‚¤ì§€ ë ˆë²¨ í¸ì˜ í•¨ìˆ˜ë“¤
def get_strategy_list() -> List[str]:
    """ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  ì „ëµ ëª©ë¡ ë°˜í™˜"""
    try:
        return strategy_registry.list_strategies()
    except:
        return []

def create_strategy(strategy_name: str, **kwargs) -> Optional[BaseStrategy]:
    """ì „ëµ ìƒì„± í¸ì˜ í•¨ìˆ˜"""
    try:
        return strategy_registry.create_strategy(strategy_name, **kwargs)
    except Exception as e:
        logging.error(f"Failed to create strategy {strategy_name}: {e}")
        return None

def get_basic_strategies() -> List[str]:
    """ê¸°ë³¸ ì „ëµ 10ê°€ì§€ ëª©ë¡"""
    basic_list = [
        "low_pe",
        "dividend_aristocrats", 
        "simple_momentum",
        "moving_average_cross",
        "rsi_mean_reversion",
        "bollinger_band",
        "small_cap",
        "low_volatility", 
        "quality_factor",
        "regular_rebalancing"
    ]
    available = get_strategy_list()
    return [s for s in basic_list if s in available]

def get_advanced_strategies() -> List[str]:
    """ê³ ê¸‰ ì „ëµ 10ê°€ì§€ ëª©ë¡"""
    advanced_list = [
        "buffett_moat",
        "peter_lynch_peg", 
        "benjamin_graham_defensive",
        "joel_greenblatt_magic",
        "william_oneil_canslim",
        "howard_marks_cycle",
        "james_oshaughnessy",
        "ray_dalio_all_weather",
        "david_dreman_contrarian",
        "john_neff_low_pe_dividend"
    ]
    available = get_strategy_list()
    return [s for s in advanced_list if s in available]

def get_strategy_by_risk_level(risk_level: str) -> List[str]:
    """ìœ„í—˜ë„ë³„ ì „ëµ í•„í„°ë§"""
    try:
        return strategy_registry.search_strategies(risk_level=risk_level)
    except:
        return []

def get_strategy_by_complexity(complexity: str) -> List[str]:
    """ë³µì¡ë„ë³„ ì „ëµ í•„í„°ë§"""
    try:
        return strategy_registry.search_strategies(complexity=complexity)
    except:
        return []

def print_package_info():
    """íŒ¨í‚¤ì§€ ì •ë³´ ì¶œë ¥"""
    total_strategies = len(get_strategy_list())
    basic_count = len(get_basic_strategies())  
    advanced_count = len(get_advanced_strategies())
    
    print(f"""
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘           Investment Strategies Package v{__version__}           â•‘
    â•‘                                                            â•‘
    â•‘  ê°œì¸íˆ¬ììë¥¼ ìœ„í•œ 20ê°€ì§€ íˆ¬ìì „ëµ ë°±í…ŒìŠ¤íŒ… ì—”ì§„                   â•‘
    â•‘                                                            â•‘
    â•‘  ğŸ“Š ì „ì²´ ì „ëµ: {total_strategies}ê°œ                                      â•‘
    â•‘  ğŸ“ˆ ê¸°ë³¸ ì „ëµ: {basic_count}ê°œ                                      â•‘  
    â•‘  ğŸ¯ ê³ ê¸‰ ì „ëµ: {advanced_count}ê°œ                                      â•‘
    â•‘                                                            â•‘
    â•‘  ì£¼ìš” ê¸°ëŠ¥:                                                  â•‘
    â•‘  â€¢ ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚°                                           â•‘
    â•‘  â€¢ í€ë”ë©˜í„¸ ë¶„ì„                                             â•‘
    â•‘  â€¢ í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™”                                          â•‘
    â•‘  â€¢ ë°±í…ŒìŠ¤íŒ… & ì„±ê³¼ ì¸¡ì •                                       â•‘
    â•‘                                                            â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)

def quick_start_guide():
    """ë¹ ë¥¸ ì‹œì‘ ê°€ì´ë“œ"""
    print("""
    ğŸš€ Quick Start Guide:
    
    1. ì „ëµ ëª©ë¡ í™•ì¸:
       >>> import strategies
       >>> strategies.get_strategy_list()
    
    2. ì „ëµ ìƒì„±:
       >>> strategy = strategies.create_strategy('low_pe')
    
    3. ì‹ í˜¸ ìƒì„±:
       >>> signals = strategy.generate_signals(data)
    
    4. í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¤‘ì¹˜:
       >>> weights = strategy.calculate_weights(signals)
    
    5. ì¶”ì²œ ì „ëµ:
       >>> user_profile = {'risk_tolerance': 'medium', 'experience_level': 'beginner'}
       >>> recommended = strategies.get_recommended_strategies(user_profile)
    
    ìì„¸í•œ ì‚¬ìš©ë²•ì€ ê° ì „ëµì˜ ë©”íƒ€ë°ì´í„°ë¥¼ í™•ì¸í•˜ì„¸ìš”.
    """)

# íŒ¨í‚¤ì§€ ë¡œë”© ì™„ë£Œ ë©”ì‹œì§€
def _on_import():
    """íŒ¨í‚¤ì§€ import ì‹œ ì‹¤í–‰"""
    total_strategies = len(get_strategy_list())
    if total_strategies > 0:
        logging.info(f"Investment Strategies Package v{__version__} loaded successfully with {total_strategies} strategies")
    else:
        logging.warning("Investment Strategies Package loaded but no strategies found")

# íŒ¨í‚¤ì§€ importì‹œ ìë™ ì‹¤í–‰
_on_import()

# ì‚¬ìš©ì í¸ì˜ë¥¼ ìœ„í•œ ë³„ì¹­ë“¤
create = create_strategy
list_all = get_strategy_list
list_basic = get_basic_strategies
list_advanced = get_advanced_strategies
info = print_package_info
help = quick_start_guide

# ë””ë²„ê·¸ ëª¨ë“œ ì„¤ì •
DEBUG = False

def set_debug_mode(enabled: bool = True):
    """ë””ë²„ê·¸ ëª¨ë“œ ì„¤ì •"""
    global DEBUG
    DEBUG = enabled
    log_level = logging.DEBUG if enabled else logging.INFO
    logging.getLogger().setLevel(log_level)
    
    if enabled:
        logging.info("Debug mode enabled")
    else:
        logging.info("Debug mode disabled") 


