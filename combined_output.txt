
==================================================
File: C:\Aproject\quant_platform\quant_engine\base_strategy.py
==================================================
"""
Base Strategy Class and Common Interfaces
전략 기본 클래스 및 공통 인터페이스
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple, Union
import pandas as pd
import numpy as np
from dataclasses import dataclass
from enum import Enum
import logging

# 설정 및 상수
class RiskLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"

class Complexity(Enum):
    SIMPLE = "simple"
    MEDIUM = "medium"
    COMPLEX = "complex"

class StrategyCategory(Enum):
    BASIC = "basic"
    ADVANCED = "advanced"

@dataclass
class StrategyMetadata:
    """전략 메타데이터"""
    name: str
    description: str
    category: StrategyCategory
    risk_level: RiskLevel
    complexity: Complexity
    expected_return: str
    volatility: str
    min_investment_period: str
    rebalancing_frequency: str

@dataclass
class Signal:
    """매매 신호"""
    symbol: str
    timestamp: pd.Timestamp
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    strength: float  # 0.0 ~ 1.0
    confidence: float  # 0.0 ~ 1.0
    metadata: Optional[Dict] = None

@dataclass
class PortfolioWeight:
    """포트폴리오 가중치"""
    symbol: str
    weight: float
    target_weight: float
    current_weight: float
    rebalance_needed: bool = False

class BaseStrategy(ABC):
    """전략 기본 클래스"""
    
    def __init__(self, name: str, **kwargs):
        self.name = name
        self.parameters = kwargs
        self.metadata = self._get_metadata()
        self.logger = logging.getLogger(f"Strategy.{name}")
        self._validate_parameters()
    
    @abstractmethod
    def _get_metadata(self) -> StrategyMetadata:
        """전략 메타데이터 반환"""
        pass
    
    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        """매매 신호 생성"""
        pass
    
    @abstractmethod
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        """포트폴리오 가중치 계산"""
        pass
    
    def _validate_parameters(self):
        """파라미터 검증"""
        required_params = self._get_required_parameters()
        for param in required_params:
            if param not in self.parameters:
                raise ValueError(f"Required parameter '{param}' is missing for strategy '{self.name}'")
    
    def _get_required_parameters(self) -> List[str]:
        """필수 파라미터 목록 반환"""
        return []
    
    def preprocess_data(self, data: pd.DataFrame) -> pd.DataFrame:
        """데이터 전처리"""
        # 기본적인 데이터 정리
        data = data.copy()
        
        # 필수 컬럼 확인
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        missing_columns = [col for col in required_columns if col not in data.columns]
        if missing_columns:
            raise ValueError(f"Missing required columns: {missing_columns}")
        
        # 결측치 처리
        data = data.fillna(method='ffill').dropna()
        
        # 날짜 인덱스 설정
        if not isinstance(data.index, pd.DatetimeIndex):
            if 'date' in data.columns:
                data['date'] = pd.to_datetime(data['date'])
                data.set_index('date', inplace=True)
            else:
                self.logger.warning("No date column found, using existing index")
        
        return data
    
    def filter_universe(self, data: pd.DataFrame) -> pd.DataFrame:
        """투자 유니버스 필터링"""
        # 기본 필터링 조건
        filtered_data = data.copy()
        
        # 거래량 필터 (일평균 거래량이 너무 적은 종목 제외)
        min_volume = self.parameters.get('min_volume', 100000)
        if 'volume' in filtered_data.columns:
            avg_volume = filtered_data['volume'].rolling(20).mean()
            filtered_data = filtered_data[avg_volume > min_volume]
        
        # 가격 필터 (너무 저가주 제외)
        min_price = self.parameters.get('min_price', 1.0)
        if 'close' in filtered_data.columns:
            filtered_data = filtered_data[filtered_data['close'] > min_price]
        
        # 시가총액 필터 (설정된 경우)
        min_market_cap = self.parameters.get('min_market_cap')
        if min_market_cap and 'market_cap' in filtered_data.columns:
            filtered_data = filtered_data[filtered_data['market_cap'] > min_market_cap]
        
        return filtered_data
    
    def calculate_risk_metrics(self, returns: pd.Series) -> Dict[str, float]:
        """리스크 지표 계산"""
        if len(returns) == 0:
            return {}
        
        # 기본 리스크 지표
        volatility = returns.std() * np.sqrt(252)  # 연율화
        max_drawdown = self._calculate_max_drawdown(returns)
        var_95 = returns.quantile(0.05)  # 5% VaR
        
        # 하방 위험 지표
        downside_returns = returns[returns < 0]
        downside_volatility = downside_returns.std() * np.sqrt(252) if len(downside_returns) > 0 else 0
        
        return {
            'volatility': volatility,
            'max_drawdown': max_drawdown,
            'var_95': var_95,
            'downside_volatility': downside_volatility,
            'skewness': returns.skew(),
            'kurtosis': returns.kurtosis()
        }
    
    def _calculate_max_drawdown(self, returns: pd.Series) -> float:
        """최대 낙폭 계산"""
        cumulative = (1 + returns).cumprod()
        running_max = cumulative.expanding().max()
        drawdown = (cumulative - running_max) / running_max
        return drawdown.min()
    
    def get_strategy_info(self) -> Dict:
        """전략 정보 반환"""
        return {
            'name': self.name,
            'metadata': self.metadata,
            'parameters': self.parameters,
            'required_data': self._get_required_data_columns(),
            'rebalancing_frequency': self.metadata.rebalancing_frequency
        }
    
    def _get_required_data_columns(self) -> List[str]:
        """필요한 데이터 컬럼 반환"""
        return ['open', 'high', 'low', 'close', 'volume']
    
    def validate_signals(self, signals: List[Signal]) -> List[Signal]:
        """신호 검증 및 필터링"""
        valid_signals = []
        
        for signal in signals:
            # 신호 강도 검증
            if not 0 <= signal.strength <= 1:
                self.logger.warning(f"Invalid signal strength for {signal.symbol}: {signal.strength}")
                continue
            
            # 신뢰도 검증
            if not 0 <= signal.confidence <= 1:
                self.logger.warning(f"Invalid signal confidence for {signal.symbol}: {signal.confidence}")
                continue
            
            # 신호 타입 검증
            if signal.signal_type not in ['BUY', 'SELL', 'HOLD']:
                self.logger.warning(f"Invalid signal type for {signal.symbol}: {signal.signal_type}")
                continue
            
            valid_signals.append(signal)
        
        return valid_signals
    
    def apply_position_sizing(self, weights: List[PortfolioWeight]) -> List[PortfolioWeight]:
        """포지션 사이징 적용"""
        # 최대 단일 종목 비중 제한
        max_single_weight = self.parameters.get('max_single_weight', 0.1)  # 10%
        
        adjusted_weights = []
        for weight in weights:
            adjusted_weight = min(weight.target_weight, max_single_weight)
            
            adjusted_weights.append(PortfolioWeight(
                symbol=weight.symbol,
                weight=adjusted_weight,
                target_weight=adjusted_weight,
                current_weight=weight.current_weight,
                rebalance_needed=abs(adjusted_weight - weight.current_weight) > 0.01
            ))
        
        # 가중치 정규화 (합계가 1.0이 되도록)
        total_weight = sum(w.weight for w in adjusted_weights)
        if total_weight > 0:
            for weight in adjusted_weights:
                weight.weight /= total_weight
                weight.target_weight /= total_weight
        
        return adjusted_weights
    
    def log_strategy_performance(self, signals: List[Signal], weights: List[PortfolioWeight]):
        """전략 성과 로깅"""
        buy_signals = len([s for s in signals if s.signal_type == 'BUY'])
        sell_signals = len([s for s in signals if s.signal_type == 'SELL'])
        total_positions = len([w for w in weights if w.weight > 0])
        
        self.logger.info(f"Strategy {self.name} - Buy: {buy_signals}, Sell: {sell_signals}, Positions: {total_positions}")

class StrategyFactory:
    """전략 팩토리 클래스"""
    
    _strategies = {}
    
    @classmethod
    def register_strategy(cls, strategy_name: str, strategy_class):
        """전략 등록"""
        cls._strategies[strategy_name] = strategy_class
    
    @classmethod
    def create_strategy(cls, strategy_name: str, **kwargs):
        """전략 생성"""
        if strategy_name not in cls._strategies:
            raise ValueError(f"Unknown strategy: {strategy_name}")
        
        return cls._strategies[strategy_name](**kwargs)
    
    @classmethod
    def list_strategies(cls) -> List[str]:
        """등록된 전략 목록 반환"""
        return list(cls._strategies.keys())

# 유틸리티 함수들
def calculate_sharpe_ratio(returns: pd.Series, risk_free_rate: float = 0.02) -> float:
    """샤프 비율 계산"""
    if len(returns) == 0 or returns.std() == 0:
        return 0.0
    
    excess_returns = returns.mean() * 252 - risk_free_rate  # 연율화
    volatility = returns.std() * np.sqrt(252)
    
    return excess_returns / volatility

def calculate_sortino_ratio(returns: pd.Series, risk_free_rate: float = 0.02) -> float:
    """소르티노 비율 계산"""
    if len(returns) == 0:
        return 0.0
    
    excess_returns = returns.mean() * 252 - risk_free_rate
    downside_returns = returns[returns < 0]
    
    if len(downside_returns) == 0:
        return float('inf')
    
    downside_volatility = downside_returns.std() * np.sqrt(252)
    
    if downside_volatility == 0:
        return float('inf')
    
    return excess_returns / downside_volatility


==================================================
File: C:\Aproject\quant_platform\quant_engine\basic_strategies.py
==================================================
"""
Basic Investment Strategies - 10가지
개인투자자용 기본 전략들
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional
from base_strategy import BaseStrategy, StrategyMetadata, Signal, PortfolioWeight
from base_strategy import RiskLevel, Complexity, StrategyCategory, StrategyFactory
import technical_indicators as ti
import fundamental_metrics as fm

# 1. 저PER 전략
class LowPEStrategy(BaseStrategy):
    """저PER 전략 - PER 15배 이하 종목 선별"""
    
    def __init__(self, **kwargs):
        super().__init__("Low_PE_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="저PER 전략",
            description="PER 15배 이하 종목 선별하는 가치투자 전략",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.SIMPLE,
            expected_return="8-12%",
            volatility="12-18%",
            min_investment_period="1년 이상",
            rebalancing_frequency="분기별"
        )
    
    def _get_required_parameters(self) -> List[str]:
        return ['max_pe_ratio']
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + ['pe_ratio', 'market_cap']
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        max_pe = self.parameters.get('max_pe_ratio', 15)
        signals = []
        
        # PE 데이터가 있는 종목들만 처리
        pe_data = data.dropna(subset=['pe_ratio'])
        
        for symbol in pe_data.index:
            pe_ratio = pe_data.loc[symbol, 'pe_ratio']
            
            # 저PER 조건 확인
            if 0 < pe_ratio <= max_pe:
                # 추가 필터링: 적자 기업 제외, 최소 시가총액
                market_cap = pe_data.loc[symbol, 'market_cap']
                if market_cap > 1000:  # 10억 달러 이상
                    signal_strength = min(1.0, (max_pe - pe_ratio) / max_pe)
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=signal_strength,
                        confidence=0.7,
                        metadata={'pe_ratio': pe_ratio}
                    ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # 동일 가중치 방식
        target_weight = 1.0 / len(signals)
        weights = []
        
        for signal in signals:
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight,
                rebalance_needed=abs(target_weight - current_weight) > 0.01
            ))
        
        return self.apply_position_sizing(weights)

# 2. 배당 귀족주 전략
class DividendAristocratsStrategy(BaseStrategy):
    """배당 귀족주 전략 - 20년 이상 연속 배당 증가 기업"""
    
    def __init__(self, **kwargs):
        super().__init__("Dividend_Aristocrats_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="배당 귀족주 전략",
            description="20년 이상 연속 배당 증가 기업 투자",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.SIMPLE,
            expected_return="7-10%",
            volatility="10-15%",
            min_investment_period="3년 이상",
            rebalancing_frequency="연 1회"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + ['dividend_yield', 'dividend_growth_years']
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        min_dividend_years = self.parameters.get('min_dividend_years', 20)
        min_yield = self.parameters.get('min_dividend_yield', 0.02)
        
        signals = []
        dividend_data = data.dropna(subset=['dividend_yield', 'dividend_growth_years'])
        
        for symbol in dividend_data.index:
            dividend_years = dividend_data.loc[symbol, 'dividend_growth_years']
            dividend_yield = dividend_data.loc[symbol, 'dividend_yield']
            
            if dividend_years >= min_dividend_years and dividend_yield >= min_yield:
                # 신호 강도: 배당 기간과 수익률 기준
                strength = min(1.0, (dividend_years / 30) * 0.7 + (dividend_yield / 0.06) * 0.3)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=0.8,
                    metadata={
                        'dividend_years': dividend_years,
                        'dividend_yield': dividend_yield
                    }
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # 배당수익률 기준 가중치
        total_strength = sum(signal.strength for signal in signals)
        weights = []
        
        for signal in signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 3. 단순 모멘텀 전략
class SimpleMomentumStrategy(BaseStrategy):
    """단순 모멘텀 전략 - 최근 3-12개월 수익률 상위 종목"""
    
    def __init__(self, **kwargs):
        super().__init__("Simple_Momentum_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="단순 모멘텀 전략",
            description="최근 성과 상위 종목 투자, 상승 추세 추종",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.SIMPLE,
            expected_return="10-15%",
            volatility="16-22%",
            min_investment_period="6개월 이상",
            rebalancing_frequency="월별"
        )
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        lookback_months = self.parameters.get('lookback_months', 6)
        top_percentile = self.parameters.get('top_percentile', 0.2)  # 상위 20%
        
        signals = []
        
        # 가격 데이터에서 수익률 계산
        returns = data['close'].pct_change(lookback_months * 21)  # 약 월별 거래일
        
        # 상위 percentile 계산
        threshold = returns.quantile(1 - top_percentile)
        
        for symbol in returns.index:
            if pd.isna(returns[symbol]):
                continue
                
            if returns[symbol] >= threshold:
                # 추가 필터: 최근 변동성 확인
                recent_returns = data.loc[symbol, 'close'].pct_change().tail(21)
                volatility = recent_returns.std()
                
                # 과도한 변동성 종목 제외
                max_volatility = self.parameters.get('max_volatility', 0.05)
                if volatility <= max_volatility:
                    strength = min(1.0, returns[symbol] / (threshold * 2))
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=strength,
                        confidence=0.6,
                        metadata={
                            'momentum_return': returns[symbol],
                            'volatility': volatility
                        }
                    ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # 모멘텀 강도 기준 가중치
        total_strength = sum(signal.strength for signal in signals)
        weights = []
        
        for signal in signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 4. 이동평균 교차 전략
class MovingAverageCrossStrategy(BaseStrategy):
    """이동평균 교차 전략 - 20일선이 60일선 돌파"""
    
    def __init__(self, **kwargs):
        super().__init__("Moving_Average_Cross_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="이동평균 교차 전략",
            description="단기 이동평균이 장기 이동평균 상향 돌파시 매수",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.SIMPLE,
            expected_return="8-12%",
            volatility="14-20%",
            min_investment_period="6개월 이상",
            rebalancing_frequency="주별"
        )
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        short_period = self.parameters.get('short_ma', 20)
        long_period = self.parameters.get('long_ma', 60)
        
        signals = []
        
        for symbol in data.index:
            prices = data.loc[symbol, 'close']
            if len(prices) < long_period:
                continue
            
            # 이동평균 계산
            short_ma = ti.simple_moving_average(prices, short_period)
            long_ma = ti.simple_moving_average(prices, long_period)
            
            if len(short_ma) < 2 or len(long_ma) < 2:
                continue
            
            # 골든 크로스 확인 (단기선이 장기선을 상향 돌파)
            current_cross = short_ma.iloc[-1] > long_ma.iloc[-1]
            previous_cross = short_ma.iloc[-2] > long_ma.iloc[-2]
            
            if current_cross and not previous_cross:
                # 교차 강도 계산
                cross_strength = (short_ma.iloc[-1] - long_ma.iloc[-1]) / long_ma.iloc[-1]
                strength = min(1.0, abs(cross_strength) * 10)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=0.65,
                    metadata={
                        'short_ma': short_ma.iloc[-1],
                        'long_ma': long_ma.iloc[-1],
                        'cross_strength': cross_strength
                    }
                ))
            
            # 데드 크로스 확인 (매도 신호)
            elif not current_cross and previous_cross:
                cross_strength = (long_ma.iloc[-1] - short_ma.iloc[-1]) / long_ma.iloc[-1]
                strength = min(1.0, abs(cross_strength) * 10)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='SELL',
                    strength=strength,
                    confidence=0.65,
                    metadata={
                        'short_ma': short_ma.iloc[-1],
                        'long_ma': long_ma.iloc[-1],
                        'cross_strength': cross_strength
                    }
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        buy_signals = [s for s in signals if s.signal_type == 'BUY']
        if not buy_signals:
            return []
        
        # 동일 가중치
        target_weight = 1.0 / len(buy_signals)
        weights = []
        
        for signal in buy_signals:
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 5. RSI 과매수/과매도 전략
class RSIMeanReversionStrategy(BaseStrategy):
    """RSI 과매수/과매도 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("RSI_Mean_Reversion_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="RSI 평균회귀 전략",
            description="RSI 30 이하 매수, 70 이상 매도",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.SIMPLE,
            expected_return="10-13%",
            volatility="12-18%",
            min_investment_period="3개월 이상",
            rebalancing_frequency="주별"
        )
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        rsi_period = self.parameters.get('rsi_period', 14)
        oversold_threshold = self.parameters.get('oversold', 30)
        overbought_threshold = self.parameters.get('overbought', 70)
        
        signals = []
        
        for symbol in data.index:
            prices = data.loc[symbol, 'close']
            if len(prices) < rsi_period + 1:
                continue
            
            rsi = ti.rsi(prices, rsi_period)
            if len(rsi) == 0:
                continue
            
            current_rsi = rsi.iloc[-1]
            
            # 과매도 구간 (매수 신호)
            if current_rsi <= oversold_threshold:
                strength = (oversold_threshold - current_rsi) / oversold_threshold
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=0.7,
                    metadata={'rsi': current_rsi}
                ))
            
            # 과매수 구간 (매도 신호)
            elif current_rsi >= overbought_threshold:
                strength = (current_rsi - overbought_threshold) / (100 - overbought_threshold)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='SELL',
                    strength=strength,
                    confidence=0.7,
                    metadata={'rsi': current_rsi}
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        buy_signals = [s for s in signals if s.signal_type == 'BUY']
        if not buy_signals:
            return []
        
        # RSI 신호 강도 기반 가중치
        total_strength = sum(signal.strength for signal in buy_signals)
        weights = []
        
        for signal in buy_signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 6. 볼린저 밴드 역발상 전략
class BollingerBandStrategy(BaseStrategy):
    """볼린저 밴드 역발상 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("Bollinger_Band_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="볼린저 밴드 역발상 전략",
            description="하단선 터치시 매수, 상단선 터치시 매도",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.SIMPLE,
            expected_return="9-12%",
            volatility="13-19%",
            min_investment_period="6개월 이상",
            rebalancing_frequency="주별"
        )
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        bb_period = self.parameters.get('bb_period', 20)
        bb_std = self.parameters.get('bb_std', 2)
        
        signals = []
        
        for symbol in data.index:
            prices = data.loc[symbol, 'close']
            if len(prices) < bb_period:
                continue
            
            bb_upper, bb_middle, bb_lower = ti.bollinger_bands(prices, bb_period, bb_std)
            
            if len(bb_upper) == 0:
                continue
            
            current_price = prices.iloc[-1]
            current_upper = bb_upper.iloc[-1]
            current_lower = bb_lower.iloc[-1]
            current_middle = bb_middle.iloc[-1]
            
            # 하단선 근처 (매수 신호)
            if current_price <= current_lower * 1.02:  # 2% 버퍼
                distance_ratio = (current_lower - current_price) / (current_middle - current_lower)
                strength = min(1.0, max(0, distance_ratio))
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=0.65,
                    metadata={
                        'price': current_price,
                        'bb_lower': current_lower,
                        'bb_middle': current_middle
                    }
                ))
            
            # 상단선 근처 (매도 신호)
            elif current_price >= current_upper * 0.98:  # 2% 버퍼
                distance_ratio = (current_price - current_upper) / (current_upper - current_middle)
                strength = min(1.0, max(0, distance_ratio))
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='SELL',
                    strength=strength,
                    confidence=0.65,
                    metadata={
                        'price': current_price,
                        'bb_upper': current_upper,
                        'bb_middle': current_middle
                    }
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        buy_signals = [s for s in signals if s.signal_type == 'BUY']
        if not buy_signals:
            return []
        
        # 동일 가중치
        target_weight = 1.0 / len(buy_signals)
        weights = []
        
        for signal in buy_signals:
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 7. 소형주 프리미엄 전략
class SmallCapStrategy(BaseStrategy):
    """소형주 프리미엄 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("Small_Cap_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="소형주 프리미엄 전략",
            description="시가총액 하위 종목 투자로 초과수익 추구",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.HIGH,
            complexity=Complexity.SIMPLE,
            expected_return="12-18%",
            volatility="20-30%",
            min_investment_period="2년 이상",
            rebalancing_frequency="분기별"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + ['market_cap']
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        small_cap_percentile = self.parameters.get('small_cap_percentile', 0.2)  # 하위 20%
        
        signals = []
        market_cap_data = data.dropna(subset=['market_cap'])
        
        # 시가총액 하위 percentile 계산
        threshold = market_cap_data['market_cap'].quantile(small_cap_percentile)
        
        for symbol in market_cap_data.index:
            market_cap = market_cap_data.loc[symbol, 'market_cap']
            
            if market_cap <= threshold:
                # 최소 유동성 확인
                min_market_cap = self.parameters.get('min_market_cap', 100)  # 1억 달러
                if market_cap >= min_market_cap:
                    # 신호 강도는 시가총액이 작을수록 높음
                    strength = 1.0 - (market_cap / threshold)
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=strength,
                        confidence=0.6,
                        metadata={'market_cap': market_cap}
                    ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # 동일 가중치 (소형주는 집중 위험 방지)
        target_weight = 1.0 / len(signals)
        weights = []
        
        for signal in signals:
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 8. 저변동성 전략
class LowVolatilityStrategy(BaseStrategy):
    """저변동성 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("Low_Volatility_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="저변동성 전략",
            description="변동성이 낮은 종목으로 안정적 수익 추구",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.SIMPLE,
            expected_return="8-11%",
            volatility="8-12%",
            min_investment_period="1년 이상",
            rebalancing_frequency="분기별"
        )
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        volatility_period = self.parameters.get('volatility_period', 60)
        low_vol_percentile = self.parameters.get('low_vol_percentile', 0.3)  # 하위 30%
        
        signals = []
        volatilities = {}
        
        # 각 종목의 변동성 계산
        for symbol in data.index:
            prices = data.loc[symbol, 'close']
            if len(prices) < volatility_period:
                continue
            
            returns = prices.pct_change().dropna()
            volatility = returns.tail(volatility_period).std() * np.sqrt(252)  # 연율화
            volatilities[symbol] = volatility
        
        if not volatilities:
            return []
        
        # 저변동성 기준선 계산
        vol_values = list(volatilities.values())
        threshold = np.percentile(vol_values, low_vol_percentile * 100)
        
        for symbol, volatility in volatilities.items():
            if volatility <= threshold:
                # 변동성이 낮을수록 높은 강도
                strength = 1.0 - (volatility / threshold)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=0.75,
                    metadata={'volatility': volatility}
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # 역변동성 가중치 (변동성이 낮을수록 높은 가중치)
        total_inv_strength = sum(1/signal.strength if signal.strength > 0 else 1 for signal in signals)
        weights = []
        
        for signal in signals:
            inv_strength = 1/signal.strength if signal.strength > 0 else 1
            weight = inv_strength / total_inv_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 9. 품질 팩터 전략
class QualityFactorStrategy(BaseStrategy):
    """품질 팩터 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("Quality_Factor_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="품질 팩터 전략",
            description="ROE, 부채비율 등 재무 건전성 우수 기업",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.SIMPLE,
            expected_return="9-13%",
            volatility="12-16%",
            min_investment_period="2년 이상",
            rebalancing_frequency="분기별"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + ['roe', 'debt_ratio', 'current_ratio']
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        min_roe = self.parameters.get('min_roe', 0.15)
        max_debt_ratio = self.parameters.get('max_debt_ratio', 0.5)
        min_current_ratio = self.parameters.get('min_current_ratio', 1.2)
        
        signals = []
        quality_data = data.dropna(subset=['roe', 'debt_ratio', 'current_ratio'])
        
        for symbol in quality_data.index:
            roe = quality_data.loc[symbol, 'roe']
            debt_ratio = quality_data.loc[symbol, 'debt_ratio']
            current_ratio = quality_data.loc[symbol, 'current_ratio']
            
            # 품질 기준 충족 확인
            if roe >= min_roe and debt_ratio <= max_debt_ratio and current_ratio >= min_current_ratio:
                # 품질 점수 계산 (각 지표의 우수성 기준)
                roe_score = min(1.0, roe / 0.3)  # ROE 30%를 만점으로
                debt_score = max(0.0, (max_debt_ratio - debt_ratio) / max_debt_ratio)
                current_score = min(1.0, (current_ratio - 1.0) / 2.0)  # 유동비율 3.0을 만점으로
                
                quality_score = (roe_score + debt_score + current_score) / 3
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=quality_score,
                    confidence=0.8,
                    metadata={
                        'roe': roe,
                        'debt_ratio': debt_ratio,
                        'current_ratio': current_ratio,
                        'quality_score': quality_score
                    }
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # 품질 점수 기반 가중치
        total_strength = sum(signal.strength for signal in signals)
        weights = []
        
        for signal in signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 10. 정기 리밸런싱 전략
class RegularRebalancingStrategy(BaseStrategy):
    """정기 리밸런싱 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("Regular_Rebalancing_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="정기 리밸런싱 전략",
            description="정해진 비율로 정기적 리밸런싱하여 위험 관리",
            category=StrategyCategory.BASIC,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.SIMPLE,
            expected_return="8-12%",
            volatility="10-16%",
            min_investment_period="1년 이상",
            rebalancing_frequency="월별"
        )
    
    def _get_required_parameters(self) -> List[str]:
        return ['target_allocation']
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        target_allocation = self.parameters.get('target_allocation', {})
        rebalance_threshold = self.parameters.get('rebalance_threshold', 0.05)  # 5% 편차
        
        signals = []
        
        if not target_allocation:
            # 기본 동일 가중치
            symbols = data.index.tolist()
            equal_weight = 1.0 / len(symbols)
            target_allocation = {symbol: equal_weight for symbol in symbols}
        
        current_portfolio = self.parameters.get('current_portfolio', {})
        
        for symbol, target_weight in target_allocation.items():
            current_weight = current_portfolio.get(symbol, 0.0)
            weight_diff = abs(target_weight - current_weight)
            
            if weight_diff > rebalance_threshold:
                if target_weight > current_weight:
                    signal_type = 'BUY'
                    strength = min(1.0, weight_diff / rebalance_threshold)
                else:
                    signal_type = 'SELL'
                    strength = min(1.0, weight_diff / rebalance_threshold)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type=signal_type,
                    strength=strength,
                    confidence=0.9,
                    metadata={
                        'target_weight': target_weight,
                        'current_weight': current_weight,
                        'weight_diff': weight_diff
                    }
                ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        target_allocation = self.parameters.get('target_allocation', {})
        
        if not target_allocation:
            return []
        
        weights = []
        
        for symbol, target_weight in target_allocation.items():
            current_weight = current_portfolio.get(symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight,
                rebalance_needed=abs(target_weight - current_weight) > 0.01
            ))
        
        return weights

# 전략 팩토리에 등록
def register_basic_strategies():
    """기본 전략들을 팩토리에 등록"""
    StrategyFactory.register_strategy("low_pe", LowPEStrategy)
    StrategyFactory.register_strategy("dividend_aristocrats", DividendAristocratsStrategy)
    StrategyFactory.register_strategy("simple_momentum", SimpleMomentumStrategy)
    StrategyFactory.register_strategy("moving_average_cross", MovingAverageCrossStrategy)
    StrategyFactory.register_strategy("rsi_mean_reversion", RSIMeanReversionStrategy)
    StrategyFactory.register_strategy("bollinger_band", BollingerBandStrategy)
    StrategyFactory.register_strategy("small_cap", SmallCapStrategy)
    StrategyFactory.register_strategy("low_volatility", LowVolatilityStrategy)
    StrategyFactory.register_strategy("quality_factor", QualityFactorStrategy)
    StrategyFactory.register_strategy("regular_rebalancing", RegularRebalancingStrategy)

# 모듈 로드 시 자동 등록
register_basic_strategies()


==================================================
File: C:\Aproject\quant_platform\quant_engine\cycle_contrarian_strategies.py
==================================================
 """
Cycle & Contrarian Strategies - 사이클/역발상 관련 고급 전략 3가지
레이 달리오의 올웨더, 데이비드 드레먼의 역발상, 존 네프의 저PER+배당 전략
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple
from base_strategy import BaseStrategy, StrategyMetadata, Signal, PortfolioWeight
from base_strategy import RiskLevel, Complexity, StrategyCategory, StrategyFactory
import technical_indicators as ti
import fundamental_metrics as fm

# 18. 레이 달리오의 올웨더 포트폴리오
class RayDalioAllWeatherStrategy(BaseStrategy):
    """레이 달리오의 올웨더 포트폴리오 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("Ray_Dalio_All_Weather_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="레이 달리오의 올웨더 포트폴리오",
            description="경제 환경 변화에 관계없이 안정적 수익 추구",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.MEDIUM,
            expected_return="8-12%",
            volatility="8-12%",
            min_investment_period="5년 이상",
            rebalancing_frequency="분기별"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'asset_class', 'duration', 'correlation_matrix', 'volatility', 
            'inflation_sensitivity', 'growth_sensitivity'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        """올웨더는 고정 배분이므로 리밸런싱 신호만 생성"""
        signals = []
        
        # 기본 올웨더 배분
        target_allocation = self.parameters.get('target_allocation', {
            'stocks': 0.30,
            'long_term_bonds': 0.40,
            'intermediate_bonds': 0.15,
            'commodities': 0.075,
            'tips': 0.075  # Treasury Inflation-Protected Securities
        })
        
        current_allocation = self.parameters.get('current_allocation', {})
        rebalance_threshold = self.parameters.get('rebalance_threshold', 0.05)
        
        # 각 자산군별 리밸런싱 필요성 확인
        for asset_class, target_weight in target_allocation.items():
            current_weight = current_allocation.get(asset_class, 0.0)
            weight_diff = target_weight - current_weight
            
            if abs(weight_diff) > rebalance_threshold:
                # 리밸런싱 강도는 편차 크기에 비례
                strength = min(1.0, abs(weight_diff) / rebalance_threshold)
                
                signal_type = 'BUY' if weight_diff > 0 else 'SELL'
                
                # 자산군별 대표 종목들 찾기
                asset_symbols = self._get_asset_class_symbols(data, asset_class)
                
                for symbol in asset_symbols:
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type=signal_type,
                        strength=strength,
                        confidence=0.95,  # 올웨더는 확신도 높음
                        metadata={
                            'asset_class': asset_class,
                            'target_weight': target_weight,
                            'current_weight': current_weight,
                            'weight_diff': weight_diff,
                            'rebalancing_reason': 'all_weather_allocation'
                        }
                    ))
        
        return self.validate_signals(signals)
    
    def _get_asset_class_symbols(self, data: pd.DataFrame, asset_class: str) -> List[str]:
        """자산군별 해당 종목들 반환"""
        if 'asset_class' not in data.columns:
            # 기본 매핑 사용
            asset_mapping = {
                'stocks': ['SPY', 'VTI', 'ITOT'],
                'long_term_bonds': ['TLT', 'VGLT'],
                'intermediate_bonds': ['IEF', 'VGIT'],
                'commodities': ['DJP', 'PDBC', 'BCI'],
                'tips': ['TIPS', 'VTIP', 'SCHP']
            }
            return asset_mapping.get(asset_class, [])
        
        # 데이터에서 해당 자산군 종목들 찾기
        asset_symbols = data[data['asset_class'] == asset_class].index.tolist()
        return asset_symbols[:3]  # 최대 3개까지
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        
        target_allocation = self.parameters.get('target_allocation', {
            'stocks': 0.30,
            'long_term_bonds': 0.40,
            'intermediate_bonds': 0.15,
            'commodities': 0.075,
            'tips': 0.075
        })
        
        weights = []
        
        # 각 자산군 내에서 동일 가중치 배분
        asset_weights = {}
        for signal in signals:
            asset_class = signal.metadata.get('asset_class')
            if asset_class not in asset_weights:
                asset_weights[asset_class] = []
            asset_weights[asset_class].append(signal.symbol)
        
        for asset_class, symbols in asset_weights.items():
            target_asset_weight = target_allocation.get(asset_class, 0.0)
            weight_per_symbol = target_asset_weight / len(symbols)
            
            for symbol in symbols:
                current_weight = current_portfolio.get(symbol, 0.0) if current_portfolio else 0.0
                
                weights.append(PortfolioWeight(
                    symbol=symbol,
                    weight=weight_per_symbol,
                    target_weight=weight_per_symbol,
                    current_weight=current_weight,
                    rebalance_needed=abs(weight_per_symbol - current_weight) > 0.01
                ))
        
        return weights

# 19. 데이비드 드레먼의 역발상 투자
class DavidDremanContrarianStrategy(BaseStrategy):
    """데이비드 드레먼의 역발상 투자 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("David_Dreman_Contrarian_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="데이비드 드레먼의 역발상 투자",
            description="시장 공포와 비관론 속에서 저평가 기회 발굴",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.MEDIUM,
            expected_return="12-16%",
            volatility="16-22%",
            min_investment_period="2년 이상",
            rebalancing_frequency="분기별"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'pe_ratio', 'pb_ratio', 'sentiment_score', 'analyst_coverage',
            'news_sentiment', 'price_momentum_3m', 'earnings_surprise',
            'analyst_revisions', 'short_interest'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # 드레먼의 역발상 기준
        max_pe_percentile = self.parameters.get('max_pe_percentile', 0.2)  # 하위 20%
        fear_threshold = self.parameters.get('fear_threshold', -0.6)  # 부정적 감정
        min_market_cap = self.parameters.get('min_market_cap', 1000)  # 10억 달러
        
        contrarian_data = data.dropna(subset=['pe_ratio', 'pb_ratio'])
        
        # 시장 전체 공포 수준 확인
        market_fear_score = self._calculate_market_fear_level(contrarian_data)
        
        # 시장이 충분히 비관적이지 않으면 대기
        if market_fear_score > -0.5:
            return []
        
        # PE 기준선 계산 (하위 percentile)
        pe_threshold = contrarian_data['pe_ratio'].quantile(max_pe_percentile)
        
        for symbol in contrarian_data.index:
            company_data = contrarian_data.loc[symbol]
            
            # 기본 저평가 조건
            pe_ratio = company_data['pe_ratio']
            pb_ratio = company_data['pb_ratio']
            market_cap = company_data.get('market_cap', 0)
            
            basic_value_conditions = [
                0 < pe_ratio <= pe_threshold,
                0 < pb_ratio <= 2.0,
                market_cap >= min_market_cap
            ]
            
            if not all(basic_value_conditions):
                continue
            
            # 역발상 신호 평가
            contrarian_score = self._evaluate_contrarian_signals(company_data)
            
            if contrarian_score >= 0.6:  # 충분한 역발상 신호
                # 가치 + 역발상 종합 점수
                value_score = self._calculate_value_score(company_data, contrarian_data)
                final_strength = min(1.0, contrarian_score * value_score * 1.2)
                
                confidence = min(0.9, 0.6 + abs(market_fear_score) * 0.3)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=final_strength,
                    confidence=confidence,
                    metadata={
                        'contrarian_score': contrarian_score,
                        'value_score': value_score,
                        'market_fear_score': market_fear_score,
                        'pe_ratio': pe_ratio,
                        'pb_ratio': pb_ratio
                    }
                ))
        
        return self.validate_signals(signals)
    
    def _calculate_market_fear_level(self, data: pd.DataFrame) -> float:
        """시장 전체 공포 수준 계산"""
        fear_indicators = []
        
        # VIX 수준 (있다면)
        if 'vix' in data.columns:
            avg_vix = data['vix'].mean()
            if avg_vix > 30:
                fear_indicators.append(-0.8)
            elif avg_vix > 25:
                fear_indicators.append(-0.5)
            else:
                fear_indicators.append(0.2)
        
        # 전체 시장 심리
        if 'sentiment_score' in data.columns:
            avg_sentiment = data['sentiment_score'].mean()
            fear_indicators.append(avg_sentiment)
        
        # 뉴스 심리
        if 'news_sentiment' in data.columns:
            avg_news_sentiment = data['news_sentiment'].mean()
            fear_indicators.append(avg_news_sentiment)
        
        # 단기 모멘텀 (하락이 클수록 공포)
        if 'price_momentum_3m' in data.columns:
            avg_momentum = data['price_momentum_3m'].mean()
            if avg_momentum < -0.2:  # 20% 하락
                fear_indicators.append(-0.9)
            elif avg_momentum < -0.1:  # 10% 하락
                fear_indicators.append(-0.6)
            else:
                fear_indicators.append(0.0)
        
        return np.mean(fear_indicators) if fear_indicators else 0.0
    
    def _evaluate_contrarian_signals(self, company_data: pd.Series) -> float:
        """개별 종목의 역발상 신호 평가"""
        contrarian_score = 0.0
        
        # 부정적 감정
        sentiment = company_data.get('sentiment_score', 0.0)
        if sentiment <= -0.7:
            contrarian_score += 0.3
        elif sentiment <= -0.4:
            contrarian_score += 0.2
        
        # 애널리스트 커버리지 감소 (관심 저하)
        analyst_coverage = company_data.get('analyst_coverage', 10)
        if analyst_coverage <= 5:
            contrarian_score += 0.2
        
        # 애널리스트 하향 조정
        analyst_revisions = company_data.get('analyst_revisions', 0.0)
        if analyst_revisions < -0.3:  # 30% 하향
            contrarian_score += 0.25
        
        # 공매도 비율 높음 (비관론)
        short_interest = company_data.get('short_interest', 0.05)
        if short_interest > 0.15:  # 15% 이상
            contrarian_score += 0.25
        
        return min(1.0, contrarian_score)
    
    def _calculate_value_score(self, company_data: pd.Series, universe_data: pd.DataFrame) -> float:
        """가치 평가 점수"""
        value_score = 0.0
        
        # PE 상대 순위 (낮을수록 좋음)
        pe_ratio = company_data['pe_ratio']
        pe_rank = 1 - (universe_data['pe_ratio'] <= pe_ratio).mean()
        value_score += pe_rank * 0.5
        
        # PB 상대 순위
        pb_ratio = company_data['pb_ratio']
        pb_rank = 1 - (universe_data['pb_ratio'] <= pb_ratio).mean()
        value_score += pb_rank * 0.3
        
        # 어닝 서프라이즈 보너스
        earnings_surprise = company_data.get('earnings_surprise', 0.0)
        if earnings_surprise > 0.1:  # 10% 서프라이즈
            value_score += 0.2
        
        return min(1.0, value_score)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # 역발상 강도 기반 가중치
        weights = []
        total_strength = sum(signal.strength for signal in signals)
        
        for signal in signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 20. 존 네프의 저PER + 배당 전략
class JohnNeffLowPEDividendStrategy(BaseStrategy):
    """존 네프의 저PER + 배당 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("John_Neff_Low_PE_Dividend_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="존 네프의 저PER + 배당 전략",
            description="소외받는 업종에서 저PER + 고배당 보석 발굴",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.MEDIUM,
            expected_return="11-15%",
            volatility="14-18%",
            min_investment_period="3년 이상",
            rebalancing_frequency="반기별"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'pe_ratio', 'dividend_yield', 'earnings_growth_rate', 
            'total_return_potential', 'industry_popularity', 'peg_ratio'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # 네프의 기본 기준
        market_pe_discount = self.parameters.get('market_pe_discount', 0.6)  # 시장 PE의 60%
        min_dividend_yield = self.parameters.get('min_dividend_yield', 0.03)  # 3%
        target_total_return = self.parameters.get('target_total_return', 0.12)  # 12%
        max_peg = self.parameters.get('max_peg', 0.5)  # PEG 0.5 이하
        
        neff_data = data.dropna(subset=['pe_ratio', 'dividend_yield'])
        
        if len(neff_data) == 0:
            return []
        
        # 시장 평균 PE 계산
        market_pe = neff_data['pe_ratio'].median()
        target_pe_threshold = market_pe * market_pe_discount
        
        for symbol in neff_data.index:
            company_data = neff_data.loc[symbol]
            
            pe_ratio = company_data['pe_ratio']
            dividend_yield = company_data['dividend_yield']
            
            # 기본 조건 확인
            basic_conditions = [
                0 < pe_ratio <= target_pe_threshold,
                dividend_yield >= min_dividend_yield
            ]
            
            if not all(basic_conditions):
                continue
            
            # 네프의 총수익률 공식 평가
            total_return_score = self._calculate_neff_total_return(company_data)
            
            if total_return_score >= target_total_return:
                # 소외 업종 보너스
                neglected_bonus = self._evaluate_neglected_sector(company_data)
                
                # PEG 비율 확인
                peg_ratio = company_data.get('peg_ratio', 1.0)
                peg_bonus = 1.0 if peg_ratio <= max_peg else 0.7
                
                # 최종 강도 계산
                base_strength = min(1.0, total_return_score / target_total_return)
                final_strength = base_strength * neglected_bonus * peg_bonus
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=final_strength,
                    confidence=0.8,
                    metadata={
                        'total_return_score': total_return_score,
                        'neglected_bonus': neglected_bonus,
                        'peg_bonus': peg_bonus,
                        'pe_ratio': pe_ratio,
                        'dividend_yield': dividend_yield,
                        'peg_ratio': peg_ratio,
                        'market_pe': market_pe
                    }
                ))
        
        return self.validate_signals(signals)
    
    def _calculate_neff_total_return(self, company_data: pd.Series) -> float:
        """네프의 총수익률 계산법"""
        # 총수익률 = 배당수익률 + 예상 주가상승률
        dividend_yield = company_data['dividend_yield']
        
        # 예상 주가상승률 추정
        earnings_growth = company_data.get('earnings_growth_rate', 0.05)
        pe_ratio = company_data['pe_ratio']
        
        # 간단한 주가상승률 추정: 수익 성장률 + PE 정상화 기대
        # PE가 낮으면 PE 확장 가능성
        normal_pe = 15  # 정상 PE 가정
        pe_expansion_potential = max(0, (normal_pe - pe_ratio) / pe_ratio * 0.3)  # 30% 반영
        
        expected_price_appreciation = earnings_growth + pe_expansion_potential
        total_return = dividend_yield + expected_price_appreciation
        
        return total_return
    
    def _evaluate_neglected_sector(self, company_data: pd.Series) -> float:
        """소외받는 업종/종목 평가"""
        neglected_score = 1.0  # 기본값
        
        # 업종 인기도 (낮을수록 좋음)
        industry_popularity = company_data.get('industry_popularity', 0.5)
        if industry_popularity <= 0.3:  # 하위 30%
            neglected_score *= 1.2
        elif industry_popularity <= 0.5:  # 하위 50%
            neglected_score *= 1.1
        
        return min(1.3, neglected_score)  # 최대 30% 보너스
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # 총수익률 기대치 기반 가중치
        weights = []
        total_return_sum = sum(signal.metadata.get('total_return_score', 0.12) for signal in signals)
        
        for signal in signals:
            expected_return = signal.metadata.get('total_return_score', 0.12)
            weight = expected_return / total_return_sum
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 전략 팩토리에 등록
def register_cycle_contrarian_strategies():
    """사이클/역발상 전략들을 팩토리에 등록"""
    StrategyFactory.register_strategy("ray_dalio_all_weather", RayDalioAllWeatherStrategy)
    StrategyFactory.register_strategy("david_dreman_contrarian", DavidDremanContrarianStrategy)
    StrategyFactory.register_strategy("john_neff_low_pe_dividend", JohnNeffLowPEDividendStrategy)

# 모듈 로드 시 자동 등록
register_cycle_contrarian_strategies()



==================================================
File: C:\Aproject\quant_platform\quant_engine\fundamental_metrics.py
==================================================
"""
Fundamental Metrics Module - 재무비율 계산 함수들
PER, PBR, ROE, 부채비율 등 펀더멘털 지표들 200여 라인
"""

import pandas as pd
import numpy as np
from typing import Dict, Optional, Union, Tuple
import warnings

# 밸류에이션 지표들
def price_to_earnings_ratio(price: float, earnings_per_share: float) -> Optional[float]:
    """주가수익비율 (PER)"""
    if earnings_per_share <= 0:
        return None
    return price / earnings_per_share

def price_to_book_ratio(price: float, book_value_per_share: float) -> Optional[float]:
    """주가순자산비율 (PBR)"""
    if book_value_per_share <= 0:
        return None
    return price / book_value_per_share

def price_to_sales_ratio(market_cap: float, revenue: float) -> Optional[float]:
    """주가매출비율 (PSR)"""
    if revenue <= 0:
        return None
    return market_cap / revenue

def price_earnings_growth_ratio(pe_ratio: float, earnings_growth_rate: float) -> Optional[float]:
    """PEG 비율"""
    if earnings_growth_rate <= 0:
        return None
    return pe_ratio / (earnings_growth_rate * 100)

def enterprise_value_to_ebitda(enterprise_value: float, ebitda: float) -> Optional[float]:
    """EV/EBITDA"""
    if ebitda <= 0:
        return None
    return enterprise_value / ebitda

def enterprise_value_to_sales(enterprise_value: float, revenue: float) -> Optional[float]:
    """EV/Sales"""
    if revenue <= 0:
        return None
    return enterprise_value / revenue

# 수익성 지표들
def return_on_equity(net_income: float, shareholders_equity: float) -> Optional[float]:
    """자기자본수익률 (ROE)"""
    if shareholders_equity <= 0:
        return None
    return net_income / shareholders_equity

def return_on_assets(net_income: float, total_assets: float) -> Optional[float]:
    """총자산수익률 (ROA)"""
    if total_assets <= 0:
        return None
    return net_income / total_assets

def return_on_invested_capital(nopat: float, invested_capital: float) -> Optional[float]:
    """투하자본수익률 (ROIC)"""
    if invested_capital <= 0:
        return None
    return nopat / invested_capital

def gross_profit_margin(gross_profit: float, revenue: float) -> Optional[float]:
    """매출총이익률"""
    if revenue <= 0:
        return None
    return gross_profit / revenue

def operating_profit_margin(operating_income: float, revenue: float) -> Optional[float]:
    """영업이익률"""
    if revenue <= 0:
        return None
    return operating_income / revenue

def net_profit_margin(net_income: float, revenue: float) -> Optional[float]:
    """순이익률"""
    if revenue <= 0:
        return None
    return net_income / revenue

def ebitda_margin(ebitda: float, revenue: float) -> Optional[float]:
    """EBITDA 마진"""
    if revenue <= 0:
        return None
    return ebitda / revenue

# 안정성/레버리지 지표들
def debt_to_equity_ratio(total_debt: float, shareholders_equity: float) -> Optional[float]:
    """부채비율"""
    if shareholders_equity <= 0:
        return None
    return total_debt / shareholders_equity

def debt_to_assets_ratio(total_debt: float, total_assets: float) -> Optional[float]:
    """부채자산비율"""
    if total_assets <= 0:
        return None
    return total_debt / total_assets

def current_ratio(current_assets: float, current_liabilities: float) -> Optional[float]:
    """유동비율"""
    if current_liabilities <= 0:
        return None
    return current_assets / current_liabilities

def quick_ratio(current_assets: float, inventory: float, current_liabilities: float) -> Optional[float]:
    """당좌비율"""
    if current_liabilities <= 0:
        return None
    return (current_assets - inventory) / current_liabilities

def interest_coverage_ratio(ebit: float, interest_expense: float) -> Optional[float]:
    """이자보상비율"""
    if interest_expense <= 0:
        return None
    return ebit / interest_expense

def cash_ratio(cash_and_equivalents: float, current_liabilities: float) -> Optional[float]:
    """현금비율"""
    if current_liabilities <= 0:
        return None
    return cash_and_equivalents / current_liabilities

# 효율성 지표들
def asset_turnover(revenue: float, total_assets: float) -> Optional[float]:
    """자산회전율"""
    if total_assets <= 0:
        return None
    return revenue / total_assets

def inventory_turnover(cost_of_goods_sold: float, average_inventory: float) -> Optional[float]:
    """재고회전율"""
    if average_inventory <= 0:
        return None
    return cost_of_goods_sold / average_inventory

def receivables_turnover(revenue: float, average_receivables: float) -> Optional[float]:
    """매출채권회전율"""
    if average_receivables <= 0:
        return None
    return revenue / average_receivables

def days_sales_outstanding(average_receivables: float, revenue: float) -> Optional[float]:
    """매출채권회수기간 (DSO)"""
    if revenue <= 0:
        return None
    return (average_receivables / revenue) * 365

def days_inventory_outstanding(average_inventory: float, cost_of_goods_sold: float) -> Optional[float]:
    """재고회전기간 (DIO)"""
    if cost_of_goods_sold <= 0:
        return None
    return (average_inventory / cost_of_goods_sold) * 365

def cash_conversion_cycle(dso: float, dio: float, dpo: float) -> float:
    """현금전환주기 (CCC)"""
    return dso + dio - dpo

# 성장률 지표들
def revenue_growth_rate(current_revenue: float, previous_revenue: float) -> Optional[float]:
    """매출 성장률"""
    if previous_revenue <= 0:
        return None
    return (current_revenue - previous_revenue) / previous_revenue

def earnings_growth_rate(current_earnings: float, previous_earnings: float) -> Optional[float]:
    """순이익 성장률"""
    if previous_earnings <= 0:
        return None
    return (current_earnings - previous_earnings) / previous_earnings

def compound_annual_growth_rate(beginning_value: float, ending_value: float, periods: int) -> Optional[float]:
    """연평균성장률 (CAGR)"""
    if beginning_value <= 0 or periods <= 0:
        return None
    return (ending_value / beginning_value) ** (1/periods) - 1

def sustainable_growth_rate(roe: float, dividend_payout_ratio: float) -> float:
    """지속가능성장률"""
    retention_ratio = 1 - dividend_payout_ratio
    return roe * retention_ratio

# 배당 관련 지표들
def dividend_yield(annual_dividend: float, stock_price: float) -> Optional[float]:
    """배당수익률"""
    if stock_price <= 0:
        return None
    return annual_dividend / stock_price

def dividend_payout_ratio(dividend_per_share: float, earnings_per_share: float) -> Optional[float]:
    """배당성향"""
    if earnings_per_share <= 0:
        return None
    return dividend_per_share / earnings_per_share

def dividend_coverage_ratio(earnings_per_share: float, dividend_per_share: float) -> Optional[float]:
    """배당커버리지"""
    if dividend_per_share <= 0:
        return None
    return earnings_per_share / dividend_per_share

# 종합 평가 지표들
def piotroski_f_score(financial_data: Dict[str, float]) -> int:
    """피오트로스키 F-Score (재무건전성 점수)"""
    score = 0
    
    # 수익성 (4점)
    if financial_data.get('net_income', 0) > 0:
        score += 1
    if financial_data.get('roa', 0) > 0:
        score += 1
    if financial_data.get('operating_cash_flow', 0) > 0:
        score += 1
    if financial_data.get('operating_cash_flow', 0) > financial_data.get('net_income', 0):
        score += 1
    
    # 레버리지, 유동성, 자금 조달 (3점)
    if financial_data.get('debt_to_equity_current', 0) < financial_data.get('debt_to_equity_previous', 1):
        score += 1
    if financial_data.get('current_ratio_current', 0) > financial_data.get('current_ratio_previous', 0):
        score += 1
    if financial_data.get('shares_outstanding_current', 0) <= financial_data.get('shares_outstanding_previous', 1):
        score += 1
    
    # 운영 효율성 (2점)
    if financial_data.get('gross_margin_current', 0) > financial_data.get('gross_margin_previous', 0):
        score += 1
    if financial_data.get('asset_turnover_current', 0) > financial_data.get('asset_turnover_previous', 0):
        score += 1
    
    return score

def altman_z_score(financial_data: Dict[str, float]) -> Optional[float]:
    """알트만 Z-Score (파산 위험도)"""
    try:
        working_capital = financial_data['current_assets'] - financial_data['current_liabilities']
        total_assets = financial_data['total_assets']
        market_value_equity = financial_data['market_cap']
        total_liabilities = financial_data['total_liabilities']
        revenue = financial_data['revenue']
        retained_earnings = financial_data['retained_earnings']
        ebit = financial_data['ebit']
        
        if total_assets <= 0:
            return None
        
        z1 = 1.2 * (working_capital / total_assets)
        z2 = 1.4 * (retained_earnings / total_assets)
        z3 = 3.3 * (ebit / total_assets)
        z4 = 0.6 * (market_value_equity / total_liabilities)
        z5 = 1.0 * (revenue / total_assets)
        
        z_score = z1 + z2 + z3 + z4 + z5
        return z_score
        
    except (KeyError, ZeroDivisionError):
        return None

def m_score(financial_data: Dict[str, float]) -> Optional[float]:
    """베니시 M-Score (분식회계 탐지)"""
    try:
        # 간단화된 M-Score 계산
        score = 0.0
        
        # Days Sales Outstanding Index
        dso_current = financial_data.get('dso_current', 0)
        dso_previous = financial_data.get('dso_previous', 1)
        dsri = dso_current / dso_previous if dso_previous != 0 else 1
        
        # Gross Margin Index
        gm_current = financial_data.get('gross_margin_current', 0)
        gm_previous = financial_data.get('gross_margin_previous', 0)
        gmi = gm_previous / gm_current if gm_current != 0 else 1
        
        # Asset Quality Index
        total_assets = financial_data.get('total_assets', 1)
        ppe = financial_data.get('ppe', 0)
        current_assets = financial_data.get('current_assets', 0)
        aqi = (total_assets - current_assets - ppe) / total_assets
        
        # Sales Growth Index
        sales_current = financial_data.get('revenue_current', 1)
        sales_previous = financial_data.get('revenue_previous', 1)
        sgi = sales_current / sales_previous
        
        # Simplified M-Score
        m_score_value = -4.84 + 0.92*dsri + 0.528*gmi + 0.404*aqi + 0.892*sgi
        
        return m_score_value
        
    except (KeyError, ZeroDivisionError):
        return None

# 유틸리티 함수들
def calculate_enterprise_value(market_cap: float, total_debt: float, cash: float) -> float:
    """기업가치 (EV) 계산"""
    return market_cap + total_debt - cash

def calculate_book_value_per_share(shareholders_equity: float, shares_outstanding: float) -> Optional[float]:
    """주당순자산 (BPS)"""
    if shares_outstanding <= 0:
        return None
    return shareholders_equity / shares_outstanding

def calculate_earnings_per_share(net_income: float, shares_outstanding: float) -> Optional[float]:
    """주당순이익 (EPS)"""
    if shares_outstanding <= 0:
        return None
    return net_income / shares_outstanding

def calculate_free_cash_flow(operating_cash_flow: float, capex: float) -> float:
    """잉여현금흐름 (FCF)"""
    return operating_cash_flow - capex

def calculate_fcf_per_share(free_cash_flow: float, shares_outstanding: float) -> Optional[float]:
    """주당잉여현금흐름"""
    if shares_outstanding <= 0:
        return None
    return free_cash_flow / shares_outstanding

def working_capital(current_assets: float, current_liabilities: float) -> float:
    """운전자본"""
    return current_assets - current_liabilities

def normalize_ratio(ratio_value: Optional[float], industry_median: float) -> Optional[float]:
    """업종 대비 정규화"""
    if ratio_value is None or industry_median <= 0:
        return None
    return ratio_value / industry_median

def calculate_quality_score(financial_data: Dict[str, float]) -> float:
    """종합 품질 점수 (0-1)"""
    score = 0.0
    max_score = 0.0
    
    # ROE
    roe = financial_data.get('roe', 0)
    if roe > 0.15:
        score += 0.25
    elif roe > 0.10:
        score += 0.15
    max_score += 0.25
    
    # 부채비율
    debt_ratio = financial_data.get('debt_to_equity', 1.0)
    if debt_ratio < 0.3:
        score += 0.2
    elif debt_ratio < 0.5:
        score += 0.15
    max_score += 0.2
    
    # 유동비율
    current_ratio = financial_data.get('current_ratio', 1.0)
    if current_ratio > 2.0:
        score += 0.15
    elif current_ratio > 1.5:
        score += 0.1
    max_score += 0.15
    
    # 이익 성장률
    earnings_growth = financial_data.get('earnings_growth', 0)
    if earnings_growth > 0.1:
        score += 0.2
    elif earnings_growth > 0.05:
        score += 0.1
    max_score += 0.2
    
    # 매출 성장률
    revenue_growth = financial_data.get('revenue_growth', 0)
    if revenue_growth > 0.1:
        score += 0.2
    elif revenue_growth > 0.05:
        score += 0.1
    max_score += 0.2
    
    return score / max_score if max_score > 0 else 0.0

def calculate_financial_strength_rank(financial_data: Dict[str, float]) -> str:
    """재무 건전성 등급"""
    score = 0
    
    # 수익성
    roe = financial_data.get('roe', 0)
    if roe > 0.2:
        score += 3
    elif roe > 0.15:
        score += 2
    elif roe > 0.1:
        score += 1
    
    # 안정성
    debt_ratio = financial_data.get('debt_to_equity', 1.0)
    if debt_ratio < 0.3:
        score += 3
    elif debt_ratio < 0.5:
        score += 2
    elif debt_ratio < 0.8:
        score += 1
    
    # 유동성
    current_ratio = financial_data.get('current_ratio', 1.0)
    if current_ratio > 3.0:
        score += 3
    elif current_ratio > 2.0:
        score += 2
    elif current_ratio > 1.2:
        score += 1
    
    # 성장성
    revenue_growth = financial_data.get('revenue_growth', 0)
    if revenue_growth > 0.15:
        score += 3
    elif revenue_growth > 0.1:
        score += 2
    elif revenue_growth > 0.05:
        score += 1
    
    # 등급 매핑
    if score >= 10:
        return 'A+'
    elif score >= 8:
        return 'A'
    elif score >= 6:
        return 'B+'
    elif score >= 4:
        return 'B'
    elif score >= 2:
        return 'C'
    else:
        return 'D'



==================================================
File: C:\Aproject\quant_platform\quant_engine\growth_momentum_stratigies.py
==================================================
"""
Growth & Momentum Strategies - 성장/모멘텀 관련 고급 전략 3가지
윌리엄 오닐의 CAN SLIM, 제임스 오쇼네시 전략 포함
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple
from base_strategy import BaseStrategy, StrategyMetadata, Signal, PortfolioWeight
from base_strategy import RiskLevel, Complexity, StrategyCategory, StrategyFactory
import technical_indicators as ti
import fundamental_metrics as fm

# 15. 윌리엄 오닐의 CAN SLIM 전략
class WilliamONeilCANSLIMStrategy(BaseStrategy):
    """윌리엄 오닐의 CAN SLIM 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("William_ONeil_CANSLIM_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="윌리엄 오닐의 CAN SLIM",
            description="7가지 기준으로 고성장주 발굴, 모멘텀과 펀더멘털 결합",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.HIGH,
            complexity=Complexity.COMPLEX,
            expected_return="15-25%",
            volatility="20-30%",
            min_investment_period="6개월-2년",
            rebalancing_frequency="월별"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'eps_growth_current', 'eps_growth_annual', 'new_products', 'new_management',
            'supply_demand', 'leading_stock', 'institutional_ownership', 'market_direction',
            'price_52w_high', 'relative_strength', 'industry_rank'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # CAN SLIM 각 요소별 최소 기준
        min_current_earnings = self.parameters.get('min_current_earnings', 0.25)  # 25%
        min_annual_earnings = self.parameters.get('min_annual_earnings', 0.25)   # 25%
        min_relative_strength = self.parameters.get('min_relative_strength', 80)  # 80 이상
        min_institutional_ownership = self.parameters.get('min_institutional_ownership', 0.1)
        price_near_high_threshold = self.parameters.get('price_near_high', 0.85)  # 52주 고점의 85%
        
        canslim_data = data.dropna(subset=['eps_growth_current', 'eps_growth_annual'])
        
        for symbol in canslim_data.index:
            company_data = canslim_data.loc[symbol]
            
            # CAN SLIM 7가지 기준 평가
            canslim_scores = self._evaluate_canslim_criteria(company_data)
            
            # 각 기준별 점수
            c_score = canslim_scores['current_earnings']
            a_score = canslim_scores['annual_earnings']
            n_score = canslim_scores['new_factors']
            s_score = canslim_scores['supply_demand']
            l_score = canslim_scores['leader']
            i_score = canslim_scores['institutional']
            m_score = canslim_scores['market_direction']
            
            # 종합 CAN SLIM 점수
            total_score = (c_score + a_score + n_score + s_score + l_score + i_score + m_score) / 7
            
            # 최소 기준 충족 확인
            basic_requirements = [
                c_score >= 0.6,  # C: 현재 분기 수익 25% 이상 증가
                a_score >= 0.6,  # A: 연간 수익 증가 지속
                l_score >= 0.6,  # L: 업종 선도주
                m_score >= 0.5   # M: 시장 방향 확인
            ]
            
            if sum(basic_requirements) >= 3 and total_score >= 0.65:
                # 추가 기술적 확인
                technical_score = self._evaluate_technical_breakout(company_data)
                
                if technical_score >= 0.6:
                    final_strength = min(1.0, total_score * technical_score * 1.2)
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=final_strength,
                        confidence=0.75,
                        metadata={
                            'canslim_total_score': total_score,
                            'technical_score': technical_score,
                            'c_score': c_score,
                            'a_score': a_score,
                            'n_score': n_score,
                            's_score': s_score,
                            'l_score': l_score,
                            'i_score': i_score,
                            'm_score': m_score
                        }
                    ))
        
        return self.validate_signals(signals)
    
    def _evaluate_canslim_criteria(self, company_data: pd.Series) -> Dict[str, float]:
        """CAN SLIM 7가지 기준 평가"""
        scores = {}
        
        # C - Current Earnings (현재 분기 수익)
        current_eps_growth = company_data.get('eps_growth_current', 0)
        if current_eps_growth >= 0.5:  # 50% 이상
            scores['current_earnings'] = 1.0
        elif current_eps_growth >= 0.25:  # 25% 이상
            scores['current_earnings'] = 0.8
        elif current_eps_growth >= 0.1:   # 10% 이상
            scores['current_earnings'] = 0.6
        else:
            scores['current_earnings'] = 0.2
        
        # A - Annual Earnings (연간 수익 증가)
        annual_eps_growth = company_data.get('eps_growth_annual', 0)
        if annual_eps_growth >= 0.25:  # 25% 이상
            scores['annual_earnings'] = 1.0
        elif annual_eps_growth >= 0.15:  # 15% 이상
            scores['annual_earnings'] = 0.8
        else:
            scores['annual_earnings'] = 0.4
        
        # N - New (신제품, 신경영, 신고점)
        new_score = 0
        if company_data.get('new_products', False):
            new_score += 0.4
        if company_data.get('new_management', False):
            new_score += 0.3
        # 52주 신고점 근처
        price_vs_high = company_data.get('price_52w_high', 0)
        if price_vs_high >= 0.85:  # 52주 고점의 85% 이상
            new_score += 0.3
        scores['new_factors'] = min(1.0, new_score)
        
        # S - Supply and Demand (수급)
        supply_demand = company_data.get('supply_demand', 0.5)
        scores['supply_demand'] = supply_demand
        
        # L - Leader (업종 선도주)
        leading_stock = company_data.get('leading_stock', False)
        industry_rank = company_data.get('industry_rank', 50)
        if leading_stock and industry_rank <= 10:
            scores['leader'] = 1.0
        elif industry_rank <= 20:
            scores['leader'] = 0.8
        elif industry_rank <= 40:
            scores['leader'] = 0.6
        else:
            scores['leader'] = 0.3
        
        # I - Institutional Sponsorship (기관 후원)
        institutional_ownership = company_data.get('institutional_ownership', 0)
        if institutional_ownership >= 0.2:  # 20% 이상
            scores['institutional'] = 1.0
        elif institutional_ownership >= 0.1:  # 10% 이상
            scores['institutional'] = 0.7
        else:
            scores['institutional'] = 0.4
        
        # M - Market Direction (시장 방향)
        market_direction = company_data.get('market_direction', 0.5)
        scores['market_direction'] = market_direction
        
        return scores
    
    def _evaluate_technical_breakout(self, company_data: pd.Series) -> float:
        """기술적 돌파 패턴 평가"""
        technical_score = 0.0
        
        # 상대강도 (RS Rating)
        relative_strength = company_data.get('relative_strength', 50)
        if relative_strength >= 90:
            technical_score += 0.4
        elif relative_strength >= 80:
            technical_score += 0.3
        elif relative_strength >= 70:
            technical_score += 0.2
        
        # 52주 고점 근처
        price_vs_high = company_data.get('price_52w_high', 0)
        if price_vs_high >= 0.95:  # 95% 이상
            technical_score += 0.3
        elif price_vs_high >= 0.85:  # 85% 이상
            technical_score += 0.2
        
        # 거래량 증가 (간접 지표)
        volume_score = company_data.get('volume_increase', 0.5)
        technical_score += volume_score * 0.3
        
        return min(1.0, technical_score)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # 성장주 집중 투자 스타일
        # 상위 성과 종목에 더 높은 가중치
        signals_sorted = sorted(signals, key=lambda x: x.strength, reverse=True)
        top_signals = signals_sorted[:min(8, len(signals_sorted))]  # 최대 8개 종목 집중
        
        weights = []
        total_strength = sum(signal.strength for signal in top_signals)
        
        for i, signal in enumerate(top_signals):
            # 상위 종목일수록 높은 가중치
            position_bonus = 1.3 if i < 3 else 1.0
            adjusted_strength = signal.strength * position_bonus
            weight = adjusted_strength / (total_strength * 1.1)
            
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 16. 하워드 막스의 사이클 투자 전략 (성장/모멘텀 버전)
class HowardMarksCycleStrategy(BaseStrategy):
    """하워드 막스의 사이클 투자 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("Howard_Marks_Cycle_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="하워드 막스의 사이클 투자",
            description="경기사이클 극단점에서 역발상 기회 포착",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.COMPLEX,
            expected_return="13-18%",
            volatility="16-24%",
            min_investment_period="2년 이상",
            rebalancing_frequency="분기별"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'credit_spread', 'vix', 'yield_curve', 'sentiment_index', 
            'valuation_percentile', 'cycle_position', 'fear_greed_index'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # 시장 사이클 분석
        market_cycle_score = self._analyze_market_cycle(data)
        
        # 극단적 상황에서만 매매 (막스의 철학)
        if abs(market_cycle_score) < 0.7:  # 중립 구간에서는 거래하지 않음
            return []
        
        cycle_data = data.dropna(subset=['valuation_percentile'])
        
        for symbol in cycle_data.index:
            company_data = cycle_data.loc[symbol]
            
            # 개별 종목의 사이클 위치 분석
            stock_cycle_score = self._analyze_stock_cycle(company_data)
            
            # 시장 사이클과 개별 종목 사이클의 조합
            combined_score = (market_cycle_score + stock_cycle_score) / 2
            
            # 극단적 저평가 상황 (매수 기회)
            if combined_score <= -0.7:
                strength = abs(combined_score)
                confidence = min(0.9, abs(combined_score) + 0.1)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=confidence,
                    metadata={
                        'market_cycle_score': market_cycle_score,
                        'stock_cycle_score': stock_cycle_score,
                        'combined_score': combined_score,
                        'valuation_percentile': company_data['valuation_percentile']
                    }
                ))
            
            # 극단적 고평가 상황 (매도 신호)
            elif combined_score >= 0.7:
                strength = combined_score
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='SELL',
                    strength=strength,
                    confidence=0.8,
                    metadata={
                        'market_cycle_score': market_cycle_score,
                        'stock_cycle_score': stock_cycle_score,
                        'combined_score': combined_score
                    }
                ))
        
        return self.validate_signals(signals)
    
    def _analyze_market_cycle(self, data: pd.DataFrame) -> float:
        """전체 시장 사이클 분석"""
        cycle_indicators = []
        
        # 신용 스프레드 (위험 지표)
        avg_credit_spread = data['credit_spread'].mean()
        if avg_credit_spread > 300:  # 3% 이상
            cycle_indicators.append(-0.8)  # 매우 부정적
        elif avg_credit_spread > 200:  # 2% 이상
            cycle_indicators.append(-0.5)
        elif avg_credit_spread < 100:  # 1% 이하
            cycle_indicators.append(0.6)   # 과도한 낙관
        else:
            cycle_indicators.append(0.0)
        
        # VIX (공포 지수)
        avg_vix = data['vix'].mean()
        if avg_vix > 30:
            cycle_indicators.append(-0.7)  # 극단적 공포
        elif avg_vix > 20:
            cycle_indicators.append(-0.3)
        elif avg_vix < 15:
            cycle_indicators.append(0.5)   # 과도한 안정감
        else:
            cycle_indicators.append(0.0)
        
        # 투자 심리
        avg_sentiment = data['sentiment_index'].mean()
        if avg_sentiment < 20:
            cycle_indicators.append(-0.8)  # 극단적 비관
        elif avg_sentiment < 40:
            cycle_indicators.append(-0.4)
        elif avg_sentiment > 80:
            cycle_indicators.append(0.7)   # 극단적 낙관
        else:
            cycle_indicators.append(0.0)
        
        return np.mean(cycle_indicators)
    
    def _analyze_stock_cycle(self, company_data: pd.Series) -> float:
        """개별 종목 사이클 분석"""
        stock_score = 0.0
        
        # 밸류에이션 백분위
        val_percentile = company_data['valuation_percentile']
        if val_percentile < 10:  # 하위 10%
            stock_score -= 0.8
        elif val_percentile < 25:  # 하위 25%
            stock_score -= 0.5
        elif val_percentile > 90:  # 상위 10%
            stock_score += 0.7
        elif val_percentile > 75:  # 상위 25%
            stock_score += 0.4
        
        # 사이클 위치
        cycle_position = company_data.get('cycle_position', 0.5)
        if cycle_position < 0.2:  # 사이클 바닥
            stock_score -= 0.6
        elif cycle_position > 0.8:  # 사이클 고점
            stock_score += 0.6
        
        return np.clip(stock_score, -1.0, 1.0)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        buy_signals = [s for s in signals if s.signal_type == 'BUY']
        if not buy_signals:
            return []
        
        # 사이클 투자는 기회주의적 집중
        weights = []
        total_strength = sum(signal.strength for signal in buy_signals)
        
        for signal in buy_signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 17. 제임스 오쇼네시의 What Works on Wall Street 전략
class JamesOShaughnessyStrategy(BaseStrategy):
    """제임스 오쇼네시의 What Works on Wall Street 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("James_OShaughnessy_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="제임스 오쇼네시의 What Works",
            description="50년 데이터 검증, 시총+PBR+모멘텀 멀티팩터",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.MEDIUM,
            expected_return="14-19%",
            volatility="17-23%",
            min_investment_period="1년 이상",
            rebalancing_frequency="연 1회"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'market_cap', 'pb_ratio', 'momentum_1year', 'price_sales', 
            'shareholder_yield', 'roe', 'earnings_quality'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # 오쇼네시의 최적 조합: 대형주 + 저PBR + 모멘텀
        market_cap_threshold = self.parameters.get('market_cap_percentile', 0.5)  # 상위 50%
        pbr_threshold = self.parameters.get('pbr_percentile', 0.25)  # 하위 25%
        momentum_threshold = self.parameters.get('momentum_percentile', 0.75)  # 상위 25%
        
        oshaughnessy_data = data.dropna(subset=['market_cap', 'pb_ratio', 'momentum_1year'])
        
        # 각 팩터별 기준선 계산
        market_cap_cutoff = oshaughnessy_data['market_cap'].quantile(market_cap_threshold)
        pbr_cutoff = oshaughnessy_data['pb_ratio'].quantile(pbr_threshold)
        momentum_cutoff = oshaughnessy_data['momentum_1year'].quantile(momentum_threshold)
        
        for symbol in oshaughnessy_data.index:
            company_data = oshaughnessy_data.loc[symbol]
            
            # 3가지 핵심 조건
            large_cap = company_data['market_cap'] >= market_cap_cutoff
            low_pbr = company_data['pb_ratio'] <= pbr_cutoff
            high_momentum = company_data['momentum_1year'] >= momentum_cutoff
            
            # 모든 조건 충족 시 기본 선별
            if large_cap and low_pbr and high_momentum:
                # 추가 품질 지표 평가
                quality_score = self._evaluate_quality_factors(company_data)
                
                if quality_score >= 0.5:
                    # 각 팩터의 상대적 순위 계산
                    factor_scores = self._calculate_factor_scores(company_data, oshaughnessy_data)
                    
                    # 종합 점수
                    composite_score = (
                        factor_scores['size_score'] * 0.3 +
                        factor_scores['value_score'] * 0.4 +
                        factor_scores['momentum_score'] * 0.3
                    )
                    
                    final_strength = min(1.0, composite_score * quality_score * 1.1)
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=final_strength,
                        confidence=0.8,
                        metadata={
                            'composite_score': composite_score,
                            'quality_score': quality_score,
                            'size_score': factor_scores['size_score'],
                            'value_score': factor_scores['value_score'],
                            'momentum_score': factor_scores['momentum_score'],
                            'market_cap': company_data['market_cap'],
                            'pb_ratio': company_data['pb_ratio'],
                            'momentum_1year': company_data['momentum_1year']
                        }
                    ))
        
        return self.validate_signals(signals)
    
    def _evaluate_quality_factors(self, company_data: pd.Series) -> float:
        """품질 팩터 평가"""
        quality_score = 0.0
        
        # ROE
        roe = company_data.get('roe', 0.1)
        if roe > 0.15:
            quality_score += 0.3
        elif roe > 0.1:
            quality_score += 0.2
        
        # 주주수익률 (배당 + 자사주 매입)
        shareholder_yield = company_data.get('shareholder_yield', 0.02)
        if shareholder_yield > 0.05:
            quality_score += 0.3
        elif shareholder_yield > 0.02:
            quality_score += 0.2
        
        # 수익 품질
        earnings_quality = company_data.get('earnings_quality', 0.7)
        quality_score += earnings_quality * 0.4
        
        return min(1.0, quality_score)
    
    def _calculate_factor_scores(self, company_data: pd.Series, universe_data: pd.DataFrame) -> Dict[str, float]:
        """팩터별 상대 점수 계산"""
        scores = {}
        
        # 시가총액 점수 (클수록 높은 점수)
        market_cap = company_data['market_cap']
        market_cap_rank = (universe_data['market_cap'] <= market_cap).mean()
        scores['size_score'] = market_cap_rank
        
        # 가치 점수 (PBR 낮을수록 높은 점수)
        pb_ratio = company_data['pb_ratio']
        pbr_rank = 1 - (universe_data['pb_ratio'] <= pb_ratio).mean()
        scores['value_score'] = pbr_rank
        
        # 모멘텀 점수 (높을수록 높은 점수)
        momentum = company_data['momentum_1year']
        momentum_rank = (universe_data['momentum_1year'] <= momentum).mean()
        scores['momentum_score'] = momentum_rank
        
        return scores
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # 팩터 점수 기반 가중치
        weights = []
        total_strength = sum(signal.strength for signal in signals)
        
        for signal in signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 전략 팩토리에 등록
def register_growth_momentum_strategies():
    """성장/모멘텀 전략들을 팩토리에 등록"""
    StrategyFactory.register_strategy("william_oneil_canslim", WilliamONeilCANSLIMStrategy)
    StrategyFactory.register_strategy("howard_marks_cycle", HowardMarksCycleStrategy)
    StrategyFactory.register_strategy("james_oshaughnessy", JamesOShaughnessyStrategy)

# 모듈 로드 시 자동 등록
register_growth_momentum_strategies()


==================================================
File: C:\Aproject\quant_platform\quant_engine\portfolio_utils.py
==================================================
"""
Portfolio Utilities Module - 포트폴리오 관리 유틸리티
리밸런싱, 가중치 계산, 포트폴리오 최적화 관련 함수들 250여 라인
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Optional, Union
import scipy.optimize as sco
from scipy import linalg
import warnings

# 포트폴리오 가중치 계산
def equal_weight_portfolio(symbols: List[str]) -> Dict[str, float]:
    """동일 가중치 포트폴리오"""
    if not symbols:
        return {}
    
    weight = 1.0 / len(symbols)
    return {symbol: weight for symbol in symbols}

def market_cap_weighted_portfolio(symbols: List[str], market_caps: Dict[str, float]) -> Dict[str, float]:
    """시가총액 가중 포트폴리오"""
    total_market_cap = sum(market_caps.get(symbol, 0) for symbol in symbols)
    
    if total_market_cap == 0:
        return equal_weight_portfolio(symbols)
    
    return {symbol: market_caps.get(symbol, 0) / total_market_cap for symbol in symbols}

def inverse_volatility_weighted_portfolio(returns: pd.DataFrame) -> Dict[str, float]:
    """역변동성 가중 포트폴리오"""
    volatilities = returns.std()
    
    # 0으로 나누기 방지
    volatilities = volatilities.replace(0, volatilities.mean())
    
    inverse_vol = 1 / volatilities
    total_inverse_vol = inverse_vol.sum()
    
    return (inverse_vol / total_inverse_vol).to_dict()

def risk_parity_portfolio(returns: pd.DataFrame, method: str = 'naive') -> Dict[str, float]:
    """리스크 패리티 포트폴리오"""
    if method == 'naive':
        return inverse_volatility_weighted_portfolio(returns)
    
    # 고급 리스크 패리티 (각 자산의 리스크 기여도 동일)
    cov_matrix = returns.cov().values
    n_assets = len(returns.columns)
    
    def risk_budget_objective(weights, cov_matrix):
        portfolio_vol = np.sqrt(np.dot(weights, np.dot(cov_matrix, weights)))
        marginal_contrib = np.dot(cov_matrix, weights) / portfolio_vol
        contrib = np.multiply(marginal_contrib, weights)
        
        # 각 자산의 리스크 기여도가 동일하도록
        target_contrib = portfolio_vol / n_assets
        return np.sum(np.square(contrib - target_contrib))
    
    # 제약조건
    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
    bounds = tuple((0.01, 0.5) for _ in range(n_assets))  # 1%-50% 제한
    
    # 초기값
    x0 = np.array([1/n_assets] * n_assets)
    
    try:
        result = sco.minimize(risk_budget_objective, x0, args=(cov_matrix,),
                             method='SLSQP', bounds=bounds, constraints=constraints)
        
        if result.success:
            return dict(zip(returns.columns, result.x))
        else:
            return inverse_volatility_weighted_portfolio(returns)
    except:
        return inverse_volatility_weighted_portfolio(returns)

def minimum_variance_portfolio(returns: pd.DataFrame) -> Dict[str, float]:
    """최소분산 포트폴리오"""
    cov_matrix = returns.cov().values
    n_assets = len(returns.columns)
    
    # 목적함수: 포트폴리오 분산 최소화
    def portfolio_variance(weights, cov_matrix):
        return np.dot(weights, np.dot(cov_matrix, weights))
    
    # 제약조건
    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
    bounds = tuple((0, 1) for _ in range(n_assets))
    
    # 초기값
    x0 = np.array([1/n_assets] * n_assets)
    
    try:
        result = sco.minimize(portfolio_variance, x0, args=(cov_matrix,),
                             method='SLSQP', bounds=bounds, constraints=constraints)
        
        if result.success:
            return dict(zip(returns.columns, result.x))
        else:
            return equal_weight_portfolio(returns.columns.tolist())
    except:
        return equal_weight_portfolio(returns.columns.tolist())

def maximum_diversification_portfolio(returns: pd.DataFrame) -> Dict[str, float]:
    """최대분산효과 포트폴리오"""
    cov_matrix = returns.cov().values
    volatilities = returns.std().values
    n_assets = len(returns.columns)
    
    def diversification_ratio(weights, cov_matrix, volatilities):
        portfolio_vol = np.sqrt(np.dot(weights, np.dot(cov_matrix, weights)))
        weighted_avg_vol = np.dot(weights, volatilities)
        return -weighted_avg_vol / portfolio_vol  # 음수로 최대화를 최소화로 변환
    
    # 제약조건
    constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
    bounds = tuple((0, 1) for _ in range(n_assets))
    
    # 초기값
    x0 = np.array([1/n_assets] * n_assets)
    
    try:
        result = sco.minimize(diversification_ratio, x0, 
                             args=(cov_matrix, volatilities),
                             method='SLSQP', bounds=bounds, constraints=constraints)
        
        if result.success:
            return dict(zip(returns.columns, result.x))
        else:
            return equal_weight_portfolio(returns.columns.tolist())
    except:
        return equal_weight_portfolio(returns.columns.tolist())

# 리밸런싱 함수들
def calculate_rebalancing_trades(current_weights: Dict[str, float], 
                                target_weights: Dict[str, float],
                                portfolio_value: float,
                                threshold: float = 0.05) -> Dict[str, Dict]:
    """리밸런싱 거래 계산"""
    trades = {}
    
    # 모든 종목 리스트
    all_symbols = set(current_weights.keys()) | set(target_weights.keys())
    
    for symbol in all_symbols:
        current_weight = current_weights.get(symbol, 0.0)
        target_weight = target_weights.get(symbol, 0.0)
        weight_diff = target_weight - current_weight
        
        # 임계값 이상의 차이만 거래
        if abs(weight_diff) > threshold:
            current_value = current_weight * portfolio_value
            target_value = target_weight * portfolio_value
            trade_value = target_value - current_value
            
            trades[symbol] = {
                'current_weight': current_weight,
                'target_weight': target_weight,
                'weight_diff': weight_diff,
                'current_value': current_value,
                'target_value': target_value,
                'trade_value': trade_value,
                'trade_type': 'BUY' if trade_value > 0 else 'SELL'
            }
    
    return trades

def optimize_rebalancing_frequency(returns: pd.DataFrame, 
                                  target_weights: pd.Series,
                                  transaction_cost: float = 0.001) -> Dict:
    """최적 리밸런싱 빈도 계산"""
    frequencies = [1, 5, 21, 63, 126, 252]  # 일, 주, 월, 분기, 반기, 연
    results = {}
    
    for freq in frequencies:
        # 해당 빈도로 리밸런싱했을 때의 성과 계산
        rebalanced_returns = simulate_rebalanced_returns(
            returns, target_weights, freq, transaction_cost
        )
        
        total_return = (1 + rebalanced_returns).prod() - 1
        volatility = rebalanced_returns.std() * np.sqrt(252)
        sharpe_ratio = (rebalanced_returns.mean() * 252) / (rebalanced_returns.std() * np.sqrt(252))
        
        results[freq] = {
            'frequency_days': freq,
            'total_return': total_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'total_transactions': len(returns) // freq
        }
    
    # 샤프 비율 기준 최적 빈도 선택
    optimal_freq = max(results.keys(), key=lambda x: results[x]['sharpe_ratio'])
    
    return {
        'optimal_frequency': optimal_freq,
        'results': results
    }

def simulate_rebalanced_returns(returns: pd.DataFrame, 
                               target_weights: pd.Series,
                               rebalance_frequency: int,
                               transaction_cost: float = 0.001) -> pd.Series:
    """리밸런싱 시뮬레이션"""
    portfolio_returns = []
    current_weights = target_weights.copy()
    
    for i in range(len(returns)):
        # 일일 수익률 계산
        daily_return = (returns.iloc[i] * current_weights).sum()
        portfolio_returns.append(daily_return)
        
        # 가중치 업데이트 (수익률에 따른 자연적 변화)
        current_weights = current_weights * (1 + returns.iloc[i])
        current_weights = current_weights / current_weights.sum()
        
        # 리밸런싱 시점
        if (i + 1) % rebalance_frequency == 0:
            # 거래비용 차감
            rebalancing_cost = transaction_cost * np.sum(np.abs(current_weights - target_weights))
            portfolio_returns[-1] -= rebalancing_cost
            
            # 목표 가중치로 리밸런싱
            current_weights = target_weights.copy()
    
    return pd.Series(portfolio_returns, index=returns.index)

# 포트폴리오 성과 측정
def calculate_portfolio_metrics(returns: pd.Series, 
                               benchmark_returns: Optional[pd.Series] = None,
                               risk_free_rate: float = 0.02) -> Dict[str, float]:
    """포트폴리오 성과 지표 계산"""
    metrics = {}
    
    if len(returns) == 0:
        return metrics
    
    # 기본 지표
    metrics['total_return'] = (1 + returns).prod() - 1
    metrics['annualized_return'] = (1 + returns.mean()) ** 252 - 1
    metrics['volatility'] = returns.std() * np.sqrt(252)
    metrics['sharpe_ratio'] = (metrics['annualized_return'] - risk_free_rate) / metrics['volatility']
    
    # 하방 위험 지표
    downside_returns = returns[returns < 0]
    if len(downside_returns) > 0:
        metrics['downside_volatility'] = downside_returns.std() * np.sqrt(252)
        metrics['sortino_ratio'] = (metrics['annualized_return'] - risk_free_rate) / metrics['downside_volatility']
    else:
        metrics['downside_volatility'] = 0
        metrics['sortino_ratio'] = float('inf')
    
    # 최대 낙폭
    cumulative_returns = (1 + returns).cumprod()
    running_max = cumulative_returns.expanding().max()
    drawdown = (cumulative_returns - running_max) / running_max
    metrics['max_drawdown'] = drawdown.min()
    
    # VaR
    metrics['var_95'] = returns.quantile(0.05)
    metrics['cvar_95'] = returns[returns <= metrics['var_95']].mean()
    
    # 승률
    metrics['win_rate'] = (returns > 0).mean()
    
    # 벤치마크 대비 지표
    if benchmark_returns is not None and len(benchmark_returns) == len(returns):
        excess_returns = returns - benchmark_returns
        metrics['alpha'] = excess_returns.mean() * 252
        
        # 베타 계산
        covariance = np.cov(returns, benchmark_returns)[0, 1]
        benchmark_variance = benchmark_returns.var()
        metrics['beta'] = covariance / benchmark_variance if benchmark_variance != 0 else 0
        
        # 정보비율
        tracking_error = excess_returns.std() * np.sqrt(252)
        metrics['information_ratio'] = metrics['alpha'] / tracking_error if tracking_error != 0 else 0
    
    return metrics

def calculate_risk_attribution(returns: pd.DataFrame, weights: pd.Series) -> Dict[str, float]:
    """리스크 기여도 분석"""
    cov_matrix = returns.cov()
    portfolio_variance = np.dot(weights, np.dot(cov_matrix, weights))
    portfolio_volatility = np.sqrt(portfolio_variance)
    
    # 한계 기여도
    marginal_contrib = np.dot(cov_matrix, weights) / portfolio_volatility
    
    # 개별 기여도
    contrib = weights * marginal_contrib
    
    # 백분율로 변환
    risk_attribution = (contrib / portfolio_variance).to_dict()
    
    return risk_attribution

def calculate_performance_attribution(returns: pd.DataFrame, 
                                    weights: pd.Series,
                                    benchmark_returns: pd.Series) -> Dict[str, Dict[str, float]]:
    """성과 기여도 분석"""
    attribution = {}
    
    # 포트폴리오 수익률
    portfolio_returns = (returns * weights).sum(axis=1)
    
    for asset in returns.columns:
        asset_return = returns[asset].mean() * 252
        benchmark_return = benchmark_returns.mean() * 252
        weight = weights[asset]
        
        # 자산 선택 효과
        selection_effect = (asset_return - benchmark_return) * weight
        
        # 가중치 효과 (벤치마크 가중치가 있다면)
        # 여기서는 동일가중치를 벤치마크로 가정
        benchmark_weight = 1 / len(returns.columns)
        allocation_effect = (weight - benchmark_weight) * benchmark_return
        
        attribution[asset] = {
            'selection_effect': selection_effect,
            'allocation_effect': allocation_effect,
            'total_contribution': selection_effect + allocation_effect
        }
    
    return attribution

# 포트폴리오 최적화 유틸리티
def efficient_frontier(returns: pd.DataFrame, 
                      n_portfolios: int = 100) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """효율적 프론티어 계산"""
    n_assets = len(returns.columns)
    mean_returns = returns.mean() * 252
    cov_matrix = returns.cov() * 252
    
    # 목표 수익률 범위
    min_ret = mean_returns.min()
    max_ret = mean_returns.max()
    target_returns = np.linspace(min_ret, max_ret, n_portfolios)
    
    efficient_portfolios = []
    
    for target_return in target_returns:
        # 목적함수: 분산 최소화
        def portfolio_variance(weights):
            return np.dot(weights, np.dot(cov_matrix, weights))
        
        # 제약조건
        constraints = [
            {'type': 'eq', 'fun': lambda x: np.sum(x) - 1},  # 가중치 합 = 1
            {'type': 'eq', 'fun': lambda x: np.dot(x, mean_returns) - target_return}  # 목표 수익률
        ]
        bounds = tuple((0, 1) for _ in range(n_assets))
        
        # 최적화
        result = sco.minimize(portfolio_variance, 
                             np.array([1/n_assets] * n_assets),
                             method='SLSQP', 
                             bounds=bounds, 
                             constraints=constraints)
        
        if result.success:
            efficient_portfolios.append(result.x)
        else:
            efficient_portfolios.append(np.array([1/n_assets] * n_assets))
    
    efficient_portfolios = np.array(efficient_portfolios)
    
    # 효율적 프론티어의 수익률과 위험
    frontier_returns = np.array([np.dot(weights, mean_returns) 
                                for weights in efficient_portfolios])
    frontier_volatility = np.array([np.sqrt(np.dot(weights, np.dot(cov_matrix, weights))) 
                                   for weights in efficient_portfolios])
    
    return efficient_portfolios, frontier_returns, frontier_volatility

def black_litterman_optimization(returns: pd.DataFrame,
                                 market_caps: pd.Series,
                                 views: Dict[str, float] = None,
                                 view_confidence: float = 0.25) -> Dict[str, float]:
    """블랙-리터만 모델"""
    # 시장 균형 수익률 (CAPM 기반)
    market_weights = market_caps / market_caps.sum()
    cov_matrix = returns.cov() * 252
    risk_aversion = 3.0  # 일반적인 위험회피계수
    
    # 암시 수익률
    implied_returns = risk_aversion * np.dot(cov_matrix, market_weights)
    
    if views is None:
        # 뷰가 없으면 시장 포트폴리오 반환
        return market_weights.to_dict()
    
    # 뷰 행렬 구성
    P = np.zeros((len(views), len(returns.columns)))
    Q = np.zeros(len(views))
    
    for i, (asset, view_return) in enumerate(views.items()):
        if asset in returns.columns:
            asset_idx = returns.columns.get_loc(asset)
            P[i, asset_idx] = 1
            Q[i] = view_return
    
    # 뷰의 불확실성 행렬
    omega = view_confidence * np.dot(P, np.dot(cov_matrix, P.T))
    
    # 사전 불확실성
    tau = 1 / len(returns)
    
    try:
        # 블랙-리터만 수익률
        M1 = linalg.inv(tau * cov_matrix)
        M2 = np.dot(P.T, np.dot(linalg.inv(omega), P))
        M3 = np.dot(linalg.inv(tau * cov_matrix), implied_returns)
        M4 = np.dot(P.T, np.dot(linalg.inv(omega), Q))
        
        mu_bl = np.dot(linalg.inv(M1 + M2), M3 + M4)
        cov_bl = linalg.inv(M1 + M2)
        
        # 최적 가중치
        optimal_weights = np.dot(linalg.inv(risk_aversion * cov_bl), mu_bl)
        
        # 정규화
        optimal_weights = optimal_weights / optimal_weights.sum()
        
        return dict(zip(returns.columns, optimal_weights))
    
    except:
        # 계산 실패시 시장 포트폴리오 반환
        return market_weights.to_dict()

def kelly_criterion_weights(expected_returns: pd.Series, 
                           covariance_matrix: pd.DataFrame,
                           max_leverage: float = 1.0) -> Dict[str, float]:
    """켈리 기준 포지션 사이징"""
    try:
        # 켈리 공식: f = (μ - r) / σ²
        # 다자산의 경우: f = Σ^(-1) * (μ - r)
        risk_free_rate = 0.02 / 252  # 일일 무위험수익률
        excess_returns = expected_returns - risk_free_rate
        
        # 공분산 행렬의 역행렬
        inv_cov = linalg.inv(covariance_matrix.values)
        
        # 켈리 가중치
        kelly_weights = np.dot(inv_cov, excess_returns.values)
        
        # 레버리지 제한
        total_leverage = np.abs(kelly_weights).sum()
        if total_leverage > max_leverage:
            kelly_weights = kelly_weights * (max_leverage / total_leverage)
        
        # 음수 가중치를 0으로 설정 (롱온리)
        kelly_weights = np.maximum(kelly_weights, 0)
        
        # 정규화
        if kelly_weights.sum() > 0:
            kelly_weights = kelly_weights / kelly_weights.sum()
        else:
            kelly_weights = np.ones(len(expected_returns)) / len(expected_returns)
        
        return dict(zip(expected_returns.index, kelly_weights))
    
    except:
        # 계산 실패시 동일가중치 반환
        return equal_weight_portfolio(expected_returns.index.tolist()) 



==================================================
File: C:\Aproject\quant_platform\quant_engine\strategy_factory.py
==================================================
"""
Strategy Factory Module - 전략 객체 생성 팩토리 패턴
전략 이름으로 해당 클래스 반환, 전략 관리 및 유틸리티 함수들
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Type, Any, Callable
import logging
import importlib
from base_strategy import BaseStrategy, StrategyCategory
from collections import defaultdict

class StrategyRegistry:
    """전략 레지스트리 - 모든 전략을 중앙 관리"""
    
    def __init__(self):
        self._strategies: Dict[str, Type[BaseStrategy]] = {}
        self._strategy_metadata: Dict[str, Dict] = {}
        self._categories: Dict[StrategyCategory, List[str]] = defaultdict(list)
        self.logger = logging.getLogger("StrategyRegistry")
    
    def register(self, strategy_name: str, strategy_class: Type[BaseStrategy]):
        """전략 등록"""
        if not issubclass(strategy_class, BaseStrategy):
            raise ValueError(f"Strategy class must inherit from BaseStrategy")
        
        self._strategies[strategy_name] = strategy_class
        
        # 메타데이터 저장 (인스턴스 생성 없이)
        try:
            temp_instance = strategy_class()
            metadata = temp_instance.get_strategy_info()
            self._strategy_metadata[strategy_name] = metadata
            
            # 카테고리별 분류
            category = metadata['metadata'].category
            if strategy_name not in self._categories[category]:
                self._categories[category].append(strategy_name)
            
        except Exception as e:
            self.logger.warning(f"Could not get metadata for {strategy_name}: {e}")
    
    def get_strategy_class(self, strategy_name: str) -> Type[BaseStrategy]:
        """전략 클래스 반환"""
        if strategy_name not in self._strategies:
            raise ValueError(f"Strategy '{strategy_name}' not found. Available strategies: {list(self._strategies.keys())}")
        
        return self._strategies[strategy_name]
    
    def create_strategy(self, strategy_name: str, **kwargs) -> BaseStrategy:
        """전략 인스턴스 생성"""
        strategy_class = self.get_strategy_class(strategy_name)
        return strategy_class(**kwargs)
    
    def list_strategies(self) -> List[str]:
        """등록된 전략 목록"""
        return list(self._strategies.keys())
    
    def list_strategies_by_category(self, category: StrategyCategory) -> List[str]:
        """카테고리별 전략 목록"""
        return self._categories.get(category, [])
    
    def get_strategy_metadata(self, strategy_name: str) -> Dict:
        """전략 메타데이터 반환"""
        if strategy_name not in self._strategy_metadata:
            # 메타데이터가 없으면 실시간 생성
            try:
                strategy = self.create_strategy(strategy_name)
                return strategy.get_strategy_info()
            except Exception as e:
                return {"error": str(e)}
        
        return self._strategy_metadata[strategy_name]
    
    def search_strategies(self, 
                         risk_level: Optional[str] = None,
                         complexity: Optional[str] = None,
                         category: Optional[StrategyCategory] = None,
                         min_expected_return: Optional[float] = None) -> List[str]:
        """조건별 전략 검색"""
        matching_strategies = []
        
        for strategy_name, metadata in self._strategy_metadata.items():
            strategy_meta = metadata.get('metadata')
            if not strategy_meta:
                continue
            
            # 조건 확인
            if risk_level and strategy_meta.risk_level.value != risk_level:
                continue
            
            if complexity and strategy_meta.complexity.value != complexity:
                continue
            
            if category and strategy_meta.category != category:
                continue
            
            # 예상 수익률 파싱 및 비교 (간단한 구현)
            if min_expected_return:
                expected_return_str = strategy_meta.expected_return
                try:
                    # "10-12%" 형태에서 하한값 추출
                    return_value = float(expected_return_str.split('-')[0].rstrip('%'))
                    if return_value < min_expected_return:
                        continue
                except:
                    continue
            
            matching_strategies.append(strategy_name)
        
        return matching_strategies

# 글로벌 레지스트리 인스턴스
strategy_registry = StrategyRegistry()

class StrategyFactory:
    """전략 팩토리 - 백워드 호환성을 위한 래퍼"""
    
    @staticmethod
    def register_strategy(strategy_name: str, strategy_class: Type[BaseStrategy]):
        """전략 등록"""
        strategy_registry.register(strategy_name, strategy_class)
    
    @staticmethod
    def create_strategy(strategy_name: str, **kwargs) -> BaseStrategy:
        """전략 생성"""
        return strategy_registry.create_strategy(strategy_name, **kwargs)
    
    @staticmethod
    def list_strategies() -> List[str]:
        """전략 목록"""
        return strategy_registry.list_strategies()

class StrategyManager:
    """전략 매니저 - 복수 전략 관리 및 포트폴리오 운영"""
    
    def __init__(self):
        self.strategies: Dict[str, BaseStrategy] = {}
        self.strategy_weights: Dict[str, float] = {}
        self.logger = logging.getLogger("StrategyManager")
    
    def add_strategy(self, name: str, strategy: BaseStrategy, weight: float = 1.0):
        """전략 추가"""
        if not isinstance(strategy, BaseStrategy):
            raise ValueError("Strategy must be an instance of BaseStrategy")
        
        self.strategies[name] = strategy
        self.strategy_weights[name] = weight
        
        # 가중치 정규화
        self._normalize_weights()
    
    def remove_strategy(self, name: str):
        """전략 제거"""
        if name in self.strategies:
            del self.strategies[name]
            del self.strategy_weights[name]
            self._normalize_weights()
    
    def _normalize_weights(self):
        """가중치 정규화"""
        total_weight = sum(self.strategy_weights.values())
        if total_weight > 0:
            for name in self.strategy_weights:
                self.strategy_weights[name] /= total_weight
    
    def generate_combined_signals(self, data: pd.DataFrame) -> List:
        """복수 전략의 신호 결합"""
        all_signals = []
        
        for name, strategy in self.strategies.items():
            try:
                signals = strategy.generate_signals(data)
                weight = self.strategy_weights[name]
                
                # 신호에 전략 가중치 적용
                for signal in signals:
                    signal.strength *= weight
                    signal.metadata = signal.metadata or {}
                    signal.metadata['strategy_name'] = name
                    signal.metadata['strategy_weight'] = weight
                
                all_signals.extend(signals)
                
            except Exception as e:
                self.logger.error(f"Error generating signals for strategy {name}: {e}")
        
        return all_signals
    
    def calculate_ensemble_weights(self, signals: List, 
                                  current_portfolio: Optional[Dict[str, float]] = None) -> List:
        """앙상블 가중치 계산"""
        # 종목별로 신호 그룹화
        symbol_signals = defaultdict(list)
        for signal in signals:
            symbol_signals[signal.symbol].append(signal)
        
        ensemble_weights = []
        
        for symbol, symbol_signal_list in symbol_signals.items():
            # 동일 종목에 대한 여러 전략 신호 결합
            combined_strength = sum(s.strength for s in symbol_signal_list)
            combined_confidence = np.mean([s.confidence for s in symbol_signal_list])
            
            # 가장 강한 신호의 타입 사용
            signal_type = max(symbol_signal_list, key=lambda x: x.strength).signal_type
            
            if combined_strength > 0:
                from base_strategy import PortfolioWeight
                current_weight = current_portfolio.get(symbol, 0.0) if current_portfolio else 0.0
                
                ensemble_weights.append(PortfolioWeight(
                    symbol=symbol,
                    weight=combined_strength,  # 임시값, 나중에 정규화
                    target_weight=combined_strength,
                    current_weight=current_weight
                ))
        
        # 가중치 정규화
        total_weight = sum(w.weight for w in ensemble_weights)
        if total_weight > 0:
            for weight in ensemble_weights:
                weight.weight /= total_weight
                weight.target_weight /= total_weight
        
        return ensemble_weights
    
    def get_strategy_performance(self, returns: pd.DataFrame) -> Dict[str, Dict]:
        """각 전략별 성과 평가"""
        performance = {}
        
        for name, strategy in self.strategies.items():
            try:
                signals = strategy.generate_signals(returns)
                weights = strategy.calculate_weights(signals)
                
                if weights:
                    # 간단한 백테스트
                    strategy_returns = self._calculate_strategy_returns(returns, weights)
                    
                    from portfolio_utils import calculate_portfolio_metrics
                    metrics = calculate_portfolio_metrics(strategy_returns)
                    
                    performance[name] = {
                        'metrics': metrics,
                        'weight': self.strategy_weights[name],
                        'signal_count': len(signals),
                        'position_count': len(weights)
                    }
                    
            except Exception as e:
                self.logger.error(f"Error evaluating strategy {name}: {e}")
                performance[name] = {'error': str(e)}
        
        return performance
    
    def _calculate_strategy_returns(self, returns: pd.DataFrame, weights: List) -> pd.Series:
        """전략별 수익률 계산 (간단 버전)"""
        if not weights:
            return pd.Series(dtype=float)
        
        # 가중치를 시리즈로 변환
        weight_dict = {w.symbol: w.weight for w in weights if w.symbol in returns.columns}
        weight_series = pd.Series(weight_dict)
        
        # 포트폴리오 수익률
        strategy_returns = (returns[weight_series.index] * weight_series).sum(axis=1)
        
        return strategy_returns

class StrategyLoader:
    """전략 동적 로딩"""
    
    @staticmethod
    def load_strategies_from_modules():
        """모든 전략 모듈에서 전략들을 자동 로드"""
        strategy_modules = [
            'basic_strategies',
            'value_strategies', 
            'growth_momentum_strategies',
            'cycle_contrarian_strategies'
        ]
        
        for module_name in strategy_modules:
            try:
                module = importlib.import_module(module_name)
                # 각 모듈의 register 함수 호출 (있다면)
                if hasattr(module, f'register_{module_name}'):
                    register_func = getattr(module, f'register_{module_name}')
                    register_func()
                    logging.info(f"Loaded strategies from {module_name}")
            except ImportError as e:
                logging.warning(f"Could not load strategy module {module_name}: {e}")
    
    @staticmethod
    def get_all_available_strategies() -> Dict[str, Dict]:
        """사용 가능한 모든 전략 정보"""
        strategies_info = {}
        
        for strategy_name in strategy_registry.list_strategies():
            metadata = strategy_registry.get_strategy_metadata(strategy_name)
            strategies_info[strategy_name] = metadata
        
        return strategies_info

def create_strategy_combination(strategy_configs: List[Dict[str, Any]]) -> StrategyManager:
    """전략 조합 생성 헬퍼 함수"""
    manager = StrategyManager()
    
    for config in strategy_configs:
        strategy_name = config['strategy']
        weight = config.get('weight', 1.0)
        params = config.get('parameters', {})
        
        try:
            strategy = strategy_registry.create_strategy(strategy_name, **params)
            manager.add_strategy(f"{strategy_name}_{len(manager.strategies)}", strategy, weight)
        except Exception as e:
            logging.error(f"Failed to create strategy {strategy_name}: {e}")
    
    return manager

def get_recommended_strategies(user_profile: Dict[str, Any]) -> List[str]:
    """사용자 프로필 기반 추천 전략"""
    risk_tolerance = user_profile.get('risk_tolerance', 'medium')  # low, medium, high
    experience_level = user_profile.get('experience_level', 'beginner')  # beginner, intermediate, advanced
    investment_horizon = user_profile.get('investment_horizon', 'medium')  # short, medium, long
    
    recommended = []
    
    # 초보자용 전략
    if experience_level == 'beginner':
        recommended.extend([
            'low_pe', 'dividend_aristocrats', 'regular_rebalancing',
            'benjamin_graham_defensive'
        ])
    
    # 중급자용 전략  
    elif experience_level == 'intermediate':
        recommended.extend([
            'rsi_mean_reversion', 'moving_average_cross', 'quality_factor',
            'joel_greenblatt_magic', 'john_neff_low_pe_dividend'
        ])
    
    # 고급자용 전략
    else:
        recommended.extend([
            'william_oneil_canslim', 'howard_marks_cycle', 'james_oshaughnessy',
            'buffett_moat', 'peter_lynch_peg'
        ])
    
    # 위험 선호도에 따른 필터링
    if risk_tolerance == 'low':
        safe_strategies = strategy_registry.search_strategies(risk_level='low')
        recommended = [s for s in recommended if s in safe_strategies]
    elif risk_tolerance == 'high':
        aggressive_strategies = strategy_registry.search_strategies(risk_level='high')
        recommended.extend(aggressive_strategies)
    
    # 중복 제거 및 존재하는 전략만 반환
    available_strategies = strategy_registry.list_strategies()
    recommended = list(set(recommended))
    recommended = [s for s in recommended if s in available_strategies]
    
    return recommended[:5]  # 최대 5개 전략 추천

# 모듈 로드시 자동 실행
def initialize_strategy_system():
    """전략 시스템 초기화"""
    StrategyLoader.load_strategies_from_modules()
    logging.info(f"Strategy system initialized with {len(strategy_registry.list_strategies())} strategies")

# 백워드 호환성을 위한 별칭
register_strategy = StrategyFactory.register_strategy
create_strategy = StrategyFactory.create_strategy
list_strategies = StrategyFactory.list_strategies 



==================================================
File: C:\Aproject\quant_platform\quant_engine\technical_indicators.py
==================================================
"""
Technical Indicators Module - 기술적 지표 계산 함수들
RSI, MACD, 볼린저밴드, 이동평균 등 200여 라인
"""

import pandas as pd
import numpy as np
from typing import Tuple, Optional, Union
import warnings

# 이동평균 관련 함수들
def simple_moving_average(prices: pd.Series, window: int) -> pd.Series:
    """단순 이동평균 (SMA)"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    return prices.rolling(window=window).mean()

def exponential_moving_average(prices: pd.Series, window: int) -> pd.Series:
    """지수 이동평균 (EMA)"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    return prices.ewm(span=window).mean()

def weighted_moving_average(prices: pd.Series, window: int) -> pd.Series:
    """가중 이동평균 (WMA)"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    
    weights = np.arange(1, window + 1)
    wma_values = []
    
    for i in range(window - 1, len(prices)):
        period_prices = prices.iloc[i - window + 1:i + 1]
        wma_value = np.dot(period_prices, weights) / weights.sum()
        wma_values.append(wma_value)
    
    # 인덱스 맞추기
    wma_series = pd.Series(index=prices.index[window-1:], data=wma_values)
    return wma_series

def volume_weighted_average_price(prices: pd.Series, volumes: pd.Series, window: int) -> pd.Series:
    """거래량 가중 평균가격 (VWAP)"""
    if len(prices) != len(volumes) or len(prices) < window:
        return pd.Series(dtype=float)
    
    typical_price = prices
    pv = typical_price * volumes
    
    vwap = pv.rolling(window=window).sum() / volumes.rolling(window=window).sum()
    return vwap

# RSI 관련 함수들
def rsi(prices: pd.Series, window: int = 14) -> pd.Series:
    """상대강도지수 (RSI)"""
    if len(prices) < window + 1:
        return pd.Series(dtype=float)
    
    delta = prices.diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)
    
    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()
    
    rs = avg_gain / avg_loss
    rsi_values = 100 - (100 / (1 + rs))
    
    return rsi_values

def stochastic_rsi(prices: pd.Series, window: int = 14, k_period: int = 3, d_period: int = 3) -> Tuple[pd.Series, pd.Series]:
    """스토캐스틱 RSI"""
    rsi_values = rsi(prices, window)
    
    if len(rsi_values) < window:
        return pd.Series(dtype=float), pd.Series(dtype=float)
    
    rsi_low = rsi_values.rolling(window=window).min()
    rsi_high = rsi_values.rolling(window=window).max()
    
    stoch_rsi = (rsi_values - rsi_low) / (rsi_high - rsi_low) * 100
    k_percent = stoch_rsi.rolling(window=k_period).mean()
    d_percent = k_percent.rolling(window=d_period).mean()
    
    return k_percent, d_percent

# MACD 관련 함수들
def macd(prices: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """MACD (Moving Average Convergence Divergence)"""
    if len(prices) < slow:
        return pd.Series(dtype=float), pd.Series(dtype=float), pd.Series(dtype=float)
    
    ema_fast = exponential_moving_average(prices, fast)
    ema_slow = exponential_moving_average(prices, slow)
    
    macd_line = ema_fast - ema_slow
    signal_line = exponential_moving_average(macd_line, signal)
    histogram = macd_line - signal_line
    
    return macd_line, signal_line, histogram

def ppo(prices: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> Tuple[pd.Series, pd.Series]:
    """Percentage Price Oscillator"""
    if len(prices) < slow:
        return pd.Series(dtype=float), pd.Series(dtype=float)
    
    ema_fast = exponential_moving_average(prices, fast)
    ema_slow = exponential_moving_average(prices, slow)
    
    ppo_line = ((ema_fast - ema_slow) / ema_slow) * 100
    signal_line = exponential_moving_average(ppo_line, signal)
    
    return ppo_line, signal_line

# 볼린저 밴드
def bollinger_bands(prices: pd.Series, window: int = 20, num_std: float = 2) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """볼린저 밴드"""
    if len(prices) < window:
        return pd.Series(dtype=float), pd.Series(dtype=float), pd.Series(dtype=float)
    
    sma = simple_moving_average(prices, window)
    std = prices.rolling(window=window).std()
    
    upper_band = sma + (std * num_std)
    lower_band = sma - (std * num_std)
    
    return upper_band, sma, lower_band

def bollinger_bands_percent_b(prices: pd.Series, window: int = 20, num_std: float = 2) -> pd.Series:
    """볼린저 밴드 %B"""
    upper, middle, lower = bollinger_bands(prices, window, num_std)
    
    if len(upper) == 0:
        return pd.Series(dtype=float)
    
    percent_b = (prices - lower) / (upper - lower)
    return percent_b

def bollinger_bands_width(prices: pd.Series, window: int = 20, num_std: float = 2) -> pd.Series:
    """볼린저 밴드 폭"""
    upper, middle, lower = bollinger_bands(prices, window, num_std)
    
    if len(upper) == 0:
        return pd.Series(dtype=float)
    
    band_width = (upper - lower) / middle
    return band_width

# 스토캐스틱
def stochastic(high: pd.Series, low: pd.Series, close: pd.Series, 
               k_period: int = 14, k_smooth: int = 3, d_period: int = 3) -> Tuple[pd.Series, pd.Series]:
    """스토캐스틱 오실레이터"""
    if len(high) < k_period:
        return pd.Series(dtype=float), pd.Series(dtype=float)
    
    lowest_low = low.rolling(window=k_period).min()
    highest_high = high.rolling(window=k_period).max()
    
    k_percent_raw = (close - lowest_low) / (highest_high - lowest_low) * 100
    k_percent = k_percent_raw.rolling(window=k_smooth).mean()
    d_percent = k_percent.rolling(window=d_period).mean()
    
    return k_percent, d_percent

# 윌리엄스 %R
def williams_r(high: pd.Series, low: pd.Series, close: pd.Series, window: int = 14) -> pd.Series:
    """윌리엄스 %R"""
    if len(high) < window:
        return pd.Series(dtype=float)
    
    highest_high = high.rolling(window=window).max()
    lowest_low = low.rolling(window=window).min()
    
    williams_r_values = (highest_high - close) / (highest_high - lowest_low) * -100
    return williams_r_values

# CCI (Commodity Channel Index)
def cci(high: pd.Series, low: pd.Series, close: pd.Series, window: int = 20) -> pd.Series:
    """Commodity Channel Index"""
    if len(high) < window:
        return pd.Series(dtype=float)
    
    typical_price = (high + low + close) / 3
    sma_tp = typical_price.rolling(window=window).mean()
    
    # Mean Absolute Deviation 계산
    mad = typical_price.rolling(window=window).apply(lambda x: np.mean(np.abs(x - x.mean())))
    
    cci_values = (typical_price - sma_tp) / (0.015 * mad)
    return cci_values

# ATR (Average True Range)
def average_true_range(high: pd.Series, low: pd.Series, close: pd.Series, window: int = 14) -> pd.Series:
    """평균 실제 범위 (ATR)"""
    if len(high) < 2:
        return pd.Series(dtype=float)
    
    # True Range 계산
    tr1 = high - low
    tr2 = np.abs(high - close.shift(1))
    tr3 = np.abs(low - close.shift(1))
    
    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    atr = true_range.rolling(window=window).mean()
    
    return atr

# ADX (Average Directional Index)
def adx(high: pd.Series, low: pd.Series, close: pd.Series, window: int = 14) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """Average Directional Index"""
    if len(high) < window + 1:
        return pd.Series(dtype=float), pd.Series(dtype=float), pd.Series(dtype=float)
    
    # Calculate True Range and Directional Movement
    tr = average_true_range(high, low, close, 1)
    
    high_diff = high.diff()
    low_diff = low.diff()
    
    plus_dm = np.where((high_diff > low_diff) & (high_diff > 0), high_diff, 0)
    minus_dm = np.where((low_diff > high_diff) & (low_diff > 0), low_diff, 0)
    
    plus_dm = pd.Series(plus_dm, index=high.index)
    minus_dm = pd.Series(minus_dm, index=low.index)
    
    # Smooth the values
    plus_di = 100 * (plus_dm.rolling(window=window).mean() / tr.rolling(window=window).mean())
    minus_di = 100 * (minus_dm.rolling(window=window).mean() / tr.rolling(window=window).mean())
    
    # Calculate ADX
    dx = 100 * np.abs(plus_di - minus_di) / (plus_di + minus_di)
    adx_values = dx.rolling(window=window).mean()
    
    return adx_values, plus_di, minus_di

# 거래량 지표들
def on_balance_volume(close: pd.Series, volume: pd.Series) -> pd.Series:
    """On-Balance Volume"""
    if len(close) != len(volume) or len(close) < 2:
        return pd.Series(dtype=float)
    
    price_change = close.diff()
    obv = np.where(price_change > 0, volume, 
                   np.where(price_change < 0, -volume, 0)).cumsum()
    
    return pd.Series(obv, index=close.index)

def accumulation_distribution_line(high: pd.Series, low: pd.Series, close: pd.Series, volume: pd.Series) -> pd.Series:
    """Accumulation/Distribution Line"""
    if len(high) != len(volume):
        return pd.Series(dtype=float)
    
    clv = ((close - low) - (high - close)) / (high - low)
    clv = clv.fillna(0)  # high == low인 경우 처리
    
    money_flow_volume = clv * volume
    ad_line = money_flow_volume.cumsum()
    
    return ad_line

def money_flow_index(high: pd.Series, low: pd.Series, close: pd.Series, volume: pd.Series, window: int = 14) -> pd.Series:
    """Money Flow Index"""
    if len(high) != len(volume) or len(high) < window + 1:
        return pd.Series(dtype=float)
    
    typical_price = (high + low + close) / 3
    money_flow = typical_price * volume
    
    price_change = typical_price.diff()
    
    positive_flow = np.where(price_change > 0, money_flow, 0)
    negative_flow = np.where(price_change < 0, money_flow, 0)
    
    positive_flow_sum = pd.Series(positive_flow, index=high.index).rolling(window=window).sum()
    negative_flow_sum = pd.Series(negative_flow, index=high.index).rolling(window=window).sum()
    
    money_ratio = positive_flow_sum / negative_flow_sum
    mfi = 100 - (100 / (1 + money_ratio))
    
    return mfi

# 모멘텀 지표들
def momentum(prices: pd.Series, window: int = 10) -> pd.Series:
    """모멘텀 지표"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    
    return prices - prices.shift(window)

def rate_of_change(prices: pd.Series, window: int = 10) -> pd.Series:
    """변화율 (ROC)"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    
    return ((prices - prices.shift(window)) / prices.shift(window)) * 100

def relative_strength(prices: pd.Series, benchmark: pd.Series, window: int = 252) -> pd.Series:
    """상대강도 (vs 벤치마크)"""
    if len(prices) != len(benchmark) or len(prices) < window:
        return pd.Series(dtype=float)
    
    stock_return = prices.pct_change(window)
    benchmark_return = benchmark.pct_change(window)
    
    relative_strength_values = (1 + stock_return) / (1 + benchmark_return) - 1
    return relative_strength_values * 100

# 변동성 지표들
def standard_deviation(prices: pd.Series, window: int = 20) -> pd.Series:
    """표준편차"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    
    return prices.rolling(window=window).std()

def historical_volatility(prices: pd.Series, window: int = 30) -> pd.Series:
    """역사적 변동성 (연율화)"""
    if len(prices) < window:
        return pd.Series(dtype=float)
    
    returns = prices.pct_change()
    volatility = returns.rolling(window=window).std() * np.sqrt(252)
    return volatility * 100

# 추세 지표들
def parabolic_sar(high: pd.Series, low: pd.Series, af_start: float = 0.02, af_increment: float = 0.02, af_max: float = 0.2) -> pd.Series:
    """Parabolic SAR"""
    if len(high) < 2:
        return pd.Series(dtype=float)
    
    sar = np.zeros(len(high))
    trend = np.zeros(len(high))  # 1 for uptrend, -1 for downtrend
    af = np.zeros(len(high))
    ep = np.zeros(len(high))  # Extreme Point
    
    # 초기값 설정
    sar[0] = low.iloc[0]
    trend[0] = 1
    af[0] = af_start
    ep[0] = high.iloc[0]
    
    for i in range(1, len(high)):
        if trend[i-1] == 1:  # Uptrend
            sar[i] = sar[i-1] + af[i-1] * (ep[i-1] - sar[i-1])
            
            if low.iloc[i] <= sar[i]:  # Trend reversal
                trend[i] = -1
                sar[i] = ep[i-1]
                af[i] = af_start
                ep[i] = low.iloc[i]
            else:
                trend[i] = 1
                if high.iloc[i] > ep[i-1]:
                    ep[i] = high.iloc[i]
                    af[i] = min(af_max, af[i-1] + af_increment)
                else:
                    ep[i] = ep[i-1]
                    af[i] = af[i-1]
        else:  # Downtrend
            sar[i] = sar[i-1] + af[i-1] * (ep[i-1] - sar[i-1])
            
            if high.iloc[i] >= sar[i]:  # Trend reversal
                trend[i] = 1
                sar[i] = ep[i-1]
                af[i] = af_start
                ep[i] = high.iloc[i]
            else:
                trend[i] = -1
                if low.iloc[i] < ep[i-1]:
                    ep[i] = low.iloc[i]
                    af[i] = min(af_max, af[i-1] + af_increment)
                else:
                    ep[i] = ep[i-1]
                    af[i] = af[i-1]
    
    return pd.Series(sar, index=high.index)

# 유틸리티 함수들
def crossover(series1: pd.Series, series2: pd.Series) -> pd.Series:
    """상향 교차 확인"""
    return (series1 > series2) & (series1.shift(1) <= series2.shift(1))

def crossunder(series1: pd.Series, series2: pd.Series) -> pd.Series:
    """하향 교차 확인"""
    return (series1 < series2) & (series1.shift(1) >= series2.shift(1))

def highest(series: pd.Series, window: int) -> pd.Series:
    """지정 기간 내 최고값"""
    return series.rolling(window=window).max()

def lowest(series: pd.Series, window: int) -> pd.Series:
    """지정 기간 내 최저값"""
    return series.rolling(window=window).min()

def normalize_indicator(indicator: pd.Series, window: int = 252) -> pd.Series:
    """지표 정규화 (0-1 범위)"""
    if len(indicator) < window:
        return pd.Series(dtype=float)
    
    rolling_min = indicator.rolling(window=window).min()
    rolling_max = indicator.rolling(window=window).max()
    
    normalized = (indicator - rolling_min) / (rolling_max - rolling_min)
    return normalized




==================================================
File: C:\Aproject\quant_platform\quant_engine\value_strategies.py
==================================================
"""
Value Investment Strategies - 가치투자 관련 고급 전략 4가지
워렌 버핏, 벤저민 그레이엄, 존 네프, 조엘 그린블라트의 전략들
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional
from base_strategy import BaseStrategy, StrategyMetadata, Signal, PortfolioWeight
from base_strategy import RiskLevel, Complexity, StrategyCategory, StrategyFactory
import fundamental_metrics as fm

# 11. 워렌 버핏의 해자 전략
class BuffettMoatStrategy(BaseStrategy):
    """워렌 버핏의 경제적 해자 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("Buffett_Moat_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="워렌 버핏의 해자 전략",
            description="경쟁우위가 있는 기업을 합리적 가격에 장기 보유",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.MEDIUM,
            expected_return="12-16%",
            volatility="10-15%",
            min_investment_period="10년 이상",
            rebalancing_frequency="연 1회"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'pe_ratio', 'roe', 'roic', 'debt_to_equity', 'profit_margin', 
            'revenue_growth_5y', 'earnings_growth_5y', 'brand_strength', 
            'market_share', 'switching_cost'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # 버핏 기준 파라미터
        max_pe = self.parameters.get('max_pe', 20)
        min_roe = self.parameters.get('min_roe', 0.15)
        min_roic = self.parameters.get('min_roic', 0.12)
        max_debt_equity = self.parameters.get('max_debt_equity', 0.5)
        min_profit_margin = self.parameters.get('min_profit_margin', 0.1)
        min_revenue_growth = self.parameters.get('min_revenue_growth', 0.05)
        
        moat_data = data.dropna(subset=['pe_ratio', 'roe', 'roic'])
        
        for symbol in moat_data.index:
            # 기본 재무 지표 확인
            pe_ratio = moat_data.loc[symbol, 'pe_ratio']
            roe = moat_data.loc[symbol, 'roe']
            roic = moat_data.loc[symbol, 'roic']
            debt_equity = moat_data.loc[symbol, 'debt_to_equity']
            profit_margin = moat_data.loc[symbol, 'profit_margin']
            
            # 버핏의 기본 조건 검증
            basic_conditions = [
                0 < pe_ratio <= max_pe,
                roe >= min_roe,
                roic >= min_roic,
                debt_equity <= max_debt_equity,
                profit_margin >= min_profit_margin
            ]
            
            if not all(basic_conditions):
                continue
            
            # 경제적 해자 평가
            moat_score = self._evaluate_economic_moat(moat_data.loc[symbol])
            
            if moat_score >= 0.6:  # 해자 점수 60% 이상
                # 내재가치 대비 할인 정도 계산
                intrinsic_value = self._calculate_intrinsic_value(moat_data.loc[symbol])
                current_price = moat_data.loc[symbol, 'close']
                discount = (intrinsic_value - current_price) / intrinsic_value
                
                # 안전마진 20% 이상일 때만 매수
                if discount >= 0.2:
                    strength = min(1.0, moat_score * discount * 2)
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=strength,
                        confidence=0.85,
                        metadata={
                            'moat_score': moat_score,
                            'intrinsic_value': intrinsic_value,
                            'current_price': current_price,
                            'discount': discount,
                            'pe_ratio': pe_ratio,
                            'roe': roe,
                            'roic': roic
                        }
                    ))
        
        return self.validate_signals(signals)
    
    def _evaluate_economic_moat(self, company_data: pd.Series) -> float:
        """경제적 해자 평가"""
        moat_score = 0.0
        
        # 브랜드 파워 (25%)
        brand_strength = company_data.get('brand_strength', 0.5)
        moat_score += brand_strength * 0.25
        
        # 시장 지배력 (25%)
        market_share = company_data.get('market_share', 0.3)
        if market_share > 0.3:  # 시장 점유율 30% 이상
            moat_score += min(1.0, market_share) * 0.25
        
        # 전환 비용 (20%)
        switching_cost = company_data.get('switching_cost', 0.5)
        moat_score += switching_cost * 0.2
        
        # 지속적 수익성 (15%)
        roe_consistency = self._calculate_roe_consistency(company_data)
        moat_score += roe_consistency * 0.15
        
        # 재투자 효율성 (15%)
        roic = company_data.get('roic', 0.1)
        if roic > 0.15:
            reinvestment_score = min(1.0, roic / 0.3)
            moat_score += reinvestment_score * 0.15
        
        return min(1.0, moat_score)
    
    def _calculate_roe_consistency(self, company_data: pd.Series) -> float:
        """ROE 일관성 평가"""
        # 간단화: ROE가 15% 이상이고 안정적이면 높은 점수
        roe = company_data.get('roe', 0)
        if roe >= 0.15:
            return 1.0
        elif roe >= 0.1:
            return 0.6
        else:
            return 0.2
    
    def _calculate_intrinsic_value(self, company_data: pd.Series) -> float:
        """간단한 내재가치 계산 (DCF 모형 단순화)"""
        # 현재 수익을 기반으로 한 추정
        current_price = company_data.get('close', 100)
        pe_ratio = company_data.get('pe_ratio', 15)
        earnings_per_share = current_price / pe_ratio
        
        # 성장률 추정
        earnings_growth = company_data.get('earnings_growth_5y', 0.08)
        discount_rate = 0.1  # 10% 할인율
        
        # 10년 DCF 단순 계산
        intrinsic_value = 0
        for year in range(1, 11):
            future_earnings = earnings_per_share * (1 + earnings_growth) ** year
            present_value = future_earnings / (1 + discount_rate) ** year
            intrinsic_value += present_value
        
        # 터미널 가치 (단순화)
        terminal_value = (earnings_per_share * (1 + earnings_growth) ** 10 * 15) / (1 + discount_rate) ** 10
        intrinsic_value += terminal_value
        
        return intrinsic_value
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # 집중 투자 (버핏 스타일)
        # 상위 종목에 더 높은 가중치
        signals_sorted = sorted(signals, key=lambda x: x.strength, reverse=True)
        top_signals = signals_sorted[:min(10, len(signals_sorted))]  # 최대 10개 종목
        
        weights = []
        total_strength = sum(signal.strength for signal in top_signals)
        
        for i, signal in enumerate(top_signals):
            # 상위 종목일수록 더 높은 가중치 (집중도 증가)
            position_multiplier = 1.5 if i < 3 else 1.0  # 상위 3개 종목 가중치 증가
            adjusted_strength = signal.strength * position_multiplier
            weight = adjusted_strength / (total_strength * 1.2)  # 조정된 총합으로 나눔
            
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 12. 피터 린치의 PEG 전략
class PeterLynchPEGStrategy(BaseStrategy):
    """피터 린치의 PEG 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("Peter_Lynch_PEG_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="피터 린치의 PEG 전략",
            description="PEG 비율 1.0 이하 성장주 발굴, 10배 주식 추구",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.MEDIUM,
            expected_return="13-18%",
            volatility="16-22%",
            min_investment_period="2년 이상",
            rebalancing_frequency="분기별"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'pe_ratio', 'earnings_growth_rate', 'revenue_growth_rate', 
            'market_cap', 'industry_type', 'consumer_exposure'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        max_peg = self.parameters.get('max_peg', 1.0)
        min_growth_rate = self.parameters.get('min_growth_rate', 0.1)  # 10%
        max_pe = self.parameters.get('max_pe', 30)
        
        peg_data = data.dropna(subset=['pe_ratio', 'earnings_growth_rate'])
        
        for symbol in peg_data.index:
            pe_ratio = peg_data.loc[symbol, 'pe_ratio']
            growth_rate = peg_data.loc[symbol, 'earnings_growth_rate']
            
            # PEG 계산
            if growth_rate <= 0:
                continue
            
            peg_ratio = pe_ratio / (growth_rate * 100)
            
            # 린치의 기본 조건
            conditions = [
                peg_ratio <= max_peg,
                growth_rate >= min_growth_rate,
                pe_ratio <= max_pe,
                pe_ratio > 0
            ]
            
            if not all(conditions):
                continue
            
            # 추가 린치 스타일 평가
            lynch_score = self._evaluate_lynch_criteria(peg_data.loc[symbol], peg_ratio)
            
            if lynch_score >= 0.5:
                # PEG가 낮을수록, 성장률이 높을수록 높은 강도
                growth_bonus = min(1.0, growth_rate / 0.3)  # 30% 성장을 최대로
                peg_bonus = max(0.1, (1.0 - peg_ratio))  # PEG가 낮을수록 높은 점수
                strength = min(1.0, lynch_score * growth_bonus * peg_bonus)
                
                signals.append(Signal(
                    symbol=symbol,
                    timestamp=pd.Timestamp.now(),
                    signal_type='BUY',
                    strength=strength,
                    confidence=0.75,
                    metadata={
                        'peg_ratio': peg_ratio,
                        'growth_rate': growth_rate,
                        'pe_ratio': pe_ratio,
                        'lynch_score': lynch_score
                    }
                ))
        
        return self.validate_signals(signals)
    
    def _evaluate_lynch_criteria(self, company_data: pd.Series, peg_ratio: float) -> float:
        """린치의 추가 평가 기준"""
        score = 0.0
        
        # 1. 이해하기 쉬운 사업 (소비자 노출도)
        consumer_exposure = company_data.get('consumer_exposure', 0.5)
        score += consumer_exposure * 0.3
        
        # 2. 적당한 크기 (너무 크지 않은 기업 선호)
        market_cap = company_data.get('market_cap', 5000)
        if 1000 <= market_cap <= 50000:  # 10억-500억 달러
            size_score = 1.0
        elif market_cap <= 100000:  # 1000억 달러 이하
            size_score = 0.7
        else:
            size_score = 0.3
        score += size_score * 0.2
        
        # 3. 매출 성장률 일관성
        revenue_growth = company_data.get('revenue_growth_rate', 0.05)
        if revenue_growth > 0.1:  # 10% 이상
            score += 0.3
        elif revenue_growth > 0.05:  # 5% 이상
            score += 0.2
        
        # 4. PEG 우수성 (0.5 이하면 보너스)
        if peg_ratio <= 0.5:
            score += 0.2
        
        return min(1.0, score)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # PEG와 성장률 기반 가중치 (성장주 스타일)
        weights = []
        total_strength = sum(signal.strength for signal in signals)
        
        for signal in signals:
            weight = signal.strength / total_strength
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=weight,
                target_weight=weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 13. 벤저민 그레이엄의 방어적 투자
class BenjaminGrahamDefensiveStrategy(BaseStrategy):
    """벤저민 그레이엄의 방어적 투자자 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("Benjamin_Graham_Defensive_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="벤저민 그레이엄의 방어적 투자",
            description="안전성과 수익성을 겸비한 보수적 가치투자",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.LOW,
            complexity=Complexity.MEDIUM,
            expected_return="9-13%",
            volatility="10-16%",
            min_investment_period="3년 이상",
            rebalancing_frequency="연 1회"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'pe_ratio', 'pb_ratio', 'current_ratio', 'debt_to_equity', 
            'dividend_yield', 'earnings_stability', 'dividend_years', 'market_cap'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        # 그레이엄의 방어적 투자자 기준
        max_pe = self.parameters.get('max_pe', 15)
        max_pb = self.parameters.get('max_pb', 1.5)
        min_current_ratio = self.parameters.get('min_current_ratio', 2.0)
        max_debt_equity = self.parameters.get('max_debt_equity', 0.5)
        min_dividend_years = self.parameters.get('min_dividend_years', 3)
        min_market_cap_rank = self.parameters.get('min_market_cap_percentile', 0.7)  # 상위 30%
        
        graham_data = data.dropna(subset=['pe_ratio', 'pb_ratio', 'current_ratio'])
        
        # 시가총액 기준선 계산
        market_cap_threshold = graham_data['market_cap'].quantile(min_market_cap_rank)
        
        for symbol in graham_data.index:
            company_data = graham_data.loc[symbol]
            
            # 그레이엄의 7가지 기준 검증
            graham_criteria = [
                0 < company_data['pe_ratio'] <= max_pe,
                0 < company_data['pb_ratio'] <= max_pb,
                company_data['current_ratio'] >= min_current_ratio,
                company_data['debt_to_equity'] <= max_debt_equity,
                company_data.get('dividend_years', 0) >= min_dividend_years,
                company_data['market_cap'] >= market_cap_threshold,
                company_data.get('earnings_stability', 0) >= 0.7  # 수익 안정성
            ]
            
            passed_criteria = sum(graham_criteria)
            
            # 최소 5개 기준 이상 충족
            if passed_criteria >= 5:
                # 추가 안전성 검증
                safety_score = self._calculate_safety_margin(company_data)
                
                if safety_score >= 0.6:
                    # 충족 기준 수와 안전성을 기반으로 강도 계산
                    criteria_score = passed_criteria / 7
                    strength = min(1.0, criteria_score * safety_score * 1.2)
                    
                    signals.append(Signal(
                        symbol=symbol,
                        timestamp=pd.Timestamp.now(),
                        signal_type='BUY',
                        strength=strength,
                        confidence=0.9,
                        metadata={
                            'passed_criteria': passed_criteria,
                            'safety_score': safety_score,
                            'pe_ratio': company_data['pe_ratio'],
                            'pb_ratio': company_data['pb_ratio'],
                            'current_ratio': company_data['current_ratio']
                        }
                    ))
        
        return self.validate_signals(signals)
    
    def _calculate_safety_margin(self, company_data: pd.Series) -> float:
        """안전마진 계산"""
        safety_score = 0.0
        
        # 유동성 안전성 (30%)
        current_ratio = company_data['current_ratio']
        if current_ratio >= 3.0:
            liquidity_score = 1.0
        elif current_ratio >= 2.0:
            liquidity_score = 0.8
        else:
            liquidity_score = max(0, (current_ratio - 1.0) / 1.0)
        safety_score += liquidity_score * 0.3
        
        # 부채 안전성 (25%)
        debt_equity = company_data['debt_to_equity']
        debt_score = max(0, (0.5 - debt_equity) / 0.5)
        safety_score += debt_score * 0.25
        
        # 밸류에이션 안전성 (25%)
        pe_ratio = company_data['pe_ratio']
        pb_ratio = company_data['pb_ratio']
        if pe_ratio > 0 and pb_ratio > 0:
            pe_score = max(0, (15 - pe_ratio) / 15)
            pb_score = max(0, (1.5 - pb_ratio) / 1.5)
            valuation_score = (pe_score + pb_score) / 2
            safety_score += valuation_score * 0.25
        
        # 배당 안전성 (20%)
        dividend_yield = company_data.get('dividend_yield', 0)
        dividend_years = company_data.get('dividend_years', 0)
        if dividend_yield > 0.02 and dividend_years >= 5:
            dividend_score = min(1.0, (dividend_yield / 0.06) * 0.5 + (dividend_years / 20) * 0.5)
            safety_score += dividend_score * 0.2
        
        return min(1.0, safety_score)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # 보수적 균등 분산 (그레이엄 스타일)
        target_weight = 1.0 / len(signals)
        weights = []
        
        for signal in signals:
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 14. 조엘 그린블라트의 마법공식
class JoelGreenblattMagicFormulaStrategy(BaseStrategy):
    """조엘 그린블라트의 마법공식 전략"""
    
    def __init__(self, **kwargs):
        super().__init__("Joel_Greenblatt_Magic_Formula_Strategy", **kwargs)
    
    def _get_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            name="조엘 그린블라트의 마법공식",
            description="ROE + 수익수익률(E/P) 결합한 체계적 가치투자",
            category=StrategyCategory.ADVANCED,
            risk_level=RiskLevel.MEDIUM,
            complexity=Complexity.MEDIUM,
            expected_return="12-17%",
            volatility="14-20%",
            min_investment_period="3년 이상",
            rebalancing_frequency="연 1회"
        )
    
    def _get_required_data_columns(self) -> List[str]:
        return super()._get_required_data_columns() + [
            'roe', 'pe_ratio', 'roic', 'market_cap'
        ]
    
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        signals = []
        
        min_market_cap = self.parameters.get('min_market_cap', 1000)  # 10억 달러
        top_stocks = self.parameters.get('top_stocks', 30)
        
        magic_data = data.dropna(subset=['roe', 'pe_ratio'])
        
        # 시가총액 필터링
        magic_data = magic_data[magic_data['market_cap'] >= min_market_cap]
        
        if len(magic_data) == 0:
            return []
        
        # 마법공식 랭킹 계산
        magic_scores = []
        
        for symbol in magic_data.index:
            company_data = magic_data.loc[symbol]
            
            # 수익수익률 계산 (E/P = 1/PE)
            pe_ratio = company_data['pe_ratio']
            if pe_ratio <= 0:
                continue
            
            earnings_yield = 1 / pe_ratio
            roe = company_data['roe']
            
            # ROIC 사용 가능하면 ROE 대신 사용
            if 'roic' in company_data and pd.notna(company_data['roic']):
                return_on_capital = company_data['roic']
            else:
                return_on_capital = roe
            
            magic_scores.append({
                'symbol': symbol,
                'earnings_yield': earnings_yield,
                'return_on_capital': return_on_capital,
                'company_data': company_data
            })
        
        if not magic_scores:
            return []
        
        # 각 지표별 순위 계산
        df_scores = pd.DataFrame(magic_scores)
        df_scores['ey_rank'] = df_scores['earnings_yield'].rank(ascending=False)
        df_scores['roc_rank'] = df_scores['return_on_capital'].rank(ascending=False)
        df_scores['combined_rank'] = df_scores['ey_rank'] + df_scores['roc_rank']
        
        # 상위 종목 선별
        df_scores = df_scores.sort_values('combined_rank')
        top_selections = df_scores.head(top_stocks)
        
        for _, row in top_selections.iterrows():
            # 순위가 높을수록 높은 강도
            max_rank = len(df_scores) * 2  # 두 순위 합의 최대값
            strength = 1.0 - (row['combined_rank'] / max_rank)
            
            signals.append(Signal(
                symbol=row['symbol'],
                timestamp=pd.Timestamp.now(),
                signal_type='BUY',
                strength=strength,
                confidence=0.8,
                metadata={
                    'earnings_yield': row['earnings_yield'],
                    'return_on_capital': row['return_on_capital'],
                    'ey_rank': row['ey_rank'],
                    'roc_rank': row['roc_rank'],
                    'combined_rank': row['combined_rank']
                }
            ))
        
        return self.validate_signals(signals)
    
    def calculate_weights(self, signals: List[Signal], 
                         current_portfolio: Optional[Dict[str, float]] = None) -> List[PortfolioWeight]:
        if not signals:
            return []
        
        # 마법공식은 동일 가중치 권장
        target_weight = 1.0 / len(signals)
        weights = []
        
        for signal in signals:
            current_weight = current_portfolio.get(signal.symbol, 0.0) if current_portfolio else 0.0
            
            weights.append(PortfolioWeight(
                symbol=signal.symbol,
                weight=target_weight,
                target_weight=target_weight,
                current_weight=current_weight
            ))
        
        return self.apply_position_sizing(weights)

# 전략 팩토리에 등록
def register_value_strategies():
    """가치투자 전략들을 팩토리에 등록"""
    StrategyFactory.register_strategy("buffett_moat", BuffettMoatStrategy)
    StrategyFactory.register_strategy("peter_lynch_peg", PeterLynchPEGStrategy)
    StrategyFactory.register_strategy("benjamin_graham_defensive", BenjaminGrahamDefensiveStrategy)
    StrategyFactory.register_strategy("joel_greenblatt_magic", JoelGreenblattMagicFormulaStrategy)

# 모듈 로드 시 자동 등록
register_value_strategies()


==================================================
File: C:\Aproject\quant_platform\quant_engine\__init__.py
==================================================
"""
Investment Strategies Package - 개인투자자용 투자전략 20가지
패키지 초기화 및 주요 클래스/함수 export
"""

import logging
from typing import Dict, List, Optional, Any

# 패키지 정보
__version__ = "1.0.0"
__author__ = "Investment Strategy Engine"
__description__ = "20가지 개인투자자용 투자전략 백테스팅 엔진"

# 로깅 설정
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# 코어 모듈들 import
try:
    # 기본 전략 클래스
    from .base_strategy import (
        BaseStrategy, 
        StrategyMetadata, 
        Signal, 
        PortfolioWeight,
        RiskLevel,
        Complexity,
        StrategyCategory,
        calculate_sharpe_ratio,
        calculate_sortino_ratio
    )
    
    # 팩토리 및 매니저
    from .strategy_factory import (
        StrategyFactory,
        StrategyRegistry,
        StrategyManager,
        StrategyLoader,
        strategy_registry,
        create_strategy_combination,
        get_recommended_strategies,
        initialize_strategy_system
    )
    
    # 기술적 지표
    from .technical_indicators import (
        simple_moving_average,
        exponential_moving_average,
        rsi,
        macd,
        bollinger_bands,
        stochastic,
        atr as average_true_range,
        on_balance_volume,
        momentum,
        relative_strength
    )
    
    # 펀더멘털 지표
    from .fundamental_metrics import (
        price_to_earnings_ratio,
        price_to_book_ratio,
        return_on_equity,
        debt_to_equity_ratio,
        current_ratio,
        dividend_yield,
        piotroski_f_score,
        altman_z_score,
        calculate_quality_score
    )
    
    # 포트폴리오 유틸리티
    from .portfolio_utils import (
        equal_weight_portfolio,
        market_cap_weighted_portfolio,
        risk_parity_portfolio,
        minimum_variance_portfolio,
        calculate_rebalancing_trades,
        calculate_portfolio_metrics,
        efficient_frontier,
        kelly_criterion_weights
    )

except ImportError as e:
    logging.warning(f"Some modules could not be imported: {e}")

# 전략 모듈들 import (선택적)
try:
    from . import basic_strategies
    from . import value_strategies  
    from . import growth_momentum_strategies
    from . import cycle_contrarian_strategies
    
    # 전략 시스템 초기화
    initialize_strategy_system()
    
except ImportError as e:
    logging.warning(f"Strategy modules could not be loaded: {e}")

# 공개 API 정의
__all__ = [
    # 버전 정보
    "__version__",
    "__author__", 
    "__description__",
    
    # 코어 클래스들
    "BaseStrategy",
    "StrategyMetadata", 
    "Signal",
    "PortfolioWeight",
    "RiskLevel",
    "Complexity", 
    "StrategyCategory",
    
    # 팩토리 및 매니저
    "StrategyFactory",
    "StrategyRegistry",
    "StrategyManager", 
    "StrategyLoader",
    "strategy_registry",
    
    # 헬퍼 함수들
    "create_strategy_combination",
    "get_recommended_strategies",
    "initialize_strategy_system",
    
    # 기술적 지표 (주요)
    "simple_moving_average",
    "exponential_moving_average", 
    "rsi",
    "macd",
    "bollinger_bands",
    
    # 펀더멘털 지표 (주요)
    "price_to_earnings_ratio",
    "return_on_equity",
    "debt_to_equity_ratio",
    "calculate_quality_score",
    
    # 포트폴리오 함수 (주요)
    "equal_weight_portfolio",
    "risk_parity_portfolio",
    "calculate_portfolio_metrics",
    "kelly_criterion_weights",
    
    # 성과 측정 함수들
    "calculate_sharpe_ratio",
    "calculate_sortino_ratio"
]

# 패키지 레벨 편의 함수들
def get_strategy_list() -> List[str]:
    """사용 가능한 모든 전략 목록 반환"""
    try:
        return strategy_registry.list_strategies()
    except:
        return []

def create_strategy(strategy_name: str, **kwargs) -> Optional[BaseStrategy]:
    """전략 생성 편의 함수"""
    try:
        return strategy_registry.create_strategy(strategy_name, **kwargs)
    except Exception as e:
        logging.error(f"Failed to create strategy {strategy_name}: {e}")
        return None

def get_basic_strategies() -> List[str]:
    """기본 전략 10가지 목록"""
    basic_list = [
        "low_pe",
        "dividend_aristocrats", 
        "simple_momentum",
        "moving_average_cross",
        "rsi_mean_reversion",
        "bollinger_band",
        "small_cap",
        "low_volatility", 
        "quality_factor",
        "regular_rebalancing"
    ]
    available = get_strategy_list()
    return [s for s in basic_list if s in available]

def get_advanced_strategies() -> List[str]:
    """고급 전략 10가지 목록"""
    advanced_list = [
        "buffett_moat",
        "peter_lynch_peg", 
        "benjamin_graham_defensive",
        "joel_greenblatt_magic",
        "william_oneil_canslim",
        "howard_marks_cycle",
        "james_oshaughnessy",
        "ray_dalio_all_weather",
        "david_dreman_contrarian",
        "john_neff_low_pe_dividend"
    ]
    available = get_strategy_list()
    return [s for s in advanced_list if s in available]

def get_strategy_by_risk_level(risk_level: str) -> List[str]:
    """위험도별 전략 필터링"""
    try:
        return strategy_registry.search_strategies(risk_level=risk_level)
    except:
        return []

def get_strategy_by_complexity(complexity: str) -> List[str]:
    """복잡도별 전략 필터링"""
    try:
        return strategy_registry.search_strategies(complexity=complexity)
    except:
        return []

def print_package_info():
    """패키지 정보 출력"""
    total_strategies = len(get_strategy_list())
    basic_count = len(get_basic_strategies())  
    advanced_count = len(get_advanced_strategies())
    
    print(f"""
    ╔════════════════════════════════════════════════════════════╗
    ║           Investment Strategies Package v{__version__}           ║
    ║                                                            ║
    ║  개인투자자를 위한 20가지 투자전략 백테스팅 엔진                   ║
    ║                                                            ║
    ║  📊 전체 전략: {total_strategies}개                                      ║
    ║  📈 기본 전략: {basic_count}개                                      ║  
    ║  🎯 고급 전략: {advanced_count}개                                      ║
    ║                                                            ║
    ║  주요 기능:                                                  ║
    ║  • 기술적 지표 계산                                           ║
    ║  • 펀더멘털 분석                                             ║
    ║  • 포트폴리오 최적화                                          ║
    ║  • 백테스팅 & 성과 측정                                       ║
    ║                                                            ║
    ╚════════════════════════════════════════════════════════════╝
    """)

def quick_start_guide():
    """빠른 시작 가이드"""
    print("""
    🚀 Quick Start Guide:
    
    1. 전략 목록 확인:
       >>> import strategies
       >>> strategies.get_strategy_list()
    
    2. 전략 생성:
       >>> strategy = strategies.create_strategy('low_pe')
    
    3. 신호 생성:
       >>> signals = strategy.generate_signals(data)
    
    4. 포트폴리오 가중치:
       >>> weights = strategy.calculate_weights(signals)
    
    5. 추천 전략:
       >>> user_profile = {'risk_tolerance': 'medium', 'experience_level': 'beginner'}
       >>> recommended = strategies.get_recommended_strategies(user_profile)
    
    자세한 사용법은 각 전략의 메타데이터를 확인하세요.
    """)

# 패키지 로딩 완료 메시지
def _on_import():
    """패키지 import 시 실행"""
    total_strategies = len(get_strategy_list())
    if total_strategies > 0:
        logging.info(f"Investment Strategies Package v{__version__} loaded successfully with {total_strategies} strategies")
    else:
        logging.warning("Investment Strategies Package loaded but no strategies found")

# 패키지 import시 자동 실행
_on_import()

# 사용자 편의를 위한 별칭들
create = create_strategy
list_all = get_strategy_list
list_basic = get_basic_strategies
list_advanced = get_advanced_strategies
info = print_package_info
help = quick_start_guide

# 디버그 모드 설정
DEBUG = False

def set_debug_mode(enabled: bool = True):
    """디버그 모드 설정"""
    global DEBUG
    DEBUG = enabled
    log_level = logging.DEBUG if enabled else logging.INFO
    logging.getLogger().setLevel(log_level)
    
    if enabled:
        logging.info("Debug mode enabled")
    else:
        logging.info("Debug mode disabled") 


